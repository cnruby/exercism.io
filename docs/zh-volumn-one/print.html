<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>以软件篋学习Rust语言</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Chinese">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="foreword/index.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li><ol class="section"><li><a href="foreword/about.html"><strong aria-hidden="true">1.1.</strong> 本书项目结构</a></li><li><a href="foreword/crate.html"><strong aria-hidden="true">1.2.</strong> 关于作业区和软件篋实例</a></li><li><a href="foreword/cargo.html"><strong aria-hidden="true">1.3.</strong> 关于Cargo工具基础命令</a></li><li><a href="foreword/rust.html"><strong aria-hidden="true">1.4.</strong> Rust语言新思维和新概念</a></li></ol></li><li><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> 软件篋hello_exercism</a></li><li><ol class="section"><li><a href="hello-world/about.html"><strong aria-hidden="true">2.1.</strong> 关于软件篋项目</a></li><li><a href="hello-world/commands-lib.html"><strong aria-hidden="true">2.2.</strong> 共享篋：开发命令</a></li><li><a href="hello-world/lib.html"><strong aria-hidden="true">2.3.</strong> 共享篋：程序代码解释</a></li><li><a href="hello-world/lib-tests.html"><strong aria-hidden="true">2.4.</strong> 共享篋：目录tests的测试代码解释</a></li><li><a href="hello-world/src-tests.html"><strong aria-hidden="true">2.5.</strong> 共享篋：目录src的测试代码解释</a></li><li><a href="hello-world/commands-local.html"><strong aria-hidden="true">2.6.</strong> 本地程序：开发命令</a></li><li><a href="hello-world/bin-local.html"><strong aria-hidden="true">2.7.</strong> 本地程序：程序代码解释</a></li><li><a href="hello-world/commands-bin.html"><strong aria-hidden="true">2.8.</strong> 仓库程序：开发命令</a></li><li><a href="hello-world/bin.html"><strong aria-hidden="true">2.9.</strong> 仓库程序：程序代码解释</a></li><li><a href="hello-world/off-topic.html"><strong aria-hidden="true">2.10.</strong> 题外话</a></li></ol></li><li><a href="hello-borrowing/index.html"><strong aria-hidden="true">3.</strong> 软件篋borrowing_exerci</a></li><li><ol class="section"><li><a href="hello-borrowing/about.html"><strong aria-hidden="true">3.1.</strong> 关于软件篋borrowing_exerci</a></li><li><a href="hello-borrowing/develop.html"><strong aria-hidden="true">3.2.</strong> 开发软件篋borrowing_exerci</a></li><li><a href="hello-borrowing/apply.html"><strong aria-hidden="true">3.3.</strong> 使用软件篋borrowing_exerci</a></li></ol></li><li><a href="hello-trait/index.html"><strong aria-hidden="true">4.</strong> 软件篋trait_exerci</a></li><li><ol class="section"><li><a href="hello-trait/examples-struct.html"><strong aria-hidden="true">4.1.</strong> 类型关键词struct</a></li><li><a href="hello-trait/examples-impl.html"><strong aria-hidden="true">4.2.</strong> 实现关键词impl与方法代码实现</a></li><li><a href="hello-trait/examples-methods.html"><strong aria-hidden="true">4.3.</strong> 方法代码实现</a></li><li><a href="hello-trait/examples-trait.html"><strong aria-hidden="true">4.4.</strong> 衔接关键词trait与修饰关键词mut</a></li><li><a href="hello-trait/about.html"><strong aria-hidden="true">4.5.</strong> 关于软件篋项目</a></li><li><a href="hello-trait/commands-lib.html"><strong aria-hidden="true">4.6.</strong> 共享篋：开发命令</a></li><li><a href="hello-trait/lib-structure.html"><strong aria-hidden="true">4.7.</strong> 共享篋：程序结构解释</a></li><li><a href="hello-trait/lib-codes.html"><strong aria-hidden="true">4.8.</strong> 共享篋：程序代码解释</a></li><li><a href="hello-trait/lib-tests.html"><strong aria-hidden="true">4.9.</strong> 共享篋：目录tests的测试代码解释</a></li><li><a href="hello-trait/off-topic.html"><strong aria-hidden="true">4.10.</strong> 题外话</a></li></ol></li><li><a href="hello-mod-trait/index.html"><strong aria-hidden="true">5.</strong> 软件篋mod_trait_exerci</a></li><li><ol class="section"><li><a href="hello-mod-trait/about.html"><strong aria-hidden="true">5.1.</strong> 关于软件篋mod_trait_exerci</a></li><li><a href="hello-mod-trait/develop.html"><strong aria-hidden="true">5.2.</strong> 开发软件篋mod_trait_exerci</a></li><li><a href="hello-mod-trait/apply.html"><strong aria-hidden="true">5.3.</strong> 使用软件篋mod_trait_exerci</a></li></ol></li><li><a href="hello-deref/index.html"><strong aria-hidden="true">6.</strong> 软件篋deref_exerci</a></li><li><ol class="section"><li><a href="hello-deref/about.html"><strong aria-hidden="true">6.1.</strong> 关于软件篋deref_exerci</a></li><li><a href="hello-deref/develop.html"><strong aria-hidden="true">6.2.</strong> 开发软件篋deref_exerci</a></li><li><a href="hello-deref/apply.html"><strong aria-hidden="true">6.3.</strong> 使用软件篋deref_exerci</a></li></ol></li><li><a href="hello-macro/index.html"><strong aria-hidden="true">7.</strong> 软件篋macro_exerci</a></li><li><ol class="section"><li><a href="hello-macro/about.html"><strong aria-hidden="true">7.1.</strong> 关于软件篋macro_exerci</a></li><li><a href="hello-macro/develop.html"><strong aria-hidden="true">7.2.</strong> 开发软件篋macro_exerci</a></li><li><a href="hello-macro/apply.html"><strong aria-hidden="true">7.3.</strong> 使用软件篋macro_exerci</a></li></ol></li><li><a href="hello-generics/index.html"><strong aria-hidden="true">8.</strong> 软件篋generics_exerci</a></li><li><ol class="section"><li><a href="hello-generics/about.html"><strong aria-hidden="true">8.1.</strong> 关于软件篋generics_exerci</a></li><li><a href="hello-generics/develop.html"><strong aria-hidden="true">8.2.</strong> 开发软件篋generics_exerci</a></li><li><a href="hello-generics/apply.html"><strong aria-hidden="true">8.3.</strong> 使用软件篋generics_exerci</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">以软件篋学习Rust语言</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#前言" id="前言">前言</a></h1>
<h2><a class="header" href="#rust语言" id="rust语言">Rust语言</a></h2>
<p>　　Rust是一门可靠高效、保证安全、支持并发和似C语言同级速度的计算机编程语言。</p>
<h2><a class="header" href="#rustup版本管理工具" id="rustup版本管理工具">rustup版本管理工具</a></h2>
<p>　　rustup是Rust语言官方的版本管理工具，负责安装Rust语言及其版本管理。通过rustup工具实现了Rust语言安装工作。</p>
<h2><a class="header" href="#cargo包管理器" id="cargo包管理器">Cargo包管理器</a></h2>
<p>　　Cargo是一款Rust语言官方的包管理器和开发工具，负责Rust软件篋的依赖管理，并且能够下载、开发、编译、生成和分发的软件篋。一旦安装了Rust语言，该工具也自动完成了安装。</p>
<h2><a class="header" href="#crateio" id="crateio">Crate.io</a></h2>
<p>　　Crate.io是Rust语言软件篋的官方仓库，负责软件篋登记、托管和存储等功能服务。</p>
<h2><a class="header" href="#关于本书" id="关于本书">关于本书</a></h2>
<p>　　以开发软件篋过程，学习和理解Rust语言的全新设计思路及其重要概念。</p>
<h2><a class="header" href="#重要rust语言链接" id="重要rust语言链接">重要Rust语言链接</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/">Rust官方网站</a></li>
<li><a href="https://rustup.rs/">rustup官方网站</a></li>
<li><a href="https://github.com/rust-lang/cargo">Cargo项目源代码</a></li>
<li><a href="https://crates.io/">Crates s.io官方网站</a></li>
</ul>
<h2><a class="header" href="#重要工具链接链接" id="重要工具链接链接">重要工具链接链接</a></h2>
<ul>
<li><a href="https://www.tablesgenerator.com/">Tables Generator</a></li>
<li><a href="https://www.compart.com/de/unicode/category/So">Liste der Unicode-Zeichen der Kategorie „Sonstiges Symbol“</a></li>
<li><a href="https://sketch.io/sketchpad/">Sketchpad - Draw, Create, Share!</a></li>
<li><a href="https://shields.io/">Quality metadata badges</a></li>
<li><a href="https://www.appveyor.com/">Continuous Integration and Deployment service for Windows and Linux | AppVeyor</a></li>
<li><a href="https://github.com/nushell/nushell">Nu Shell</a></li>
<li><a href="https://markdown.de/">Markdown: Syntax</a></li>
<li><a href="https://crates.io/category_slugs">category_slugs from crates.io</a></li>
</ul>
<h1><a class="header" href="#本书项目结构" id="本书项目结构">本书项目结构</a></h1>
<h2><a class="header" href="#篇目" id="篇目">篇目</a></h2>
<ol>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%92%8C%E7%AF%8B">作业区和篋</a></li>
<li><a href="foreword/about.html#%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">共享篋和应用程序</a></li>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">作业区命名法则</a></li>
<li><a href="foreword/about.html#%E7%AF%8B%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">篋命名法则</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：项目类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：篋类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E4%BD%9C%E4%B8%9A%E5%8C%BA%E6%89%80%E6%9C%89%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">实例：作业区所有目录文件清单</a></li>
<li><a href="foreword/about.html#%E6%9C%AC%E4%B9%A6%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">本书使用符号说明</a></li>
<li><a href="foreword/about.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#作业区和篋" id="作业区和篋">作业区和篋</a></h2>
<p>　　Cargo项目是Cargo工具所生成的目录和文件内容，称之为软件篋，或者简称为篋。</p>
<p>　　软件篋项目是由若干个Cargo项目或者说软件篋组成，在本书里，软件篋项目也简称为作业区（workspace）、整体项目或者项目。所有Cargo项目都是在作业区目录之下，且这些项目在相同目录层上。所有项目名称也是目录名称。每一章最顶层目录是作业区目录。</p>
<h2><a class="header" href="#共享篋和应用程序" id="共享篋和应用程序">共享篋和应用程序</a></h2>
<p>　　每一个软件篋源代码存在于一个Cargo项目里。</p>
<p>　　把Cargo项目软件篋（library package）发布到网站crates.io的共享软件篋，简称共享篋。</p>
<p>　　除了这个共享软件篋的Cargo项目外，还有一个使用本地共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为本地程序。其目的是在发布共享篋之前，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<p>　　另外，一个使用仓库crates.io里共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为仓库程序。其目的是在发布共享软件篋之后，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<h2><a class="header" href="#作业区命名法则" id="作业区命名法则">作业区命名法则</a></h2>
<p>　　作业区目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#篋命名法则" id="篋命名法则">篋命名法则</a></h2>
<p>　　按照Rust语言命名法则，共享软件篋名称使用小蛇式命名（lower snake case）。</p>
<p>　　可执行程序。其目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#实例项目类型清单" id="实例项目类型清单">实例：项目类型清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例篋类型清单" id="实例篋类型清单">实例：篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例作业区所有目录文件清单" id="实例作业区所有目录文件清单">实例：作业区所有目录文件清单</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── hello.rs
    └── lib-hello
        ├── Cargo.lock
        ├── Cargo.toml
        ├── Cargo.txt
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   └── lib.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.r
</code></pre>
<h2><a class="header" href="#本书使用符号说明" id="本书使用符号说明">本书使用符号说明</a></h2>
<table><thead><tr><th>符号</th><th>英文单词</th><th>说明</th><th>要求</th><th>实例</th></tr></thead><tbody>
<tr><td>Ⓓ</td><td>default</td><td>叙述Rust语言默认情况</td><td>必须记住</td><td>Ⓓ 所有模块和函数默认情况下都是私有的。</td></tr>
<tr><td>ⓡ</td><td>regulation</td><td>阐述Rust语言规则</td><td>必须记住</td><td>ⓡ 所有字符串文字类型都是引用，且具有静态生命周期。</td></tr>
<tr><td>Ⓒ</td><td>consensus</td><td>解释约定而非强制方法</td><td>最好记住</td><td>Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</td></tr>
<tr><td>Ⓘ</td><td>idea</td><td>必须记住</td><td>计算机技术和Rust语言基本概念</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于作业区和软件篋crate实例" id="关于作业区和软件篋crate实例">关于作业区和软件篋（Crate）实例</a></h1>
<p>　　软件篋（Crate）是其他语言的库（library）或包（package）的同义词。软件篋可以生成这里称之为应用程序的可执行文件或共享库，</p>
<h2><a class="header" href="#实例创建作业区空间" id="实例创建作业区空间">实例：创建作业区空间</a></h2>
<pre><code class="language-bash"># 创建一个工作空间
mkdir workpsaces &amp;&amp; cd workpsaces
</code></pre>
<h2><a class="header" href="#实例创建作业区" id="实例创建作业区">实例：创建作业区</a></h2>
<pre><code class="language-bash"># 创建一个作业区hello-world
mkdir hello-world &amp;&amp; cd hello-world
# 创建一个作业区配置文件
touch Cargo.toml
# 作业区存在四个软件篋
# 注意：下面两行代码是一行命令
echo '[workspace]
members = [&quot;lib-hello&quot;, &quot;bin-hello&quot;, &quot;bin-local-hello&quot;, &quot;lib-extern&quot;]' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#实例创建默认共享软件篋程序命令" id="实例创建默认共享软件篋程序命令">实例：创建默认共享软件篋程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;crate-project-name&gt;
# 命令实例，如创建名称为lib-hello的共享篋程序项目目录
mkdir lib-hello
# 进入软件篋程序根目录
cd lib-hello
# 命令说明：
# cargo init --name &lt;crate_name&gt; --lib
# 命令实例，如创建名称为hello_exercism的软件篋程序
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#实例创建默认可执行的应用程序命令" id="实例创建默认可执行的应用程序命令">实例：创建默认可执行的应用程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;app-project-name&gt;
# 命令实例，如创建名称为bin-hello的应用程序项目目录
mkdir bin-hello
# 进入应用程序根目录
cd bin-hello
# 命令说明
# cargo init --name &lt;app-name&gt; --bin
# 命令实例，如创建名称为bin-hello的应用程序
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#实例说明共享软件篋结构" id="实例说明共享软件篋结构">实例：说明共享软件篋结构</a></h2>
<p>　　使用软件工具Cargo，在默认Cargo项目基础上，这里除了增加了默认说明文件README.md外，还有增加了两个Cargo默认目录：tests和examples，同时在两个目录下增加了两个rust程序文件，其结果如下：</p>
<pre><code>── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   └── hello.rs
    ├── src
    │   └── lib.rs
    └── tests
        └── hello.rs
</code></pre>
<p>　　在上面的结构里，除了两个文件hello.rs之外，其他都是Cargo项目的默认目录和文件。这些目录和文件都是与Cargo工具默认命令相关的。Cargo项目还有其他默认目录和文件。目录src下的默认文件lib.rs是共享篋的入口文件。</p>
<h2><a class="header" href="#参考资料" id="参考资料">参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html">a4.cargo,crates_and_basic_project_structure</a></li>
</ul>
<h1><a class="header" href="#关于cargo工具基础命令" id="关于cargo工具基础命令">关于Cargo工具基础命令</a></h1>
<p>　　安装Rust语言软件篋存在两个行为，其目的和作用是不同的。使用软件工具rustup安装的软件篋是支持版本管理工具，而使用软件工具Cargo安装的软件篋是支持项目级开发环境。</p>
<h2><a class="header" href="#编写规范格式代码工具-rustfmt" id="编写规范格式代码工具-rustfmt">编写规范格式代码工具 Rustfmt</a></h2>
<h3><a class="header" href="#安装rustfmt命令" id="安装rustfmt命令">安装Rustfmt命令</a></h3>
<pre><code>rustup self update
rustup component add rustfmt
</code></pre>
<h3><a class="header" href="#使用rustfmt命令" id="使用rustfmt命令">使用Rustfmt命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo fmt
</code></pre>
<h2><a class="header" href="#编写有效代码工具-clippy" id="编写有效代码工具-clippy">编写有效代码工具 Clippy</a></h2>
<h3><a class="header" href="#安装clippy命令" id="安装clippy命令">安装Clippy命令</a></h3>
<pre><code>rustup self update
rustup component add clippy
</code></pre>
<h3><a class="header" href="#使用clippy命令" id="使用clippy命令">使用Clippy命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo clippy
</code></pre>
<h2><a class="header" href="#说明cargo软件篋开发命令" id="说明cargo软件篋开发命令">说明Cargo软件篋开发命令</a></h2>
<p>　　除了上面两个开发工具命令之外，Cargo项目还有自身命令：</p>
<h3><a class="header" href="#测试代码运行命令" id="测试代码运行命令">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目和作业区 --
# 进来Cargo项目根目录
# 默认测试命令
# 说明：测试在目录tests下的所有测试文件
cargo test
</code></pre>
<h3><a class="header" href="#运行应用程序命令" id="运行应用程序命令">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目 --
# 进来Cargo项目根目录
# 命令说明：
# cargo run --example &lt;程序文件名称&gt;
# 命令实例，如运行在目录examples下文件名称为hello.rs的应用程序
cargo run --example hello
</code></pre>
<h3><a class="header" href="#运行应用程序命令-1" id="运行应用程序命令-1">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 仅适用于Cargo应用程序项目 --
# 进来Cargo项目根目录
# 默认运行命令
# 说明：运行目录src下默认入口文件main.rs
cargo run
</code></pre>
<h2><a class="header" href="#说明cargo作业区开发命令" id="说明cargo作业区开发命令">说明Cargo作业区开发命令</a></h2>
<h3><a class="header" href="#测试代码运行命令-1" id="测试代码运行命令-1">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区和所有Cargo项目 --
# 进来作业区根目录
# 命令说明：
# cargo test --package &lt;篋名称&gt;
# 或者
# cargo test -p &lt;篋名称&gt;
# 命令实例，如运行在Cargo项目lib-hello下共享篋名称为hello_exercism
cargo test -p hello_exercism
</code></pre>
<h3><a class="header" href="#运行应用程序命令-2" id="运行应用程序命令-2">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区内Cargo应用程序项目 --
# 进来作业区根目录
# 命令说明：
# cargo run --package &lt;篋名称&gt;
# 或者
# cargo run -p &lt;软件篋名称&gt;
# 命令实例，如运行在Cargo项目bin-hello下篋名称为bin-hello
cargo run -p bin-hello
</code></pre>
<p>　　后续还将介绍上面Cargo工具的其他实用命令。</p>
<h1><a class="header" href="#rust语言新思维和新概念" id="rust语言新思维和新概念">Rust语言新思维和新概念</a></h1>
<h2><a class="header" href="#变量生命期" id="变量生命期">变量生命期</a></h2>
<h2><a class="header" href="#不可变量immutable和可变量mutable" id="不可变量immutable和可变量mutable">不可变量(Immutable)和可变量(Mutable)</a></h2>
<h2><a class="header" href="#表达式expression和语句statements" id="表达式expression和语句statements">表达式(Expression)和语句(statements)</a></h2>
<h2><a class="header" href="#方法method和函数function" id="方法method和函数function">方法(method)和函数(function)</a></h2>
<h2><a class="header" href="#类和对象" id="类和对象">类和对象</a></h2>
<h2><a class="header" href="#全局软件篋和项目软件篋" id="全局软件篋和项目软件篋">全局软件篋和项目软件篋</a></h2>
<h1><a class="header" href="#关于软件篋项目hello-world" id="关于软件篋项目hello-world">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#项目目标" id="项目目标">项目目标</a></h2>
<p>　　学习和理解如何开发Rust语言的软件篋基本思路和方法，同时了解该项目的其他Cargo项目开发过程和方法。</p>
<h2><a class="header" href="#主题内容" id="主题内容">主题内容</a></h2>
<ul>
<li>了解和学习Cargo工具作业区概念</li>
<li>学习和理解共享软件篋整个开发过程</li>
<li>了解和学习单元测试和集成测试基本概念</li>
</ul>
<h2><a class="header" href="#关键词内容" id="关键词内容">关键词内容</a></h2>
<table><thead><tr><th>说明</th><th>关键词</th><th>链接</th></tr></thead><tbody>
<tr><td>实例定义</td><td>let</td><td></td></tr>
<tr><td>公共修饰</td><td>pub</td><td></td></tr>
<tr><td>函数和方法</td><td>fn</td><td></td></tr>
<tr><td>模块定义</td><td>mod</td><td></td></tr>
<tr><td>生命周期修饰</td><td>'</td><td></td></tr>
<tr><td>静态修饰</td><td>static</td><td></td></tr>
<tr><td>模块关联</td><td>super</td><td></td></tr>
<tr><td>无名氏</td><td>_</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#类型内容" id="类型内容">类型内容</a></h2>
<table><thead><tr><th>归类</th><th>数据类型</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>基本数据类型</td><td>&amp;str</td><td>字符串文字</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#宏内容" id="宏内容">宏内容</a></h2>
<table><thead><tr><th>归类</th><th>宏名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库宏</td><td>println!</td><td>打印输出</td><td></td></tr>
<tr><td>标准库宏</td><td>assert_eq!</td><td>相同值测试</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#注释内容" id="注释内容">注释内容</a></h2>
<table><thead><tr><th>归类</th><th>注释名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库注释</td><td>#[test]</td><td>注释测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[cfg(test)]</td><td>注释有条件运行测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[path=&quot;.&quot;]</td><td>注释模块路径</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#命名规范" id="命名规范">命名规范</a></h2>
<table><thead><tr><th>命名对象</th><th>命名规范</th><th>实例</th><th>链接</th></tr></thead><tbody>
<tr><td>共享软件箧</td><td>小蛇式命名</td><td>hello_exercism</td><td></td></tr>
<tr><td>程序软件箧</td><td>小蛇式命名或短横线命名</td><td>bin-hello</td><td></td></tr>
<tr><td>函数和方法</td><td>小蛇式命名</td><td>it_works_at_private()</td><td></td></tr>
<tr><td>模块</td><td>小蛇式命名</td><td>owned_hello</td><td></td></tr>
<tr><td>变量</td><td>小蛇式命名</td><td>_</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于软件篋项目hello-world-1" id="关于软件篋项目hello-world-1">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#学习内容" id="学习内容">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
<li>了解项目目录和文件结构</li>
</ul>
<h2><a class="header" href="#篇目-1" id="篇目-1">篇目</a></h2>
<ol>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-world/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%B8%85%E5%8D%95">项目目录清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">项目文件清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A0%91">项目结构树</a></li>
<li><a href="hello-world/about.html#%E9%A2%98%E5%A4%96%E8%AF%9D%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%91%BD%E4%BB%A4">题外话：目录与命令</a></li>
</ol>
<h2><a class="header" href="#项目名称清单" id="项目名称清单">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
<tr><td>共享篋</td><td>lib-extern</td><td>./hello-world/lib-extern</td><td>作为第三方共享篋实例使用</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单" id="软件篋类型清单">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
<tr><td>共享软件篋</td><td>hello_extern</td><td>./hello-world/lib-extern</td></tr>
</tbody></table>
<h2><a class="header" href="#项目目录清单" id="项目目录清单">项目目录清单</a></h2>
<table><thead><tr><th>目录名称</th><th>根目录说明</th><th>生成方式</th></tr></thead><tbody>
<tr><td>src</td><td>篋源代码目录</td><td>Cargo命令</td></tr>
<tr><td>src/integration_tests</td><td>篋源代码集成测试目录</td><td>用户手动命令</td></tr>
<tr><td>src/private_tests</td><td>篋源代码私有代码测试目录</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>篋测试源代码目录</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>篋实例源代码目录</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>篋构建目录</td><td>Cargo命令</td></tr>
<tr><td>debug</td><td>篋调试构建目录</td><td>Cargo命令</td></tr>
<tr><td>release</td><td>篋版本构建目录</td><td>Cargo命令</td></tr>
</tbody></table>
<h2><a class="header" href="#项目文件清单" id="项目文件清单">项目文件清单</a></h2>
<table><thead><tr><th>名称</th><th>说明</th><th>内容属性</th><th>名称属性</th></tr></thead><tbody>
<tr><td>README.md</td><td>项目说明文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.lock</td><td>项目配置锁定文件</td><td>不可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.toml</td><td>项目配置锁定文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>main.rs</td><td>可执行软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>lib.rs</td><td>共享软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>mod.rs</td><td>篋模块的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>i_hello.rs</td><td>集成测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>u_hello.rs</td><td>单元测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>owned_hello.rs</td><td>私有代码测试文件</td><td>可修改</td><td>可修改</td></tr>
</tbody></table>
<h2><a class="header" href="#项目结构树" id="项目结构树">项目结构树</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── i_hello.rs
    ├── lib-extern
    │   ├── Cargo.toml
    │   ├── README.md
    │   ├── src
    │   │   └── lib.rs
    │   └── tests
    │       └── u_hello.rs
    └── lib-hello
        ├── Cargo.toml
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   ├── integration_tests
        │   │   ├── i_hello.rs
        │   │   └── mod.rs
        │   ├── lib.rs
        │   └── private_tests
        │       ├── mod.rs
        │       └── owned_hello.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.rs
</code></pre>
<h2><a class="header" href="#题外话目录与命令" id="题外话目录与命令">题外话：目录与命令</a></h2>
<table><thead><tr><th>目录名称</th><th>生成命令</th><th>删除命令</th></tr></thead><tbody>
<tr><td>src</td><td>cargo new &lt;project_name&gt; <br/> cargo new &lt;project_name&gt; --lib <br/> cargo new &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; <br/> cargo init --name &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; --lib</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>随下面命令自动生成</td><td>cargo clean</td></tr>
<tr><td>debug</td><td>cargo build 或者 cargo run</td><td>cargo clean --target-dir target/debug</td></tr>
<tr><td>release</td><td>cargo build --release <br/> cargo run --release</td><td>cargo clean --release <br/> cargo clean --target-dir target/release</td></tr>
</tbody></table>
<h1><a class="header" href="#共享篋开发命令" id="共享篋开发命令">共享篋：开发命令</a></h1>
<h2><a class="header" href="#学习内容-1" id="学习内容-1">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用共享篋项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-2" id="篇目-2">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-lib.html#%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%AF%8B%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建共享篋项目命令</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和单元测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和集成测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">执行共享篋和测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">执行共享篋的实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E6%96%87%E6%A1%A3">开发共享篋文档</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">发布共享篋准备工作</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B">发布共享篋</a></li>
</ol>
<h2><a class="header" href="#创建共享篋项目命令" id="创建共享篋项目命令">创建共享篋项目命令</a></h2>
<pre><code class="language-bash"># 创建共享篋项目命令
# 先进入作业区根目录，且创建项目目录，然后进入共享篋根目录
mkdir lib-hello &amp;&amp; cd lib-hello
# 创建名称为hello_exercism的共享篋
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#开发共享篋和单元测试代码" id="开发共享篋和单元测试代码">开发共享篋和单元测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和单元测试代码
vi Cargo.toml
vi src/lib.rs
mkdir tests
touch tests/u_hello.rs
vi tests/u_hello.rs
touch tests/i_hello.rs
vi tests/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码" id="开发共享篋的单元实例代码">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码-1" id="开发共享篋的单元实例代码-1">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋和集成测试代码" id="开发共享篋和集成测试代码">开发共享篋和集成测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和集成测试代码
echo 'i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}' &gt;&gt; Cargo.toml
touch tests/i_hello.rs
vi tests/i_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#执行共享篋和测试代码" id="执行共享篋和测试代码">执行共享篋和测试代码</a></h2>
<pre><code class="language-bash"># 执行共享篋和测试代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo test
</code></pre>
<h2><a class="header" href="#执行共享篋的实例代码" id="执行共享篋的实例代码">执行共享篋的实例代码</a></h2>
<pre><code class="language-bash"># 执行共享篋的实例代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo run --example u_hello
cargo run --example i_hello
</code></pre>
<h2><a class="header" href="#开发共享篋文档" id="开发共享篋文档">开发共享篋文档</a></h2>
<pre><code class="language-bash"># 开发共享篋文档
mkdir -p ../../docs/hello-world
cargo doc
cp -rf ../target/doc/. ../../docs/hello-world/.
</code></pre>
<h2><a class="header" href="#发布共享篋准备工作" id="发布共享篋准备工作">发布共享篋准备工作</a></h2>
<pre><code class="language-bash"># 发布共享篋准备工作
# 注册网站crates.io帐号
# 登录网站crates.io
# 从网站crates.io获取token，如下所示
# 在本地电脑运行下面命令
cargo login &lt;token&gt;
</code></pre>
<p><img src="hello-world/../../images/crates_io_api_access_new_token.png" alt="image" />
<img src="hello-world/../../images/crates_io_api_access_create.png" alt="image" /></p>
<h2><a class="header" href="#发布共享篋" id="发布共享篋">发布共享篋</a></h2>
<pre><code class="language-bash">## 提交代码
cargo package
cargo publish
</code></pre>
<h1><a class="header" href="#共享软件篋hello_exercism程序代码解释" id="共享软件篋hello_exercism程序代码解释">共享软件篋hello_exercism：程序代码解释</a></h1>
<p>　　共享软件篋本身只能提供给其他共享篋和应用程序使用。Cargo工具实现了项目内所有目录和文件有机联系在一起。当运行测试代码或者实例代码时，这些代码都知道应该怎么样连接到正在开发的共享篋。</p>
<h2><a class="header" href="#学习内容-2" id="学习内容-2">学习内容</a></h2>
<ul>
<li>阐述共享篋文件功能</li>
<li>理解项目共享篋程序代码</li>
</ul>
<h2><a class="header" href="#篇目-3" id="篇目-3">篇目</a></h2>
<ol>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/lib.html#%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6librs%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">程序文件lib.rs的核心代码</a></li>
<li><a href="hello-world/lib.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B">静态生命周期的字符串文字类型</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dmod%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8Dpub">关键词mod与关键词pub</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的单元实例文件</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E9%9B%86%E6%88%90%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的集成实例文件</a></li>
<li><a href="hello-world/lib.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-world/lib.html#rust%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8D">Rust语言类型与关键词</a></li>
<li><a href="hello-world/lib.html#%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9A%84%E6%A8%A1%E5%9D%97">浅谈软件篋的模块</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dlet">关键词let</a></li>
<li><a href="hello-world/lib.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A8%A1%E5%9D%97">表达式、语句和模块</a></li>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">项目配置文件</a></li>
<li><a href="hello-world/lib.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml" id="项目配置文件cargotoml">项目配置文件Cargo.toml</a></h2>
<p>　　文件Cargo.toml是由用户编写的描述项目共享篋依赖关系。而文件Cargo.lock包含有关共享软件篋的依赖项的确切信息。它是由Cargo工具自动生成和维护的，不应手动对其进行编辑。</p>
<pre><code class="language-toml"># Crate Configuration File: ./Cargo.toml
[package]
name = &quot;hello_exercism&quot;
version = &quot;0.5.5&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
repository = &quot;https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world&quot;
homepage = &quot;https://crates.io/crates/hello_exercism&quot;
documentation = &quot;https://cnruby.github.io/learn-rust-by-crates/hello-world/hello_exercism/&quot;
categories = [&quot;development-tools::testing&quot;]
description = &quot;how to create an own crate&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#hello_extern = { version = &quot;0.1.1&quot;}
i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}

</code></pre>
<p>　　在文件Cargo.toml里，最重要的一项是共享软件篋名称：name。这是使用该共享篋的入口名称。这里默认模块名称为hello_exercism。</p>
<p>　　最常用的一节是共享篋依赖关系：[dependencies]。这里有一行依赖关系代码，说明共享篋有赖于外部共享篋。这里使用了软件篋hello_exercism的已经发布的版本，只是为了解释问题和说明方便，实际上可以依赖所有需要的共享篋。</p>
<h2><a class="header" href="#程序文件librs的核心代码" id="程序文件librs的核心代码">程序文件lib.rs的核心代码</a></h2>
<p>　　程序文件lib.rs是由三部分代码。第一部分是共享篋核心代码：两个函数hello()和hallo()。第二部分是私有代码测试函数。第三部分是集成测试函数。这里仅仅说明该程序两个函数的功能，将在后面章节说明其它两个部分的测试代码。</p>
<p>　　程序文件lib.rs是共享篋的入口文件。它有两个函数hello()和hallo()，其功能都是返回一个字符串文字。hello()返回英文问候，而hallo()返回德文问候。它们返回的类型也都是&amp;'static str的字符串，这一类型是静态生命周期的字符串文字。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#静态生命周期的字符串文字类型" id="静态生命周期的字符串文字类型">静态生命周期的字符串文字类型</a></h2>
<p>　　程序文件lib.rs里，两个函数的返回类型都是：静态生命周期的字符串文字类型。</p>
<p>　　ⓡ 所有字符串文字类型都是引用，且具有静态生命周期的功能。</p>
<p>　　↳ 这里的函数返回值是包含一个引用字符串文字类型值，所以函数返回类型也要此类型<code>&amp;str</code>。因为在整个程序过程中需要该类型是有效的，所以此类型还要增加静态生命周期<code>'static</code>修饰关键词。</p>
<h2><a class="header" href="#关键词mod与关键词pub" id="关键词mod与关键词pub">关键词mod与关键词pub</a></h2>
<p>　　Ⓓ 在默认情况下，无论使用关键词mod定义的模块，还使用关键词fn定义的函数，它们都是私有的。要使得它们可公开访问的话，就需要使用修饰词关键词'pub'。</p>
<p>　　↳ 程序文件lib.rs里，hello()是公共可访问的函数，而hallo()只是模块hello_exercism内可访问的私有函数。该软件篋的公共接口只有：函数hello()。</p>
<p>　　Ⓓ 共享篋模块默认是公开的。</p>
<p>　　↳ 这里共享篋模块名称是hello_exercism，尽管既没有关键词mod也没有关键词pub出现，但是Rust语言已经给了该模块名称这两个关键词。</p>
<h2><a class="header" href="#实例目录的单元实例文件" id="实例目录的单元实例文件">实例目录的单元实例文件</a></h2>
<p>　　单元实例仅仅测试此软件篋自身的功能。</p>
<p>　　ⓡ 凡是存在main()函数的Rust程序都是可执行的。</p>
<p>　　这个程序的功能是调用了该项目的软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。</p>
<p>　　Ⓓ 在运行实例目录下可执行文件时，Cargo工具自动会调用程序lib.rs。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/u_hello.rs
fn main() {
    println!(&quot;{}&quot;, hello_exercism::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example u_hello -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#实例目录的集成实例文件" id="实例目录的集成实例文件">实例目录的集成实例文件</a></h2>
<p>　　集成实例测试此共享篋与外部其它共享篋的功能。</p>
<p>　　这个程序的功能是调用了外部软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。此外，还比较了正在开发的软件篋与外部软件篋的函数返回值。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/i_hello.rs
fn main() {
    println!(&quot;{}&quot;, i_crate::hello());
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example i_hello -q
Hello, World!
Hallo, Welt!
</code></pre>
<h2><a class="header" href="#题外话" id="题外话">题外话</a></h2>
<h3><a class="header" href="#rust语言类型与关键词" id="rust语言类型与关键词">Rust语言类型与关键词</a></h3>
<p>　　对于修饰词关键词'static'，Rust语言以与常量类似的方式提供了类似“全局变量”的功能。对每一个值只有一个实例，并且位于内存中的固定位置。</p>
<p>　　在Rust语言里，存在一类关键词是修饰词关键词，如关键词&quot;pub&quot;和“static”。</p>
<table><thead><tr><th>类型</th><th>关键词</th><th>类型说明</th></tr></thead><tbody>
<tr><td>&amp;str</td><td></td><td>字符串文字</td></tr>
<tr><td></td><td>static</td><td>静态修饰词关键词</td></tr>
<tr><td></td><td>'</td><td>生命周期关键词</td></tr>
<tr><td></td><td>'static</td><td>静态生命周期关键词</td></tr>
<tr><td>&amp;'static str</td><td></td><td>静态生命周期字符串文字</td></tr>
</tbody></table>
<h3><a class="header" href="#浅谈软件篋的模块" id="浅谈软件篋的模块">浅谈软件篋的模块</a></h3>
<p>　　每一个共享篋都有自己的入口模块名称，这里是hello_exercism，使用共享篋都要从这个名称开始，这里模块hello_exercism有自己的函数hello()。在程序文件lib.rs内还，可以使用关键词mod再定义模块名称，但是它们都是hello_exercism的子模块。</p>
<h3><a class="header" href="#关键词let" id="关键词let">关键词let</a></h3>
<p>　　从作用意义上，共享篋的函数hello()类似于使用关键词let语句，即可把它看作为一个类型为&amp;str的字符串文字与一个变量绑定，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">// Rust File: examples/main.rs
fn main() {
    let _: &amp;'static str = &quot;Hello, World!&quot;;
    let _: &amp;str = &quot;Hello, World!&quot;;
}

</code></pre></pre>
<h3><a class="header" href="#表达式语句和模块" id="表达式语句和模块">表达式、语句和模块</a></h3>
<p>　　在Rust语言里，表达式和语句都可以作为一行代码。要是一行代码，最后没有分号就是表达式，而有分号就是语句。表达式只有作为函数的返回值。</p>
<p>　　表达式和语句可以汇聚成一个由{}内的代码块和由关键词fn开始的函数与方法。函数和方法可以组成一个由关键词mod开始的模块。若干个模块可以形成由关键词mod开始的父模块。</p>
<h3><a class="header" href="#项目配置文件" id="项目配置文件">项目配置文件</a></h3>
<p>　　除了项目配置文件Cargo.toml之外，还可以有其它功能的配置文件，如工具rustfmt的配置文件。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://blog.csdn.net/s_lisheng/article/details/79287713">Rust中的const和static</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying-dependencies</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录tests的测试代码解释" id="共享篋hello_exercism目录tests的测试代码解释">共享篋hello_exercism：目录tests的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-3" id="学习内容-3">学习内容</a></h2>
<ul>
<li>理解开发共享篋的测试代码</li>
<li>了解公共接口的单元测试方法</li>
<li>了解目录tests的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-4" id="篇目-4">篇目</a></h2>
<ol>
<li><a href="hello-world/lib-tests.html#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6u_hellors">公共接口的单元测试文件u_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试与公共接口的单元测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">基于目录tests的集成测试文件i_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%9F%BA%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试与基于测试目录tests的集成测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#公共接口的单元测试文件u_hellors" id="公共接口的单元测试文件u_hellors">公共接口的单元测试文件u_hello.rs</a></h2>
<p>　　在下面的单元测试程序里，只有一个测试函数，其功能是判断函数hello()返回值与字符串文字“Hello, World!”是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/u_hello.rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works_at_uint() {
        assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
    }
}
</code></pre></pre>
<h2><a class="header" href="#单元测试与公共接口的单元测试" id="单元测试与公共接口的单元测试">单元测试与公共接口的单元测试</a></h2>
<p>　　Ⓘ 单元测试（Unit tests）是单个模块或者说单个软件篋的单独测试。</p>
<p>　　一般情况下，单元测试很小且可以测试私有代码。它们的目的是软件篋每一个功能能否正常工作。Rust语言将单元测试分成两类：这里探讨公共接口的单元测试和下面将要说明的私有代码的单元测试。</p>
<p>　　ⓡ 从模块范围之外只能访问模块的公共接口，而不能访问模块的私有内容。</p>
<p>　　Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</p>
<p>　　ⓡ 每一个单元测试函数带有'#[test]'注解标记。测试文件名称命名是由用户自己确定的。</p>
<p>　　每个测试函数都是单独地调用正在开发的共享软件篋进行运行的。因此Cargo工具将共享软件篋纳入到每个测试函数的范围里。</p>
<p>　　Ⓓ 所有公共接口的单元测试文件存储于默认测试目录tests下。</p>
<h2><a class="header" href="#基于目录tests的集成测试文件i_hellors" id="基于目录tests的集成测试文件i_hellors">基于目录tests的集成测试文件i_hello.rs</a></h2>
<p>　　在下面的集成测试程序里，有两个测试函数，第一个函数功能是判断外部共享篋的函数hello()返回值与字符串文字“Hello, World!”是否完全一致。第二个函数功能是判断正在开发共享篋与外部共享篋的函数hello()返回值是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/i_hello.rs
#[test]
fn it_works_with_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试与基于测试目录tests的集成测试" id="集成测试与基于测试目录tests的集成测试">集成测试与基于测试目录tests的集成测试</a></h2>
<p>　　Ⓘ 集成测试（Integration tests）是与外部的多个共享篋的测试。它们比较大，但仅测试正在开发共享篋的公共接口。它们的目的是与其它篋能否正常协同工作。</p>
<p>　　集成测试可以存储于这里探讨的基于测试目录tests，也可以存储于下面将要解释的基于共享篋目录src。但是它们处理代码的方式是完全不同的。</p>
<p>　　Ⓒ 集成测试不需要使用注释'#[cfg(test)]'来注释任何测试代码。</p>
<p>　　ⓡ 每一个单元测试函数注解带有'#[test]'标记。</p>
<p>　　ⓡ 在默认情况下，集成测试文件存储于测试目录tests下。</p>
<h2><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录src的测试代码解释" id="共享篋hello_exercism目录src的测试代码解释">共享篋hello_exercism：目录src的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-4" id="学习内容-4">学习内容</a></h2>
<ul>
<li>了解共享篋目录src下的测试代码结构</li>
<li>了解私有代码的单元测试方法</li>
<li>了解目录src下的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-5" id="篇目-5">篇目</a></h2>
<ol>
<li><a href="hello-world/src-tests.html#%E7%9B%AE%E5%BD%95src%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">目录src测试代码结构</a></li>
<li><a href="hello-world/src-tests.html#%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6modrs">默认模块文件mod.rs</a></li>
<li><a href="hello-world/src-tests.html#%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">私有代码的单元测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95src%E5%86%85%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">基于目录src内的集成测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#目录src测试代码结构" id="目录src测试代码结构">目录src测试代码结构</a></h2>
<pre><code class="language-bash">$ tree ./src -L 3
./src
├── integration_tests
│   ├── i_hello.rs
│   └── mod.rs
├── lib.rs
└── private_tests
    ├── mod.rs
    └── owned_hello.rs
</code></pre>
<h2><a class="header" href="#默认模块文件modrs" id="默认模块文件modrs">默认模块文件mod.rs</a></h2>
<p>　　Ⓓ 从目录src开始，Cargo项目共享篋程序目录名称就是模块名称。目录src就是共享篋模块名称，其模块文件就是lib.rs。</p>
<p>　　如：这里共享篋名称hello_exercism就是模块名称</p>
<p>　　Ⓓ 所有目录src的子目录也是模块名称，其模块文件就是mod.rs。</p>
<p>　　如，目录private_tests就是模块hello_exercism的子模块。</p>
<p>　　Ⓓ 除了lib.rs和mod.rs文件以外，所有其它文件名称也就是模块名称，且其文件名称就是模块名称。</p>
<p>　　如，文件i_hello.rs就是一个模块，其模块名称为i_hello。</p>
<h2><a class="header" href="#私有代码的单元测试" id="私有代码的单元测试">私有代码的单元测试</a></h2>
<p>　　↳ 所有私有函数的单元测试代码必须在其相关的程序文件内。</p>
<p>　　Cargo项目私有代码的单元测试思路：单元测试与共享篋程序代码是融为一体的。所以测试代码都是在私有代码相关的可访问模块里，是不可分开的。</p>
<h2><a class="header" href="#程序文件srclibrs与私有代码的单元测试" id="程序文件srclibrs与私有代码的单元测试">程序文件src/lib.rs与私有代码的单元测试</a></h2>
<p>　　为了测试共享篋程序文件src/lib.rs的私有函数hallo()，需要将测试代码存放在该文件的可访问模块里，或者分离到另外若干个文件里。</p>
<p>　　这里说明程序文件src/lib.rs的第二部分私有代码的单元测试代码，有四段单元测试代码，它们是为三个不同模块：hello_exercism::private_tests::owned_hello、hello_exercism::private_tests_with_use和hello_exercism::private_tests_without_use，而每一个模块都有一个单元测试函数，其测试目的和代码含义都是完全一样的，只是代码形式不一样。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#多文件结构的私有代码的单元测试" id="多文件结构的私有代码的单元测试">多文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的单元测试文件或者说模块。分离文件'src/private_tests/owned_hello.rs'如下所示里。它们的第二行说明其下一行模块的位置。</p>
<p>　　Ⓓ 因为第二段代码的访问模块方式是默认方式，所以第二行代码可以省略。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/owned_hello.rs
use super::*;
//use super::hallo;

#[test]
fn it_works_at_private() {
    assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
}
</code></pre></pre>
<p>　　在程序文件mod.rs和owned_hello.rs里，第一行代码都是需要访问其父模块的所有函数。因为从模块owned_hello出发，需要访问其上两层模块，所以两个模块里都需要使用super语句。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/mod.rs
use super::*;
mod owned_hello;
</code></pre></pre>
<h2><a class="header" href="#单一文件结构的私有代码的单元测试" id="单一文件结构的私有代码的单元测试">单一文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第三段代码和第四段代码方法是把测试代码存放在可访问私有代码的模块里。它们仅仅是否使用了关键词use不同而已。</p>
<p>　　第三段代码的第三行说明该模块hello_exercism::private_tests_with_use需要访问其父模块hello_exercism的所有函数。</p>
<p>　　第四段代码里super也是说明了需要使用期父模块的函数hallo()。</p>
<h2><a class="header" href="#基于目录src内的集成测试" id="基于目录src内的集成测试">基于目录src内的集成测试</a></h2>
<p>　　基于共享篋目录src内的集成测试，与私有代码的单元测试思路有类似性，其测试代码也都是在模块程序代码里，但是有本质上区别，它仅仅使用了共享篋模块结构属性，而非共享篋的原代码，因此它是只能访问共享篋的公共接口。</p>
<p>　　这里说明程序文件src/lib.rs的第三部分集成测试代码，存在两段测试代码。第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的集成测试文件或者说模块。代码原理与前面私有代码的单元测试是完全一样的。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/mod.rs
mod i_hello;
</code></pre></pre>
<p>　　不同代码的是，程序文件mod.rs和集成测试文件i_hello.rs。程序文件mod.rs没有super相关语句，只是说明了使用i_hello模块。集成测试文件i_hello.rs也是不一样的，也没有super相关语句，而是引用了一行使用自己模块的语句，且把自己也称之为模块hello_exercism，这个模块名称可以随意自己命名。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/i_hello.rs
use crate as hello_exercism;

#[test]
fn it_works_with_only_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#本地程序开发命令" id="本地程序开发命令">本地程序：开发命令</a></h1>
<h2><a class="header" href="#学习内容-5" id="学习内容-5">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用本地程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-6" id="篇目-6">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-local.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
</ol>
<h2><a class="header" href="#创建项目命令" id="创建项目命令">创建项目命令</a></h2>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入本地程序项目根目录
mkdir bin-local-hello &amp;&amp; cd bin-local-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-local-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件" id="修改项目配置文件">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
echo 'hello_exercism = { path = &quot;../lib-hello&quot;}' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码" id="开发主程序文件代码">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
vi src/main.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件" id="运行主程序文件">运行主程序文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
cargo run
</code></pre>
<h1><a class="header" href="#子项目本地程序项目bin-local-hello" id="子项目本地程序项目bin-local-hello">子项目：本地程序项目bin-local-hello</a></h1>
<p>　　在共享篋hello_exercism发布以前，Cargo项目本地程序可以以独立的Cargo项目使用该共享篋，且开发应用和检查代码。</p>
<h2><a class="header" href="#学习内容-6" id="学习内容-6">学习内容</a></h2>
<ul>
<li>阐述项目本地程序开发方法</li>
<li>理解项目本地程序代码</li>
</ul>
<h2><a class="header" href="#篇目-7" id="篇目-7">篇目</a></h2>
<ol>
<li><a href="hello-world/bin-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">修改项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">开发主程序文件main.rs</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行主程序及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行测试代码及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#修改项目配置文件cargotoml" id="修改项目配置文件cargotoml">修改项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了共享篋源代码所处的位置。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-local-hello&quot;
version = &quot;0.1.0&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
hello_exercism = { path = &quot;../lib-hello&quot;}
</code></pre>
<h2><a class="header" href="#开发主程序文件mainrs" id="开发主程序文件mainrs">开发主程序文件main.rs</a></h2>
<p>　　主程序文件main.rs与前面代码非常类似，但是这个程序的执行命令与以前是不一样的，并且代码文件结构形式也是不一样的，程序代码和测试代码存在于一个文件里。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

#[test]
fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
</code></pre></pre>
<h2><a class="header" href="#运行主程序及其结果" id="运行主程序及其结果">运行主程序及其结果</a></h2>
<pre><code class="language-bash"># 运行主程序及其结果
$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#运行测试代码及其结果" id="运行测试代码及其结果">运行测试代码及其结果</a></h2>
<pre><code class="language-bash"># 运行测试代码及其结果
$ cargo test -q

running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/33025887/how-to-use-a-local-unpublished-crate">how-to-use-a-local-unpublished-crate</a></li>
</ul>
<h1><a class="header" href="#仓库程序开发命令" id="仓库程序开发命令">仓库程序：开发命令</a></h1>
<p>　　只有发布了自己共享软件篋以后，才能开发这个项目。</p>
<h2><a class="header" href="#学习内容-7" id="学习内容-7">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用仓库程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-8" id="篇目-8">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-bin.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-bin.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%AE%89%E8%A3%85%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F">安装仓库程序于本地系统</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E5%AE%89%E8%A3%85%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">运行安装于本地系统的仓库程序</a></li>
<li><a href="hello-world/commands-bin.html#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">删除本地系统的仓库程序</a></li>
</ol>
<h2><a class="header" href="#创建项目命令-1" id="创建项目命令-1">创建项目命令</a></h2>
<pre><code class="language-bash"># 创建项目命令
# 先进入作业区根目录，且创建项目目录，然后进入仓库程序项目根目录
mkdir bin-hello &amp;&amp; cd bin-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件-1" id="修改项目配置文件-1">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 修改项目配置文件
# 进入仓库程序项目根目录
echo 'hello_exercism = &quot;0.4.1&quot;' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码-1" id="开发主程序文件代码-1">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 开发主程序文件代码
# 进入仓库程序项目根目录
rm src/main.rs
mkdir -p src/bin
touch src/bin/hello.rs
vi src/bin/hello.rs
touch src/bin/hallo.rs
vi src/bin/hallo.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件-1" id="运行主程序文件-1">运行主程序文件</a></h2>
<pre><code class="language-bash"># 运行主程序文件
# 进入仓库程序项目根目录
cargo run --bin hello
cargo run --bin hallo
</code></pre>
<h2><a class="header" href="#安装仓库程序于本地系统" id="安装仓库程序于本地系统">安装仓库程序于本地系统</a></h2>
<pre><code class="language-bash"># 安装仓库程序于本地系统
# 进入仓库程序项目根目录
# 所有Cargo软件篋都安装于目录~/.cargo/bin/
ls ~/.cargo/bin/
cargo install --path .
ls ~/.cargo/bin/
</code></pre>
<h2><a class="header" href="#运行安装于本地系统的仓库程序" id="运行安装于本地系统的仓库程序">运行安装于本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 运行安装于本地系统的仓库程序
# 可以在本地系统任何目录下运行下面命令
hello
hallo
</code></pre>
<h2><a class="header" href="#删除本地系统的仓库程序" id="删除本地系统的仓库程序">删除本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 删除本地系统的仓库程序
# 进入仓库程序项目根目录
ls ~/.cargo/bin/
# cargo uninstall &lt;来自于Cargo.toml里的仓库程序名称&gt;
cargo uninstall bin-hello
ls ~/.cargo/bin/
</code></pre>
<h1><a class="header" href="#子项目仓库程序项目bin-hello" id="子项目仓库程序项目bin-hello">子项目：仓库程序项目bin-hello</a></h1>
<p>　　在共享篋hello_exercism发布以后，Cargo项目仓库程序可以以独立的Cargo项目使用共享篋，且开发应用和检查代码。一般情况下。用户使用共享篋是以这种项目形式出现的。</p>
<p>　　这个仓库程序项目介绍了一种方法，在一个可执行的软件篋里，存在多个独立的可执行程序。</p>
<h2><a class="header" href="#学习内容-8" id="学习内容-8">学习内容</a></h2>
<ul>
<li>阐述项目仓库程序开发方法</li>
<li>理解项目仓库程序代码</li>
</ul>
<h2><a class="header" href="#篇目-9" id="篇目-9">篇目</a></h2>
<ol>
<li><a href="hello-world/bin.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin.html#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">主程序文件main.rs</a></li>
<li><a href="hello-world/bin.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">集成测试文件i_hello.rs</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml-1" id="项目配置文件cargotoml-1">项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了所使用的共享篋，包括共享篋名称和版本号。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-hello&quot;
version = &quot;0.5.3&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# https://crates.io/crates/hello_exercism
# change the follow version to current version
hello_exercism = &quot;0.5.3&quot;
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhellors" id="主程序文件srcbinhellors">主程序文件src/bin/hello.rs</a></h2>
<p>　　下面主程序文件main.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

</code></pre></pre>
<p>　　执行上面程序的命令及其结果，如下所示：</p>
<pre><code class="language-bash">$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhallors" id="主程序文件srcbinhallors">主程序文件src/bin/hallo.rs</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试文件i_hellors" id="集成测试文件i_hellors">集成测试文件i_hello.rs</a></h2>
<p>　　下面的集成测试文件i_hello.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
#}</code></pre></pre>
<h1><a class="header" href="#题外话-1" id="题外话-1">题外话</a></h1>
<h2><a class="header" href="#篇目-10" id="篇目-10">篇目</a></h2>
<ol>
<li><a href="hello-world/off-topic.html#cargo%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4">Cargo工具命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9B%AE%E5%BD%95examples%E4%B8%8B%E6%96%87%E4%BB%B6">构建和运行软件篋目录examples下文件</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4">Cargo项目构建命令</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4">Cargo项目测试特定代码命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98">思考问题</a></li>
<li><a href="hello-world/off-topic.html#%E7%B1%BB%E5%9E%8Bstr%E5%92%8Cstatic-str%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8Duse%E5%92%8Cextern%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">使用关键词use和extern有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E6%B3%A8%E8%A7%A3cfgtest%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89">注解#[cfg(test)]有什么意义?</a></li>
<li><a href="hello-world/off-topic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#cargo工具命令" id="cargo工具命令">Cargo工具命令</a></h2>
<h3><a class="header" href="#构建和运行软件篋目录examples下文件" id="构建和运行软件篋目录examples下文件">构建和运行软件篋目录examples下文件</a></h3>
<pre><code class="language-bash"># cargo build --example &lt;目录examples下无扩展名的文件名称&gt;
# cargo run --example &lt;目录examples下无扩展名的文件名称&gt;
cargo build --example i_hello
cargo run --example i_hello
</code></pre>
<h3><a class="header" href="#cargo项目构建命令" id="cargo项目构建命令">Cargo项目构建命令</a></h3>
<pre><code class="language-bash">cargo build
cargo build --release
</code></pre>
<h3><a class="header" href="#cargo项目测试特定代码命令" id="cargo项目测试特定代码命令">Cargo项目测试特定代码命令</a></h3>
<pre><code class="language-bash">cargo test tests::it_works_at_uint
cargo test test_hello_world
</code></pre>
<h2><a class="header" href="#思考问题" id="思考问题">思考问题</a></h2>
<h3><a class="header" href="#类型str和static-str有什么区别" id="类型str和static-str有什么区别">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></h3>
<ul>
<li>在语句里，它们是没有任何区别。</li>
<li>在函数返回类型里，它们是有区别的。</li>
</ul>
<h3><a class="header" href="#使用关键词use和extern有什么区别" id="使用关键词use和extern有什么区别">使用关键词use和extern有什么区别？</a></h3>
<ul>
<li>自Rust2018版本以来几乎不再需要extern语句。</li>
<li>关键词use方法与以前相同。</li>
<li>关键词use仅仅是引用标准符号的简写，或者使用trait时必须出现。</li>
</ul>
<h3><a class="header" href="#注解cfgtest有什么意义" id="注解cfgtest有什么意义">注解#[cfg(test)]有什么意义?</a></h3>
<ul>
<li>它告诉编译器在测试环境下进行编译，</li>
<li>仅当使用命令'cargo test'运行测试时，Cargo工具才会编译测试代码。</li>
</ul>
<h2><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/29403920/whats-the-difference-between-use-and-extern">whats-the-difference-between-use-and-extern</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-alpha.2/book/crates-and-modules.html">crates-and-modules</a></li>
<li><a href="https://freyskeyd.fr/cfg-test-and-cargo-test-a-missing-information/">cfg-test-and-cargo-test-a-missing-information</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">ch11-03-test-organization</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://stackoverflow.com/questions/49684657/what-is-the-difference-between-str-and-static-str-in-a-static-or-const">what-is-the-difference-between-str-and-static-str-in-a-static-or-const</a></li>
</ul>
<h1><a class="header" href="#第四章-软件篋borrowing_exerci" id="第四章-软件篋borrowing_exerci">第四章 软件篋borrowing_exerci</a></h1>
<h2><a class="header" href="#参考资料-6" id="参考资料-6">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/22596920/split-a-module-across-several-files">split-a-module-across-several-files</a></li>
<li><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">ch07-05-separating-modules-into-different-files</a></li>
<li><a href="https://chronicbuildfailure.co/splitting-up-modules-in-rust-5ad7713201d5">splitting-up-modules-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html">references-and-borrowing</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow.html">rust-by-example/scope/borrow</a></li>
<li><a href="http://squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html">rust-borrowing-and-ownership</a></li>
<li><a href="https://medium.com/@bugaevc/understanding-rust-ownership-borrowing-lifetimes-ff9ee9f79a9c">understanding-rust-ownership-borrowing-lifetimes</a></li>
<li><a href="https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust">you-can-t-turn-off-the-borrow-checker-in-rust</a></li>
</ul>
<h1><a class="header" href="#关于软件篋borrowing_exerci" id="关于软件篋borrowing_exerci">关于软件篋borrowing_exerci</a></h1>
<h1><a class="header" href="#开发软件篋borrowing_exerci" id="开发软件篋borrowing_exerci">开发软件篋borrowing_exerci</a></h1>
<ul>
<li><a href="https://users.rust-lang.org/t/cargo-test-internal-packages/5187/2">cargo-test-internal-packages</a></li>
</ul>
<h1><a class="header" href="#使用软件篋borrowing_exerci" id="使用软件篋borrowing_exerci">使用软件篋borrowing_exerci</a></h1>
<h1><a class="header" href="#第二章-软件篋trait_exerci" id="第二章-软件篋trait_exerci">第二章 软件篋trait_exerci</a></h1>
<h3><a class="header" href="#学习内容-9" id="学习内容-9">学习内容</a></h3>
<ul>
<li>什么是Rust语言衔接关键词trait</li>
<li>为什么需要衔接关键词trait</li>
<li>怎么样实现Rust语言衔接关键词trait</li>
<li>实现关键词impl与衔接关键词trait是什么关系</li>
</ul>
<h3><a class="header" href="#篇目-11" id="篇目-11">篇目</a></h3>
<ol>
<li><a href="hello-trait/index.html#%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5%E8%A1%A8%E8%BF%B0%E4%B9%8B%E4%B8%80">关键词trait概念表述之一</a></li>
<li><a href="hello-trait/index.html#%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5%E8%A1%A8%E8%BF%B0%E4%B9%8B%E4%BA%8C">关键词trait概念表述之二</a></li>
<li><a href="hello-trait/index.html#%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5%E8%A1%A8%E8%BF%B0%E4%B9%8B%E4%B8%89">关键词trait概念表述之三</a></li>
<li><a href="hello-trait/index.html#%E8%A7%A3%E9%87%8A%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">解释关键词trait</a></li>
<li><a href="hello-trait/index.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a>
<ol>
<li><a href="hello-trait/index.html#%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8rust%E8%AF%AD%E8%A8%80nightly%E7%89%88%E6%9C%AC">怎么样使用Rust语言nightly版本</a></li>
<li><a href="hello-trait/index.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
</li>
<li><a href="hello-trait/index.html#%E6%9C%AC%E7%AB%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">本章参考资料</a></li>
</ol>
<h2><a class="header" href="#关键词trait概念表述之一" id="关键词trait概念表述之一">关键词trait概念表述之一</a></h2>
<p>　　<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">关键词trait</a>是Rust语言的一项功能，可以告诉Rust编译器一种类型必须提供的功能。</p>
<h2><a class="header" href="#关键词trait概念表述之二" id="关键词trait概念表述之二">关键词trait概念表述之二</a></h2>
<p>　　<a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">关键词trait</a>是为任何未知类型定义方法的集合。</p>
<h2><a class="header" href="#关键词trait概念表述之三" id="关键词trait概念表述之三">关键词trait概念表述之三</a></h2>
<p>　　<a href="https://doc.rust-lang.org/beta/book/ch10-02-traits.html">关键词trait</a>告诉Rust编译器一种特定的类型具有且可与其他类型共享的功效性质。</p>
<h2><a class="header" href="#解释关键词trait" id="解释关键词trait">解释关键词trait</a></h2>
<p>　　关键词trait提供了一种类型或者几种类型之间的衔接方式。它应该包含下面内容：</p>
<ul>
<li>存在一种类型或者几种类型</li>
<li>使用关键词trait定义衔接名称</li>
<li>使用关键词trait代码块定义方法和函数</li>
<li>使用关键词&quot;impl&quot;和&quot;for&quot;组合，实现针对这一种类型或者这几种类型的方法和函数</li>
</ul>
<h2><a class="header" href="#题外话-2" id="题外话-2">题外话</a></h2>
<h3><a class="header" href="#怎么样使用rust语言nightly版本" id="怎么样使用rust语言nightly版本">怎么样使用Rust语言nightly版本</a></h3>
<pre><code class="language-bash">rustc --version
rustup default nightly
rustc --version
rustup default stable
rustup update
rustup show
</code></pre>
<h3><a class="header" href="#参考资料-7" id="参考资料-7">参考资料</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rustup.rs/issues/451">Setting &quot;rustup default nightly&quot; and back to stable ends up</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/55571">Toolchain 'nightly-x86_64-apple-darwin' missing</a></li>
</ul>
<h2><a class="header" href="#本章参考资料" id="本章参考资料">本章参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">Impls &amp; Traits</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">Traits from 'rust-by-example'</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/traits.html">Traits from 'The Rust Programming Language'</a></li>
<li><a href="https://doc.rust-lang.org/beta/book/ch10-02-traits.html">Traits: Defining Shared Behavior</a></li>
</ul>
<h1><a class="header" href="#类型关键词struct" id="类型关键词struct">类型关键词struct</a></h1>
<p>　　通过了解和学习本节Rust语言的基本概念，可以实现本章需要开发的共享软件篋程序代码。</p>
<h2><a class="header" href="#学习内容-10" id="学习内容-10">学习内容</a></h2>
<ul>
<li>理解和掌握Rust语言结构性的类型关键词struct定义形式</li>
<li>理解和掌握Rust语言结构性的类型关键词struct实例化方式</li>
<li>理解和掌握Rust语言结构性的类型关键词struct调用手段</li>
</ul>
<h2><a class="header" href="#篇目-12" id="篇目-12">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-struct.html#%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E6%98%AF%E4%BB%80%E4%B9%88">类型关键词struct是什么</a></li>
<li><a href="hello-trait/examples-struct.html#C%E8%AF%AD%E8%A8%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E4%BB%A3%E7%A0%81">C语言形式的类型关键词struct代码</a></li>
<li><a href="hello-trait/examples-struct.html#%E5%85%83%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct">元组形式的类型关键词struct</a></li>
<li><a href="hello-trait/examples-struct.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#类型关键词struct是什么" id="类型关键词struct是什么">类型关键词struct是什么</a></h2>
<p>　　类型关键词struct提供定义一种结构性的类型方式。这种类型的定义分析如下：</p>
<table><thead><tr><th>名称</th><th>事物描述</th><th>Rust语言描述</th></tr></thead><tbody>
<tr><td>结构性事物</td><td>类别</td><td>struct</td></tr>
<tr><td>事物名称</td><td>人</td><td>Person</td></tr>
<tr><td>事物属性</td><td>姓名，年龄</td><td>name: string, age:u32</td></tr>
</tbody></table>
<p><img src="hello-trait/../../images/hello-trait-11-struct.png" alt="image" /></p>
<p>　　从上图所示，可以理解到，结构类型关键词struct将一组不同的数据类型作为整体在一起分析和处理。</p>
<p>　　同时还可以看到，在Rust语言里，结构类型关键词struct可以将这种结构性事物以两种不同的表达形式进行定义。它们分别称之为：C语言形式和元组形式。图上左边的C语言形式是以哈希结构表达的类型，而图上右边的元组形式是以数组结构表达的类型。</p>
<h2><a class="header" href="#类型关键词struct的私有性" id="类型关键词struct的私有性">类型关键词struct的私有性</a></h2>
<p>　　Rust语言规定，Ⓓ 默认情况下，关键词struct定义的类型及其属性都是私有的，默认实例代码如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    name: String,
    age: u32,
}
#}</code></pre></pre>
<h2><a class="header" href="#c语言形式的类型关键词struct代码" id="c语言形式的类型关键词struct代码">C语言形式的类型关键词struct代码</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>使用关键词mod，关键词struct定义结构类型的方式。</li>
<li>使用关键词pub，实现关键词struct定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。</li>
<li>结构类型的实例调用结构类型的属性手法。</li>
<li>使用宏方法assert_eq!，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct ClikeStructType {
        // data: u32,
        pub data: u32,
    }
}

// cargo run --example pub_field
fn main() {
    let instance = trait_exerci::ClikeStructType { data: 0 };
    let data = instance.data;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#元组形式的类型关键词struct" id="元组形式的类型关键词struct">元组形式的类型关键词struct</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>使用关键词mod，关键词struct定义结构类型的方式。<br/>ⓡ 注意：元组形式的类型关键词struct定义的类型是以分号结束的，而C语言形式的类型关键词struct代码是没有分号的。</li>
<li>使用关键词pub，实现关键词struct定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。两种形式的类型不同的。</li>
<li>结构类型的实例调用结构类型的属性手法。元组形式的类型是以其属性的顺序号实现调用的，而C语言形式的类型是以其公开性属性实现调用的。</li>
<li>使用宏方法assert_eq!，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct TupleStructType (pub u32);
}

// cargo run --example tuple_struct
fn main() {
    let instance = trait_exerci::TupleStructType(0);
    let data = instance.0;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-8" id="参考资料-8">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/structs.html">structs from 'rust-by-example '</a></li>
</ul>
<h1><a class="header" href="#实现关键词impl与方法代码实现" id="实现关键词impl与方法代码实现">实现关键词impl与方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-11" id="学习内容-11">学习内容</a></h2>
<ul>
<li>阐述关键词impl基本概念</li>
<li>理解关键词impl实现代码的方式</li>
</ul>
<h2><a class="header" href="#篇目-13" id="篇目-13">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-impl.html#%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E6%A6%82%E5%BF%B5">关键词impl概念</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl">实现功能关键词impl</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">实现功能关键词impl与函数代码实现</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#关键词impl概念" id="关键词impl概念">关键词impl概念</a></h2>
<p>　　关键词impl是为类型实现结构类型或者其它一些类型的不同行为功能。这里仅仅说明了直接针对结构类型本身的不同行为实现方式。</p>
<p><img src="hello-trait/../../images/hello-trait-12-impl.png" alt="image" /></p>
<h2><a class="header" href="#实现功能关键词impl" id="实现功能关键词impl">实现功能关键词impl</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>Ⓓ 关键词impl始终是公开的，且不可增加修饰关键词pub；</li>
<li>Ⓓ 关键词impl实现的函数和方法默认都是私有的，且可增加修饰关键词pub.</li>
</ul>
<p>默认实例代码如下所示。尽管下面代码已实现了函数new()，但是该函数外部还是不可访问的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#struct Person {
#    name: String,
#    age: u32,
#}

impl Person {
    fn new(name: String, age: u32) -&gt; Person {
        Person {
            name: name,
            age: age,
        }
    }
}
#}</code></pre></pre>
<h2><a class="header" href="#实现功能关键词impl与函数代码实现" id="实现功能关键词impl与函数代码实现">实现功能关键词impl与函数代码实现</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>使用关键词impl，实现结构类型StructType的实例化函数new()。</li>
<li>使用关键词pub，实现结构类型StructType的函数new()公开性。</li>
<li>实例是一种类型的具体对象。</li>
<li>借助于公开性函数new()，实现该结构类型的实例化方式。</li>
<li>结构类型实例实现了调用结构类型的属性手法。</li>
<li>使用宏方法assert_eq!，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

// cargo run --example function_instance
fn main() {
    let instance = trait_exerci::StructType::new(0);
    println!(&quot;instance.data = {}&quot;, instance.data);

    let instance = trait_exerci::StructType{ data:0, };
    println!(&quot;instance.data = {}&quot;, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-9" id="参考资料-9">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.impl.html">std keyword impl</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html">reference implementations</a></li>
</ul>
<h1><a class="header" href="#方法代码实现" id="方法代码实现">方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-12" id="学习内容-12">学习内容</a></h2>
<ul>
<li>阐述Rust语言函数与方法概念区别</li>
<li>理解实现函数与方法手段</li>
</ul>
<h2><a class="header" href="#篇目-14" id="篇目-14">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-methods.html#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E6%A6%82%E5%BF%B5">函数与方法概念</a></li>
<li><a href="hello-trait/examples-methods.html#%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">方法代码实现</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#函数与方法概念" id="函数与方法概念">函数与方法概念</a></h2>
<p>　　在Rust语言里，给予了函数（fcuntion）与方法（method）两个名称不同的概念。</p>
<p>　　引用：<a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">Methods are functions attached to objects</a>，直接翻译：方法是附加到对象的函数（行为功能），可以这么理解，方法是附属于类型实例的行为功能。</p>
<p>　　而函数是附属于类型的功能。在前面一节里，可以看到，实现类型的函数代码方法及其调用手法。下面通过代码详细说明它们的区别。</p>
<h2><a class="header" href="#实现方法代码" id="实现方法代码">实现方法代码</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>实现结构类型StructType的实例化函数new()。</li>
<li>实现结构类型StructType的获取属性内容方法get_data()。</li>
<li>实现结构类型StructType的变更属性内容方法set_data()。</li>
<li>实现结构类型StructType的属性data是私有的。</li>
<li>借助于公开性函数new()，实现该结构类型的实例化方式。</li>
<li>结构类型实例实现了调用结构类型的属性手法。</li>
<li>使用宏方法assert_eq!，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

mod trait_exerci {
    pub struct StructType {
        data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }

        pub fn get_data(&amp;self) -&gt; u32 {
            self.data
        }

        pub fn set_data(&amp;mut self, data: &amp;u32) {
            self.data = *data;
        }
    }
}

// cargo run --example method_function
fn main() {
    let instance = trait_exerci::StructType::new(0);
    let data = instance.get_data();
    println!(&quot;data = {}&quot;, data);

    let data = trait_exerci::StructType::new(0).get_data();
    println!(&quot;data = {}&quot;, data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-10" id="参考资料-10">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">rust-by-example methods</a></li>
</ul>
<h1><a class="header" href="#衔接关键词trait与修饰关键词mut" id="衔接关键词trait与修饰关键词mut">衔接关键词trait与修饰关键词mut</a></h1>
<h2><a class="header" href="#学习内容-13" id="学习内容-13">学习内容</a></h2>
<ul>
<li>阐述</li>
<li>理解</li>
</ul>
<h2><a class="header" href="#篇目-15" id="篇目-15">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-trait.html#%E8%A1%94%E6%8E%A5%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">衔接关键词trait</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#衔接关键词trait" id="衔接关键词trait">衔接关键词trait</a></h2>
<ul>
<li>默认是私有的，且可增加修饰关键词pub</li>
<li></li>
</ul>
<h2><a class="header" href="#修饰关键词mut" id="修饰关键词mut">修饰关键词mut</a></h2>
<h2><a class="header" href="#关键词impl和for" id="关键词impl和for">关键词impl和for</a></h2>
<ul>
<li>默认是公开的</li>
<li>函数不可增加修饰关键词pub</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    pub trait TraitCanal {
        fn new(data: u32) -&gt; StructType;
    }

    impl TraitCanal for StructType {
        fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

use self::trait_exerci::TraitCanal;

// cargo run --example trait
fn main() {
    let instance = trait_exerci::StructType::new(0);
    println!(&quot;instance.data = {}&quot;, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-11" id="参考资料-11">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#关于软件篋trait_exerci" id="关于软件篋trait_exerci">关于软件篋trait_exerci</a></h1>
<h2><a class="header" href="#共享篋开发命令-1" id="共享篋开发命令-1">共享篋：开发命令</a></h2>
<h2><a class="header" href="#篇目-16" id="篇目-16">篇目</a></h2>
<ul>
<li><a href="hello-trait/commands-lib.html#i-create-the-crate-for-library">I. create the crate for library</a></li>
<li><a href="hello-trait/commands-lib.html#ii-create-the-crate-for-application">II. create the crate for application</a></li>
</ul>
<h1><a class="header" href="#i-create-the-crate-for-library" id="i-create-the-crate-for-library">I. create the crate for library</a></h1>
<pre><code class="language-bash">mkdir lib-hello &amp;&amp; cd lib-hello
cargo init --name trait_exerci --lib
</code></pre>
<h1><a class="header" href="#ii-create-the-crate-for-application" id="ii-create-the-crate-for-application">II. create the crate for application</a></h1>
<pre><code class="language-bash">mkdir bin-hello &amp;&amp; cd bin-hello
cargo init --name hello-trait --bin
</code></pre>
<h1><a class="header" href="#共享篋程序代码结构解释" id="共享篋程序代码结构解释">共享篋：程序代码结构解释</a></h1>
<p><img src="hello-trait/../../images/hello-trait-01.png" alt="image" /></p>
<p><img src="hello-trait/../../images/hello-trait-02-only-impl.png" alt="image" /></p>
<p><img src="hello-trait/../../images/hello-trait-03-trait-impl.png" alt="image" /></p>
<p><img src="hello-trait/../../images/hello-trait-04-all.png" alt="image" /></p>
<h1><a class="header" href="#共享篋程序代码解释" id="共享篋程序代码解释">共享篋：程序代码解释</a></h1>
<p><img src="hello-trait/../../images/hello-trait-05-complex.png" alt="image" /></p>
<pre><pre class="playpen"><code class="language-rust editable">pub struct StructType {
    pub data: u32,
}

// Defining a trait for any type
pub trait TraitCanal {
    //fn new(data: u32) -&gt; StructType;
    fn get_data(&amp;self) -&gt; u32;
}

// Defining a trait for any type
pub trait TraitKanal {
    //fn new(data: u32) -&gt; StructType;
    fn set_data(&amp;mut self, data: &amp;u32);
}

// Implementing a trait for a type
impl TraitCanal for StructType {
    fn get_data(&amp;self) -&gt; u32 {
        self.data
    }
}

// Implementing a trait for a type
impl TraitKanal for StructType {
    fn set_data(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

// impl AllTrait for StructType {
impl StructType {
    pub fn new(data: u32) -&gt; StructType {
        dbg!(&quot;impl StructType: new&quot;);
        StructType { data: data }
    }

    pub fn get_data_for_all(&amp;self) -&gt; u32 {
        self.data
    }

    pub fn set_data_for_all(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

</code></pre></pre>
<h1><a class="header" href="#共享篋目录tests的测试代码解释" id="共享篋目录tests的测试代码解释">共享篋：目录tests的测试代码解释</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">// For `impl StructType for StructType`
// AND For `impl StructType`
use trait_exerci::StructType;

#[test]
fn it_works_with_data_and_get() {
    // pub data: u32,
    let instance = StructType { data: 10 };
    assert_eq!(10, instance.get_data_for_all());
}

#[test]
fn it_works_with_new_and_get() {
    // new() + get()
    let instance = StructType::new(11);
    assert_eq!(11, instance.get_data_for_all());
}

#[test]
fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data_for_all(&amp;12);
    assert_eq!(12, instance.get_data_for_all());
}

</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">// For `impl TraitCanal for StructType`
use trait_exerci::TraitCanal;

// For `impl StructType for StructType`
// AND For `impl StructType`
use trait_exerci::StructType;

#[test]
fn it_works_with_get() {
    let instance = StructType { data: 20 };
    assert_eq!(20, instance.get_data());
}

</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">// For `impl TraitKanal for StructType`
use trait_exerci::TraitKanal;

// For `impl StructType for StructType`
// AND For `impl StructType`
use trait_exerci::StructType;

#[test]
fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data(&amp;31);
    assert_eq!(31, instance.data);
}

</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">// For `impl TraitCanal for StructType`
use trait_exerci::TraitCanal;
// For `impl TraitKanal for StructType`
use trait_exerci::TraitKanal;

// For `impl StructType for StructType`
// AND For `impl StructType`
use trait_exerci::StructType;

#[test]
fn it_works_with_both_traits() {
    let mut instance = StructType::new(0);
    instance.set_data(&amp;41);
    assert_eq!(41, instance.get_data());
}

</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">#[cfg(test)]
mod tests {
    use trait_exerci::TraitCanal;

    #[test]
    fn it_works() {
        let instance = Box::new(trait_exerci::StructType { data: 20 });
        assert_eq!(20, instance.get_data());
    }

    #[test]
    fn it_works_with_new() {
        let instance = Box::new(trait_exerci::StructType::new(21));
        assert_eq!(21, instance.get_data());
    }
}

</code></pre></pre>
<h1><a class="header" href="#题外话-3" id="题外话-3">题外话</a></h1>
<h1><a class="header" href="#第二章" id="第二章">第二章</a></h1>
<p><a href="https://archive.fosdem.org/2018/schedule/event/rust_testing_mocking/attachments/slides/2113/export/events/attachments/rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf">rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf</a></p>
<h1><a class="header" href="#关于软件篋mod_trait_exerci" id="关于软件篋mod_trait_exerci">关于软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#开发软件篋mod_trait_exerci" id="开发软件篋mod_trait_exerci">开发软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#使用软件篋mod_trait_exerci" id="使用软件篋mod_trait_exerci">使用软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#第四章" id="第四章">第四章</a></h1>
<h1><a class="header" href="#关于软件篋deref_exerci" id="关于软件篋deref_exerci">关于软件篋deref_exerci</a></h1>
<h1><a class="header" href="#开发软件篋deref_exerci" id="开发软件篋deref_exerci">开发软件篋deref_exerci</a></h1>
<h1><a class="header" href="#使用软件篋deref_exerci" id="使用软件篋deref_exerci">使用软件篋deref_exerci</a></h1>
<h1><a class="header" href="#软件篋macro_exerci" id="软件篋macro_exerci">软件篋macro_exerci</a></h1>
<h1><a class="header" href="#关于软件篋macro_exerci" id="关于软件篋macro_exerci">关于软件篋macro_exerci</a></h1>
<h1><a class="header" href="#开发软件篋macro_exerci" id="开发软件篋macro_exerci">开发软件篋macro_exerci</a></h1>
<h1><a class="header" href="#使用软件篋macro_exerci" id="使用软件篋macro_exerci">使用软件篋macro_exerci</a></h1>
<h1><a class="header" href="#软件篋generics_exerci" id="软件篋generics_exerci">软件篋generics_exerci</a></h1>
<h1><a class="header" href="#关于软件篋generics_exerci" id="关于软件篋generics_exerci">关于软件篋generics_exerci</a></h1>
<h1><a class="header" href="#开发软件篋generics_exerci" id="开发软件篋generics_exerci">开发软件篋generics_exerci</a></h1>
<h1><a class="header" href="#使用软件篋generics_exerci" id="使用软件篋generics_exerci">使用软件篋generics_exerci</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
