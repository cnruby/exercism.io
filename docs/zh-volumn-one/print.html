<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>以软件篋学习Rust语言</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Chinese">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="foreword/index.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li><ol class="section"><li><a href="foreword/about.html"><strong aria-hidden="true">1.1.</strong> 本书项目结构</a></li><li><a href="foreword/crate.html"><strong aria-hidden="true">1.2.</strong> 关于作业区和软件篋</a></li><li><a href="foreword/cargo.html"><strong aria-hidden="true">1.3.</strong> 关于Cargo工具基础命令</a></li><li><a href="foreword/rust.html"><strong aria-hidden="true">1.4.</strong> Rust语言新思维和新概念</a></li></ol></li><li><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> 软件篋hello_exercism</a></li><li><ol class="section"><li><a href="hello-world/commands.html"><strong aria-hidden="true">2.1.</strong> 开发软件篋命令</a></li><li><a href="hello-world/about.html"><strong aria-hidden="true">2.2.</strong> 关于软件篋项目</a></li><li><a href="hello-world/lib.html"><strong aria-hidden="true">2.3.</strong> 共享篋：程序代码解释</a></li><li><a href="hello-world/lib-tests.html"><strong aria-hidden="true">2.4.</strong> 共享篋：目录tests的测试代码解释</a></li><li><a href="hello-world/src-tests.html"><strong aria-hidden="true">2.5.</strong> 共享篋：目录src的测试代码解释</a></li><li><a href="hello-world/bin.html"><strong aria-hidden="true">2.6.</strong> 子项目：本地程序</a></li><li><a href="hello-world/bin-local.html"><strong aria-hidden="true">2.7.</strong> 子项目：仓库程序</a></li><li><a href="hello-world/off-topic.html"><strong aria-hidden="true">2.8.</strong> 题外话</a></li></ol></li><li><a href="hello-borrowing/index.html"><strong aria-hidden="true">3.</strong> 软件篋borrowing_exerci</a></li><li><ol class="section"><li><a href="hello-borrowing/about.html"><strong aria-hidden="true">3.1.</strong> 关于软件篋borrowing_exerci</a></li><li><a href="hello-borrowing/develop.html"><strong aria-hidden="true">3.2.</strong> 开发软件篋borrowing_exerci</a></li><li><a href="hello-borrowing/apply.html"><strong aria-hidden="true">3.3.</strong> 使用软件篋borrowing_exerci</a></li></ol></li><li><a href="hello-trait/index.html"><strong aria-hidden="true">4.</strong> 软件篋trait_exerci</a></li><li><ol class="section"><li><a href="hello-trait/about.html"><strong aria-hidden="true">4.1.</strong> 关于软件篋trait_exerci</a></li><li><a href="hello-trait/develop.html"><strong aria-hidden="true">4.2.</strong> 开发软件篋trait_exerci</a></li><li><a href="hello-trait/apply.html"><strong aria-hidden="true">4.3.</strong> 使用软件篋trait_exerci</a></li></ol></li><li><a href="hello-mod-trait/index.html"><strong aria-hidden="true">5.</strong> 软件篋mod_trait_exerci</a></li><li><ol class="section"><li><a href="hello-mod-trait/about.html"><strong aria-hidden="true">5.1.</strong> 关于软件篋mod_trait_exerci</a></li><li><a href="hello-mod-trait/develop.html"><strong aria-hidden="true">5.2.</strong> 开发软件篋mod_trait_exerci</a></li><li><a href="hello-mod-trait/apply.html"><strong aria-hidden="true">5.3.</strong> 使用软件篋mod_trait_exerci</a></li></ol></li><li><a href="hello-deref/index.html"><strong aria-hidden="true">6.</strong> 软件篋deref_exerci</a></li><li><ol class="section"><li><a href="hello-deref/about.html"><strong aria-hidden="true">6.1.</strong> 关于软件篋deref_exerci</a></li><li><a href="hello-deref/develop.html"><strong aria-hidden="true">6.2.</strong> 开发软件篋deref_exerci</a></li><li><a href="hello-deref/apply.html"><strong aria-hidden="true">6.3.</strong> 使用软件篋deref_exerci</a></li></ol></li><li><a href="hello-macro/index.html"><strong aria-hidden="true">7.</strong> 软件篋macro_exerci</a></li><li><ol class="section"><li><a href="hello-macro/about.html"><strong aria-hidden="true">7.1.</strong> 关于软件篋macro_exerci</a></li><li><a href="hello-macro/develop.html"><strong aria-hidden="true">7.2.</strong> 开发软件篋macro_exerci</a></li><li><a href="hello-macro/apply.html"><strong aria-hidden="true">7.3.</strong> 使用软件篋macro_exerci</a></li></ol></li><li><a href="hello-generics/index.html"><strong aria-hidden="true">8.</strong> 软件篋generics_exerci</a></li><li><ol class="section"><li><a href="hello-generics/about.html"><strong aria-hidden="true">8.1.</strong> 关于软件篋generics_exerci</a></li><li><a href="hello-generics/develop.html"><strong aria-hidden="true">8.2.</strong> 开发软件篋generics_exerci</a></li><li><a href="hello-generics/apply.html"><strong aria-hidden="true">8.3.</strong> 使用软件篋generics_exerci</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">以软件篋学习Rust语言</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#前言" id="前言">前言</a></h1>
<h2><a class="header" href="#rust语言" id="rust语言">Rust语言</a></h2>
<p>　　Rust是一门可靠高效、保证安全、支持并发和似C语言同级速度的计算机编程语言。</p>
<h2><a class="header" href="#rustup版本管理工具" id="rustup版本管理工具">rustup版本管理工具</a></h2>
<p>　　rustup是Rust语言官方的版本管理工具，负责安装Rust语言及其版本管理。通过rustup工具实现了Rust语言安装工作。</p>
<h2><a class="header" href="#cargo包管理器" id="cargo包管理器">Cargo包管理器</a></h2>
<p>　　Cargo是一款Rust语言官方的包管理器和开发工具，负责Rust软件篋的依赖管理，并且能够下载、开发、编译、生成和分发的软件篋。一旦安装了Rust语言，该工具也自动完成了安装。</p>
<h2><a class="header" href="#crateio" id="crateio">Crate.io</a></h2>
<p>　　Crate.io是Rust语言软件篋的官方仓库，负责软件篋登记、托管和存储等功能服务。</p>
<h2><a class="header" href="#关于本书" id="关于本书">关于本书</a></h2>
<p>　　以开发软件篋过程，学习和理解Rust语言的全新设计思路及其重要概念。</p>
<h2><a class="header" href="#重要rust语言链接" id="重要rust语言链接">重要Rust语言链接</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/">Rust官方网站</a></li>
<li><a href="https://rustup.rs/">rustup官方网站</a></li>
<li><a href="https://github.com/rust-lang/cargo">Cargo项目源代码</a></li>
<li><a href="https://crates.io/">Crate.io官方网站</a></li>
</ul>
<h2><a class="header" href="#重要工具链接链接" id="重要工具链接链接">重要工具链接链接</a></h2>
<ul>
<li><a href="https://www.tablesgenerator.com/">Tables Generator</a></li>
</ul>
<h1><a class="header" href="#本书项目结构" id="本书项目结构">本书项目结构</a></h1>
<h2><a class="header" href="#作业区和篋" id="作业区和篋">作业区和篋</a></h2>
<p>　　Cargo项目是Cargo工具所生成的目录和文件内容，称之为软件篋，或者简称为篋。</p>
<p>　　软件篋项目是由若干个Cargo项目或者说软件篋组成，在本书里，软件篋项目也简称为作业区（workspace）、整体项目或者项目。所有Cargo项目都是在作业区目录之下，且这些项目在相同目录层上。所有项目名称也是目录名称。每一章最顶层目录是作业区目录，其目录名称的命名法则，使用短横线命名（kebab-case）。</p>
<h2><a class="header" href="#共享篋和应用程序" id="共享篋和应用程序">共享篋和应用程序</a></h2>
<p>　　每一个软件篋源代码存在于一个Cargo项目里。</p>
<p>　　把Cargo项目软件篋（library package）发布到网站crates.io的共享软件篋，简称共享篋。</p>
<p>　　除了这个共享软件篋的Cargo项目外，还有一个使用本地共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为本地程序。其目录名称的命名法则，也使用短横线命名（kebab-case）。其目的是在发布共享篋之前，作为完全独立的Cargo项目，来测试和应用该共享软件篋。按照Rust语言命名法则，共享软件篋名称使用小蛇式命名（lower snake case）。</p>
<p>　　另外，一个使用仓库crates.io里共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为仓库程序。其目录名称的命名法则，也使用短横线命名（kebab-case）。其目的是在发布共享软件篋之后，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<h2><a class="header" href="#说明作业区实例" id="说明作业区实例">说明作业区实例</a></h2>
<p>　　下面说明这些目录名称含义。整个项目名称随着不同项目其名称也会不同，但每一个作业区目录下，所有功能相同的Cargo项目名称都是一样的。</p>
<hr/>
<h3><a class="header" href="#项目类型清单" id="项目类型清单">项目类型清单</a></h3>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h3><a class="header" href="#篋类型清单" id="篋类型清单">篋类型清单</a></h3>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h3><a class="header" href="#作业区所有目录文件清单" id="作业区所有目录文件清单">作业区所有目录文件清单</a></h3>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── hello.rs
    └── lib-hello
        ├── Cargo.lock
        ├── Cargo.toml
        ├── Cargo.txt
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   └── lib.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.r
</code></pre>
<h2><a class="header" href="#本书使用符号说明" id="本书使用符号说明">本书使用符号说明</a></h2>
<table><thead><tr><th>符号</th><th>英文单词</th><th>说明</th><th>要求</th><th>实例</th></tr></thead><tbody>
<tr><td>Ⓓ</td><td>default</td><td>叙述Rust语言默认情况</td><td>必须记住</td><td>Ⓓ 所有模块和函数默认情况下都是私有的。</td></tr>
<tr><td>ⓡ</td><td>regulation</td><td>阐述Rust语言规则</td><td>必须记住</td><td>ⓡ 所有字符串文字类型都是引用，且具有静态生命周期。</td></tr>
<tr><td>Ⓒ</td><td>consensus</td><td>解释约定而非强制方法</td><td>最好记住</td><td>Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</td></tr>
<tr><td>Ⓘ</td><td>idea</td><td>必须记住</td><td>计算机技术和Rust语言基本概念</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#参考资料" id="参考资料">参考资料</a></h2>
<ul>
<li><a href="https://www.compart.com/de/unicode/category/So">Liste der Unicode-Zeichen der Kategorie „Sonstiges Symbol“</a></li>
</ul>
<h1><a class="header" href="#关于作业区和软件篋crate" id="关于作业区和软件篋crate">关于作业区和软件篋（Crate）</a></h1>
<p>　　软件篋（Crate）是其他语言的库（library）或包（package）的同义词。软件篋可以生成这里称之为应用程序的可执行文件或共享库，</p>
<h2><a class="header" href="#创建作业区命令" id="创建作业区命令">创建作业区命令</a></h2>
<pre><code class="language-bash"># 创建一个工作空间
mkdir workpsaces &amp;&amp; cd workpsaces
# 创建一个作业区hello-world
mkdir hello-world &amp;&amp; cd hello-world
# 创建一个作业区配置文件
touch Cargo.toml
# 作业区存在三个软件篋
# 注意：下面两行代码是一行命令
echo '[workspace]
members = [&quot;lib-hello&quot;, &quot;bin-hello&quot;, &quot;bin-local-hello&quot;]' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#创建默认共享软件篋程序命令" id="创建默认共享软件篋程序命令">创建默认共享软件篋程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;crate-project-name&gt;
# 命令实例，如创建名称为lib-hello的共享篋程序项目目录
mkdir lib-hello
# 进入软件篋程序根目录
cd lib-hello
# 命令说明：
# cargo init --name &lt;crate_name&gt; --lib
# 命令实例，如创建名称为hello_exercism的软件篋程序
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#创建默认可执行的应用程序命令" id="创建默认可执行的应用程序命令">创建默认可执行的应用程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;app-project-name&gt;
# 命令实例，如创建名称为bin-hello的应用程序项目目录
mkdir bin-hello
# 进入应用程序根目录
cd bin-hello
# 命令说明
# cargo init --name &lt;app-name&gt; --bin
# 命令实例，如创建名称为bin-hello的应用程序
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#说明共享软件篋结构" id="说明共享软件篋结构">说明共享软件篋结构</a></h2>
<p>　　使用软件工具Cargo，在默认Cargo项目基础上，这里除了增加了默认说明文件README.md外，还有增加了两个Cargo默认目录：tests和examples，同时在两个目录下增加了两个rust程序文件，其结果如下：</p>
<pre><code>── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   └── hello.rs
    ├── src
    │   └── lib.rs
    └── tests
        └── hello.rs
</code></pre>
<p>　　在上面的结构里，除了两个文件hello.rs之外，其他都是Cargo项目的默认目录和文件。这些目录和文件都是与Cargo工具默认命令相关的。Cargo项目还有其他默认目录和文件。目录src下的默认文件lib.rs是共享篋的入口文件。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html">a4.cargo,crates_and_basic_project_structure</a></li>
</ul>
<h1><a class="header" href="#关于cargo工具基础命令" id="关于cargo工具基础命令">关于Cargo工具基础命令</a></h1>
<p>　　安装Rust语言软件篋存在两个行为，其目的和作用是不同的。使用软件工具rustup安装的软件篋是支持版本管理工具，而使用软件工具Cargo安装的软件篋是支持项目级开发环境。</p>
<h2><a class="header" href="#编写规范格式代码工具-rustfmt" id="编写规范格式代码工具-rustfmt">编写规范格式代码工具 Rustfmt</a></h2>
<h3><a class="header" href="#安装rustfmt命令" id="安装rustfmt命令">安装Rustfmt命令</a></h3>
<pre><code>rustup self update
rustup component add rustfmt
</code></pre>
<h3><a class="header" href="#使用rustfmt命令" id="使用rustfmt命令">使用Rustfmt命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo fmt
</code></pre>
<h2><a class="header" href="#编写有效代码工具-clippy" id="编写有效代码工具-clippy">编写有效代码工具 Clippy</a></h2>
<h3><a class="header" href="#安装clippy命令" id="安装clippy命令">安装Clippy命令</a></h3>
<pre><code>rustup self update
rustup component add clippy
</code></pre>
<h3><a class="header" href="#使用clippy命令" id="使用clippy命令">使用Clippy命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo clippy
</code></pre>
<h2><a class="header" href="#说明cargo软件篋开发命令" id="说明cargo软件篋开发命令">说明Cargo软件篋开发命令</a></h2>
<p>　　除了上面两个开发工具命令之外，Cargo项目还有自身命令：</p>
<h3><a class="header" href="#测试代码运行命令" id="测试代码运行命令">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目和作业区 --
# 进来Cargo项目根目录
# 默认测试命令
# 说明：测试在目录tests下的所有测试文件
cargo test
</code></pre>
<h3><a class="header" href="#运行应用程序命令" id="运行应用程序命令">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目 --
# 进来Cargo项目根目录
# 命令说明：
# cargo run --example &lt;程序文件名称&gt;
# 命令实例，如运行在目录examples下文件名称为hello.rs的应用程序
cargo run --example hello
</code></pre>
<h3><a class="header" href="#运行应用程序命令-1" id="运行应用程序命令-1">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 仅适用于Cargo应用程序项目 --
# 进来Cargo项目根目录
# 默认运行命令
# 说明：运行目录src下默认入口文件main.rs
cargo run
</code></pre>
<h2><a class="header" href="#说明cargo作业区开发命令" id="说明cargo作业区开发命令">说明Cargo作业区开发命令</a></h2>
<h3><a class="header" href="#测试代码运行命令-1" id="测试代码运行命令-1">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区和所有Cargo项目 --
# 进来作业区根目录
# 命令说明：
# cargo test --package &lt;篋名称&gt;
# 或者
# cargo test -p &lt;篋名称&gt;
# 命令实例，如运行在Cargo项目lib-hello下共享篋名称为hello_exercism
cargo test -p hello_exercism
</code></pre>
<h3><a class="header" href="#运行应用程序命令-2" id="运行应用程序命令-2">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区内Cargo应用程序项目 --
# 进来作业区根目录
# 命令说明：
# cargo run --package &lt;篋名称&gt;
# 或者
# cargo run -p &lt;软件篋名称&gt;
# 命令实例，如运行在Cargo项目bin-hello下篋名称为bin-hello
cargo run -p bin-hello
</code></pre>
<p>　　后续还将介绍上面Cargo工具的其他实用命令。</p>
<h1><a class="header" href="#rust语言新思维和新概念" id="rust语言新思维和新概念">Rust语言新思维和新概念</a></h1>
<h2><a class="header" href="#变量生命期" id="变量生命期">变量生命期</a></h2>
<h2><a class="header" href="#不可变量immutable和可变量mutable" id="不可变量immutable和可变量mutable">不可变量(Immutable)和可变量(Mutable)</a></h2>
<h2><a class="header" href="#表达式expression和语句statements" id="表达式expression和语句statements">表达式(Expression)和语句(statements)</a></h2>
<h2><a class="header" href="#方法method和函数function" id="方法method和函数function">方法(method)和函数(function)</a></h2>
<h2><a class="header" href="#类和对象" id="类和对象">类和对象</a></h2>
<h2><a class="header" href="#全局软件篋和项目软件篋" id="全局软件篋和项目软件篋">全局软件篋和项目软件篋</a></h2>
<h1><a class="header" href="#关于软件篋项目hello-world" id="关于软件篋项目hello-world">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#项目目标" id="项目目标">项目目标</a></h2>
<p>　　学习和理解如何开发Rust语言的软件篋基本思路和方法，同时了解该项目的其他Cargo项目开发过程和方法。</p>
<h2><a class="header" href="#学习内容" id="学习内容">学习内容</a></h2>
<ul>
<li>了解和学习Cargo工具作业区概念</li>
<li>学习和理解共享软件篋整个开发过程</li>
<li>了解和学习单元测试和集成测试基本概念</li>
</ul>
<h1><a class="header" href="#开发软件篋命令" id="开发软件篋命令">开发软件篋命令</a></h1>
<h2><a class="header" href="#学习内容-1" id="学习内容-1">学习内容</a></h2>
<ul>
<li>熟悉和使用共享篋项目命令</li>
<li>熟悉和使用本地程序项目命令</li>
<li>熟悉和使用仓库程序项目命令</li>
<li>了解项目软件篋开发过程</li>
</ul>
<h2><a class="header" href="#开发共享篋项目命令" id="开发共享篋项目命令">开发共享篋项目命令</a></h2>
<p>　　只有发布了自己共享软件篋以后，才能开发这个项目的集成测试代码和集成实例。</p>
<h3><a class="header" href="#创建项目命令" id="创建项目命令">创建项目命令</a></h3>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入共享篋根目录
mkdir lib-hello &amp;&amp; cd lib-hello
# 创建名称为hello_exercism的共享篋
cargo init --name hello_exercism --lib
</code></pre>
<h3><a class="header" href="#开发共享篋和单元测试代码" id="开发共享篋和单元测试代码">开发共享篋和单元测试代码</a></h3>
<pre><code class="language-bash">vi Cargo.toml
vi src/lib.rs
mkdir tests
touch tests/u_hello.rs
vi tests/u_hello.rs
touch tests/i_hello.rs
vi tests/i_hello.rs
</code></pre>
<h3><a class="header" href="#开发共享篋的单元实例代码" id="开发共享篋的单元实例代码">开发共享篋的单元实例代码</a></h3>
<pre><code class="language-bash">mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h3><a class="header" href="#开发共享篋的单元实例代码-1" id="开发共享篋的单元实例代码-1">开发共享篋的单元实例代码</a></h3>
<pre><code class="language-bash">mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
</code></pre>
<h3><a class="header" href="#开发共享篋和集成测试代码" id="开发共享篋和集成测试代码">开发共享篋和集成测试代码</a></h3>
<pre><code class="language-bash">echo 'i_crate = { version = &quot;0.3.6&quot;, package = &quot;hello_exercism&quot;}' &gt;&gt; Cargo.toml
touch tests/i_hello.rs
vi tests/i_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h3><a class="header" href="#执行共享篋和测试代码" id="执行共享篋和测试代码">执行共享篋和测试代码</a></h3>
<pre><code class="language-bash"># 这些命令需要重复运行
cargo fmt
cargo clippy
cargo test
</code></pre>
<h3><a class="header" href="#执行共享篋的实例代码" id="执行共享篋的实例代码">执行共享篋的实例代码</a></h3>
<pre><code class="language-bash"># 这些命令需要重复运行
cargo fmt
cargo clippy
cargo run --example u_hello
cargo run --example i_hello
</code></pre>
<h2><a class="header" href="#开发本地程序项目命令" id="开发本地程序项目命令">开发本地程序项目命令</a></h2>
<h3><a class="header" href="#创建项目命令-1" id="创建项目命令-1">创建项目命令</a></h3>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入本地程序项目根目录
mkdir bin-local-hello &amp;&amp; cd bin-local-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-local-hello --bin
</code></pre>
<h3><a class="header" href="#配置项目文件cargotoml" id="配置项目文件cargotoml">配置项目文件Cargo.toml</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
echo 'hello_exercism = { path = &quot;../lib-hello&quot;}' &gt;&gt; Cargo.toml
</code></pre>
<h3><a class="header" href="#开发rust程序文件mainrs代码" id="开发rust程序文件mainrs代码">开发Rust程序文件main.rs代码</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
vi src/main.rs
</code></pre>
<h3><a class="header" href="#运行rust程序文件mainrs" id="运行rust程序文件mainrs">运行Rust程序文件main.rs</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
cargo run
# 或者
cargo run main
</code></pre>
<h2><a class="header" href="#开发仓库程序项目命令" id="开发仓库程序项目命令">开发仓库程序项目命令</a></h2>
<p>　　只有发布了自己共享软件篋以后，才能开发这个项目。</p>
<h3><a class="header" href="#创建项目命令-2" id="创建项目命令-2">创建项目命令</a></h3>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入本地程序项目根目录
mkdir bin-hello &amp;&amp; cd bin-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-hello --bin
</code></pre>
<h3><a class="header" href="#配置项目文件cargotoml-1" id="配置项目文件cargotoml-1">配置项目文件Cargo.toml</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
echo 'hello_exercism = &quot;0.3.7&quot;' &gt;&gt; Cargo.toml
</code></pre>
<h3><a class="header" href="#开发rust程序文件mainrs代码-1" id="开发rust程序文件mainrs代码-1">开发Rust程序文件main.rs代码</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
vi src/main.rs
</code></pre>
<h3><a class="header" href="#运行rust程序文件mainrs-1" id="运行rust程序文件mainrs-1">运行Rust程序文件main.rs</a></h3>
<pre><code class="language-bash"># 进入本地程序项目根目录
cargo run
# 或者
cargo run main
</code></pre>
<h2><a class="header" href="#开发共享篋项目hello_extern命令" id="开发共享篋项目hello_extern命令">开发共享篋项目hello_extern命令</a></h2>
<h3><a class="header" href="#创建项目命令-3" id="创建项目命令-3">创建项目命令</a></h3>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入共享篋根目录
mkdir lib-extern &amp;&amp; cd lib-extern
# 创建名称为hello_extern的共享篋
cargo init --name hello_extern --lib
</code></pre>
<h3><a class="header" href="#开发共享篋和单元测试代码-1" id="开发共享篋和单元测试代码-1">开发共享篋和单元测试代码</a></h3>
<pre><code class="language-bash">vi Cargo.toml
vi src/lib.rs
mkdir tests
touch tests/u_hello.rs
vi tests/u_hello.rs
</code></pre>
<h1><a class="header" href="#关于软件篋项目hello-world-1" id="关于软件篋项目hello-world-1">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#学习内容-2" id="学习内容-2">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
<li>了解项目目录和文件结构</li>
</ul>
<h2><a class="header" href="#项目名称" id="项目名称">项目名称</a></h2>
<h3><a class="header" href="#项目清单" id="项目清单">项目清单</a></h3>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<h3><a class="header" href="#软件篋清单" id="软件篋清单">软件篋清单</a></h3>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<h2><a class="header" href="#项目结构" id="项目结构">项目结构</a></h2>
<h3><a class="header" href="#目录清单" id="目录清单">目录清单</a></h3>
<table><thead><tr><th>目录名称</th><th>根目录说明</th><th>生成方式</th></tr></thead><tbody>
<tr><td>src</td><td>篋源代码目录</td><td>Cargo命令</td></tr>
<tr><td>tests</td><td>篋测试源代码目录</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>篋实例源代码目录</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>篋构建目录</td><td>Cargo命令</td></tr>
<tr><td>debug</td><td>篋调试构建目录</td><td>Cargo命令</td></tr>
<tr><td>release</td><td>篋版本构建目录</td><td>Cargo命令</td></tr>
</tbody></table>
<h3><a class="header" href="#文件清单" id="文件清单">文件清单</a></h3>
<table><thead><tr><th>名称</th><th>说明</th><th>内容属性</th><th>名称属性</th></tr></thead><tbody>
<tr><td>README.md</td><td>项目说明文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.lock</td><td>项目配置锁定文件</td><td>不可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.toml</td><td>项目配置锁定文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>main.rs</td><td>可执行软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>lib.rs</td><td>共享软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>hello.rs</td><td>软件篋源代码文件</td><td>可修改</td><td>可修改</td></tr>
</tbody></table>
<h3><a class="header" href="#所有项目结构树" id="所有项目结构树">所有项目结构树</a></h3>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── hello.rs
    ├── lib-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── Cargo.txt
    │   ├── README.md
    │   ├── examples
    │   │   ├── i_hello.rs
    │   │   ├── main.rs
    │   │   └── u_hello.rs
    │   ├── src
    │   │   └── lib.rs
    │   └── tests
    │       ├── i_hello.rs
    │       └── u_hello.rs
    └── target
        ├── debug
        │   ├── bin-hello
        │   ├── bin-hello.d
        │   ├── bin-hello.dSYM -&gt; deps/bin_hello-e487e1d0c9778df2.dSYM
        │   ├── bin-local-hello
        │   ├── bin-local-hello.d
        │   ├── bin-local-hello.dSYM -&gt; deps/bin_local_hello-8b6b201fe1d502bb.dSYM
        │   ├── build
        │   ├── deps
        │   ├── examples
        │   ├── incremental
        │   ├── libhello_exercism.d
        │   ├── libhello_exercism.rlib
        │   └── native
        └── release
            ├── bin-hello
            ├── bin-hello.d
            ├── bin-local-hello
            ├── bin-local-hello.d
            ├── build
            ├── deps
            ├── examples
            ├── incremental
            ├── libhello_exercism.d
            ├── libhello_exercism.rlib
            └── native
</code></pre>
<h2><a class="header" href="#题外话" id="题外话">题外话</a></h2>
<h3><a class="header" href="#目录与命令" id="目录与命令">目录与命令</a></h3>
<table><thead><tr><th>目录名称</th><th>生成命令</th><th>删除命令</th></tr></thead><tbody>
<tr><td>src</td><td>cargo new &lt;project_name&gt; <br/> cargo new &lt;project_name&gt; --lib <br/> cargo new &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; <br/> cargo init --name &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; --lib</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>随下面命令自动生成</td><td>cargo clean</td></tr>
<tr><td>debug</td><td>cargo build 或者 cargo run</td><td>cargo clean --target-dir target/debug</td></tr>
<tr><td>release</td><td>cargo build --release <br/> cargo run --release</td><td>cargo clean --release <br/> cargo clean --target-dir target/release</td></tr>
</tbody></table>
<h1><a class="header" href="#共享软件篋hello_exercism程序代码解释" id="共享软件篋hello_exercism程序代码解释">共享软件篋hello_exercism：程序代码解释</a></h1>
<p>　　共享软件篋本身只能提供给其他共享篋和应用程序使用。Cargo工具实现了项目内所有目录和文件有机联系在一起。当运行测试代码或者实例代码时，这些代码都知道应该怎么样连接到正在开发的共享篋。</p>
<h2><a class="header" href="#学习内容-3" id="学习内容-3">学习内容</a></h2>
<ul>
<li>阐述Rust语言文件功能</li>
<li>理解项目共享篋程序代码</li>
</ul>
<h2><a class="header" href="#项目配置文件" id="项目配置文件">项目配置文件</a></h2>
<h3><a class="header" href="#项目配置文件-cargotoml" id="项目配置文件-cargotoml">项目配置文件: ./Cargo.toml</a></h3>
<p>　　文件Cargo.toml是由用户编写的描述项目共享篋依赖关系。而文件Cargo.lock包含有关共享软件篋的依赖项的确切信息。它是由Cargo工具自动生成和维护的，不应手动对其进行编辑。</p>
<pre><code class="language-toml"># Crate Configuration File: ./Cargo.toml
[package]
name = &quot;hello_exercism&quot;
version = &quot;0.3.8&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
repository = &quot;https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world&quot;
homepage = &quot;https://crates.io/crates/hello_exercism&quot;
documentation = &quot;https://cnruby.github.io/learn-rust-by-crates/hello-world/hello_exercism/&quot;
description = &quot;how to create an own crate&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
i_crate = { version = &quot;0.3.6&quot;, package = &quot;hello_exercism&quot;}

</code></pre>
<p>　　在文件Cargo.toml里，最重要的一项是共享软件篋名称：name。这是使用该共享篋的入口名称。这里默认模块名称为hello_exercism。</p>
<p>　　最常用的一节是共享篋依赖关系：[dependencies]。这里有一行依赖关系代码，说明共享篋有赖于外部共享篋。这里使用了软件篋hello_exercism的已经发布的版本，只是为了解释问题和说明方便，实际上可以依赖所有需要的共享篋。</p>
<h2><a class="header" href="#程序文件librs" id="程序文件librs">程序文件lib.rs</a></h2>
<p>　　程序文件lib.rs是共享篋的入口文件。这里它有两个函数：hello()和hallo()，其功能都是返回一个字符串文字。hello()返回英文问候，而hallo()返回德文问候。它们返回的类型也都是&amp;'static str的字符串，这一类型是静态生命周期的字符串文字，或者简单说静态的字符串文字。</p>
<p>　　ⓡ 所有字符串文字类型都是引用，且具有静态生命周期的功能。</p>
<p>　　↳ 这里的函数返回值是包含一个引用字符串文字类型值，所以函数返回类型也要此类型<code>&amp;str</code>。因为在整个程序过程中需要该类型是有效的，所以此类型还要是静态生命周期<code>'static</code>。</p>
<p>　　Ⓓ 在默认情况下，所有使用关键词mod定义的模块和使用关键词fn定义的函数都是私有的。要使得它们可公开访问的话，就需要使用修饰词关键词'pub'。</p>
<p>　　↳ hello()是公共可访问的函数，而hallo()是只有模块hello_exercism内可访问的私有函数。</p>
<p>　　↳ 所有私有函数的单元测试代码必须在程序文件内。将在后面说明该文件的相关测试代码。</p>
<p>　　Ⓓ 共享篋模块是公开的。</p>
<p>　　↳ 这里共享篋模块名称是hello_exercism，尽管它没有使用关键词mod定义，但是Rust语言默认定义了它。</p>
<p>　　这里仅仅说明该程序两个函数的功能，在函数下面的测试代码，将在后面章节说明。接下来的内容，可以看到使用执行程序调用该软件篋的公共接口：函数hello()。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#说明目录examples的实例文件" id="说明目录examples的实例文件">说明目录examples的实例文件</a></h2>
<h3><a class="header" href="#单元实例文件u_hellors" id="单元实例文件u_hellors">单元实例文件u_hello.rs</a></h3>
<p>　　单元实例仅仅测试此软件篋自身的功能。</p>
<p>　　ⓡ 凡是存在main()函数的Rust程序都是可执行的。</p>
<p>　　这个程序的功能是调用了该项目的软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。</p>
<p>　　Ⓓ 在运行实例目录下可执行文件时，Cargo工具自动会调用程序lib.rs。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/u_hello.rs
fn main() {
    println!(&quot;{}&quot;, hello_exercism::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example u_hello -q
Hallo, Welt!
Hello, World!
</code></pre>
<h3><a class="header" href="#集成实例文件i_hellors" id="集成实例文件i_hellors">集成实例文件i_hello.rs</a></h3>
<p>　　集成实例测试此共享篋与外部其它共享篋的功能。</p>
<p>　　这个程序的功能是调用了外部软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。此外，还比较了正在开发的软件篋与外部软件篋的函数返回值。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/i_hello.rs
fn main() {
    println!(&quot;{}&quot;, i_crate::hello());
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example i_hello -q
Hello, World!
Hallo, Welt!
</code></pre>
<h2><a class="header" href="#题外话-1" id="题外话-1">题外话</a></h2>
<h3><a class="header" href="#rust语言类型与关键词" id="rust语言类型与关键词">Rust语言类型与关键词</a></h3>
<p>　　对于修饰词关键词'static'，Rust语言以与常量类似的方式提供了类似“全局变量”的功能。对每一个值只有一个实例，并且位于内存中的固定位置。</p>
<p>　　在Rust语言里，存在一类关键词是修饰词关键词，如关键词&quot;pub&quot;和“static”。</p>
<table><thead><tr><th>类型</th><th>关键词</th><th>类型说明</th></tr></thead><tbody>
<tr><td>&amp;str</td><td></td><td>字符串文字</td></tr>
<tr><td></td><td>'static</td><td>静态修饰词关键词</td></tr>
<tr><td></td><td>'</td><td>生命周期注释符</td></tr>
<tr><td></td><td>'static</td><td>静态生命周期注释符</td></tr>
</tbody></table>
<h3><a class="header" href="#浅谈软件篋的模块" id="浅谈软件篋的模块">浅谈软件篋的模块</a></h3>
<p>　　每一个共享篋都有自己的入口模块名称，这里是hello_exercism，使用共享篋都要从这个名称开始，这里模块hello_exercism有自己的函数hello()。程序文件lib.rs可以使用关键词mod再定义模块名称，但是它们都是hello_exercism的子模块。</p>
<h3><a class="header" href="#函数hello功能" id="函数hello功能">函数hello()功能</a></h3>
<p>　　从作用意义上，共享篋的函数hello()类似于使用关键词let语句，即可把它看作为一个类型为&amp;str的字符串与一个变量绑定，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">// Rust File: examples/main.rs
fn main() {
    let _: &amp;'static str = &quot;Hello, World!&quot;;
    let _: &amp;str = &quot;Hello, World!&quot;;
}

</code></pre></pre>
<h3><a class="header" href="#表达式语句和模块" id="表达式语句和模块">表达式、语句和模块</a></h3>
<p>　　在Rust语言里，表达式和语句都可以作为一行代码。要是一行代码，最后没有分号就是表达式，而有分号就是语句。表达式只有作为函数的返回值。</p>
<p>　　表达式和语句可以汇聚成一个由{}内的代码块和由关键词fn开始的函数与方法。函数和方法可以组成一个由关键词mod开始的模块。若干个模块可以形成由关键词mod开始的父模块。</p>
<h3><a class="header" href="#项目配置文件-1" id="项目配置文件-1">项目配置文件</a></h3>
<p>　　除了项目配置文件Cargo.toml之外，还可以有其它功能的配置文件，如工具rustfmt的配置文件。</p>
<h2><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://blog.csdn.net/s_lisheng/article/details/79287713">Rust中的const和static</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying-dependencies</a></li>
</ul>
<h1><a class="header" href="#共享篋-hello_exercism-目录tests的测试代码解释" id="共享篋-hello_exercism-目录tests的测试代码解释">共享篋 hello_exercism ：目录tests的测试代码解释</a></h1>
<p>　　之所以在本共享篋里测试代码存在重复，是因为需要解释不同的问题。</p>
<h2><a class="header" href="#学习内容-4" id="学习内容-4">学习内容</a></h2>
<ul>
<li>理解开发共享篋的测试代码</li>
<li>了解公共接口的单元测试方法</li>
<li>了解目录tests的集成测试方法</li>
</ul>
<h2><a class="header" href="#公共接口的单元测试" id="公共接口的单元测试">公共接口的单元测试</a></h2>
<h3><a class="header" href="#单元测试文件u_hellors" id="单元测试文件u_hellors">单元测试文件u_hello.rs</a></h3>
<p>　　在下面的单元测试程序里，只有一个测试函数，其功能是判断函数hello()返回值与字符串文字“Hello, World!”是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/u_hello.rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works_at_uint() {
        assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
    }
}
</code></pre></pre>
<p>　　Ⓘ 单元测试（Unit tests）是单个模块或者说单个软件篋的单独测试。</p>
<p>　　一般情况下，单元测试很小且可以测试私有代码。它们的目的是软件篋每一个功能能否正常工作。Rust语言将单元测试分成两类：这里探讨公共接口的单元测试和下面将要说明的私有代码的单元测试。</p>
<p>　　ⓡ 从模块范围之外只能访问模块的公共接口，而不能访问模块的私有内容。</p>
<p>　　Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</p>
<p>　　ⓡ 每一个单元测试函数带有'#[test]'注解标记。测试文件名称命名是由用户自己确定的。</p>
<p>　　每个测试函数都是单独地调用正在开发的共享软件篋进行运行的。因此Cargo工具将共享软件篋纳入到每个测试函数的范围里。</p>
<p>　　Ⓓ 所有公共接口的单元测试文件存储于默认测试目录tests下。</p>
<h2><a class="header" href="#基于测试目录tests的集成测试" id="基于测试目录tests的集成测试">基于测试目录tests的集成测试</a></h2>
<h3><a class="header" href="#集成测试文件i_hellors" id="集成测试文件i_hellors">集成测试文件i_hello.rs</a></h3>
<p>　　在下面的集成测试程序里，有两个测试函数，第一个函数功能是判断外部共享篋的函数hello()返回值与字符串文字“Hello, World!”是否完全一致。第二个函数功能是判断正在开发共享篋与外部共享篋的函数hello()返回值是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/i_hello.rs
#[test]
fn it_works_with_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<p>　　Ⓘ 集成测试（Integration tests）是与外部的多个共享篋的测试。它们比较大，但仅测试正在开发共享篋的公共接口。它们的目的是与其它篋能否正常协同工作。</p>
<p>　　集成测试可以存储于这里探讨的基于测试目录tests，也可以存储于下面将要解释的基于共享篋目录src。但是它们处理代码的方式是完全不同的。</p>
<p>　　Ⓒ 集成测试不需要使用注释'#[cfg(test)]'来注释任何测试代码。</p>
<p>　　ⓡ 每一个单元测试函数注解带有'#[test]'标记。</p>
<p>　　ⓡ 集成测试文件可以存储于默认测试目录tests下。</p>
<h2><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#共享软件篋-hello_exercism-目录src的测试代码解释" id="共享软件篋-hello_exercism-目录src的测试代码解释">共享软件篋 hello_exercism ：目录src的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-5" id="学习内容-5">学习内容</a></h2>
<ul>
<li>了解共享篋目录src下的测试代码结构</li>
<li>了解私有代码的单元测试方法</li>
<li>了解目录src下的集成测试方法</li>
</ul>
<h2><a class="header" href="#目录src测试代码结构" id="目录src测试代码结构">目录src测试代码结构</a></h2>
<pre><code class="language-bash">$ tree ./src -L 3
./src
├── integration_tests
│   ├── i_hello.rs
│   └── mod.rs
├── lib.rs
└── private_tests
    ├── mod.rs
    └── owned_hello.rs
</code></pre>
<h2><a class="header" href="#默认模块文件modrs" id="默认模块文件modrs">默认模块文件mod.rs</a></h2>
<p>　　Ⓓ 从目录src开始，Cargo项目共享篋程序目录名称就是模块名称。目录src就是共享篋模块名称，其模块文件就是lib.rs。</p>
<p>　　如：这里共享篋名称hello_exercism就是模块名称</p>
<p>　　Ⓓ 所有目录src的子目录也是模块名称，其模块文件就是mod.rs。</p>
<p>　　如，目录private_tests就是模块hello_exercism的子模块。</p>
<p>　　Ⓓ 除了lib.rs和mod.rs文件以外，所有其它文件名称也就是模块名称，且其文件名称就是模块名称。</p>
<p>　　如，文件i_hello.rs就是一个模块，其模块名称为i_hello。</p>
<h2><a class="header" href="#私有代码的单元测试" id="私有代码的单元测试">私有代码的单元测试</a></h2>
<p>　　Cargo项目私有代码的单元测试思路：单元测试与共享篋程序代码是融为一体的。所以测试代码都是在私有代码相关的可访问模块里，是不可分开的。</p>
<h3><a class="header" href="#程序文件librs与单元测试文件owned_hellors" id="程序文件librs与单元测试文件owned_hellors">程序文件lib.rs与单元测试文件owned_hello.rs</a></h3>
<p>　　为了测试共享篋程序文件src/lib.rs的私有函数hallo()，需要将测试代码存放在该文件的可访问模块里，测试代码可以分离到另外文件里。</p>
<p>　　在篋程序文件src/lib.rs里，对于私有代码的单元测试，有四段单元测试代码，它们是为三个不同模块：hello_exercism::private_tests::owned_hello、hello_exercism::private_tests_with_use和hello_exercism::private_tests_without_use，而每一个模块都是一个单元测试函数，其测试目的和代码含义都是完全一样的，只是代码形式不一样。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<p>　　在程序文件lib.rs里，第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的单元测试文件或者说模块。分离文件'src/private_tests/owned_hello.rs'如下所示里。它们的第二行说明其下一行模块的位置。</p>
<p>　　Ⓓ 因为第二段代码的访问模块方式是默认方式，所以第二行代码可以省略。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/owned_hello.rs
use super::*;
//use super::hallo;

#[test]
fn it_works_at_private() {
    assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
}
</code></pre></pre>
<p>　　第三段代码和第四段代码方法是把测试代码存放在可访问私有代码的模块里。它们仅仅是否使用了关键词use不同而已。</p>
<p>　　第三段代码的第三行说明该模块hello_exercism::private_tests_with_use需要访问其父模块hello_exercism的所有函数。</p>
<p>　　第四段代码里super也是说明了需要使用期父模块的函数hallo()。</p>
<p>　　在程序文件mod.rs和owned_hello.rs里，第一行代码都是需要访问其父模块的所有函数。因为从模块owned_hello出发，需要访问其上两层模块，使用两个模块里都需要使用super语句。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/mod.rs
use super::*;
mod owned_hello;
</code></pre></pre>
<h2><a class="header" href="#基于共享篋目录src内的集成测试" id="基于共享篋目录src内的集成测试">基于共享篋目录src内的集成测试</a></h2>
<p>　　基于共享篋目录src内的集成测试，与私有代码的单元测试思路有类似性，其测试代码也都是在模块程序代码里，但是有本质上区别，它仅仅使用了共享篋模块结构属性，而非共享篋的原代码，因此它是只能访问共享篋的公共接口。</p>
<p>　　在程序文件lib.rs里，存在两段集成测试集成代码。第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的集成测试文件或者说模块。代码原理与前面私有代码的单元测试是完全一样的。</p>
<p>　　不同代码的是，程序文件mod.rs和集成测试文件i_hello.rs。程序文件mod.rs没有super相关语句，只是说明了使用i_hello模块。集成测试文件i_hello.rs也是不一样的，也没有super相关语句，而是引用了一行使用自己模块的语句，且把自己也称之为模块hello_exercism，这个模块名称可以随意自己命名。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/mod.rs
mod i_hello;
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/i_hello.rs
use crate as hello_exercism;

#[test]
fn it_works_with_only_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<ul>
<li><img src="hello-world/../../images/crates_io_api_access_create.png" alt="image" /></li>
</ul>
<h2><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#开发软件篋hello_exercism的本地程序" id="开发软件篋hello_exercism的本地程序">开发软件篋hello_exercism的本地程序</a></h1>
<ul>
<li>阐述项目本地程序开发过程</li>
<li>理解项目本地程序代码</li>
</ul>
<h2><a class="header" href="#cargo工具命令说明" id="cargo工具命令说明">Cargo工具命令说明</a></h2>
<pre><code class="language-bash">cargo run
cargo run -q
</code></pre>
<pre><code class="language-toml">[package]
name = &quot;bin-local-hello&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Gudao Luo &lt;iotoi.cn@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
hello_exercism = { path = &quot;../lib-hello&quot;}
</code></pre>
<p><a href="https://stackoverflow.com/questions/33025887/how-to-use-a-local-unpublished-crate">how-to-use-a-local-unpublished-crate</a></p>
<h1><a class="header" href="#子项目仓库程序hello_exercism" id="子项目仓库程序hello_exercism">子项目：仓库程序hello_exercism</a></h1>
<ul>
<li>阐述项目仓库程序开发过程</li>
<li>理解项目仓库程序代码</li>
</ul>
<h1><a class="header" href="#题外话-2" id="题外话-2">题外话</a></h1>
<h2><a class="header" href="#cargo工具命令" id="cargo工具命令">Cargo工具命令</a></h2>
<h3><a class="header" href="#构建和运行软件篋目录examples下文件" id="构建和运行软件篋目录examples下文件">构建和运行软件篋目录examples下文件</a></h3>
<pre><code class="language-bash"># cargo build --example &lt;目录examples下无扩展名的文件名称&gt;
# cargo run --example &lt;目录examples下无扩展名的文件名称&gt;
cargo build --example hello
cargo run --example hello
</code></pre>
<h3><a class="header" href="#cargo项目构建命令" id="cargo项目构建命令">Cargo项目构建命令</a></h3>
<pre><code class="language-bash">cargo build
cargo build --release
</code></pre>
<pre><code>── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── examples
    │   └── hello.rs
    ├── README.md
    ├── src
    │   └── lib.rs
    ├── target
    │   ├── debug
    │   └── package
    └── tests
        └── hello.rs
</code></pre>
<h3><a class="header" href="#cargo项目测试特定代码命令" id="cargo项目测试特定代码命令">Cargo项目测试特定代码命令</a></h3>
<pre><code class="language-bash">cargo test tests::it_works_hello_exercism
cargo test test_hello_world
</code></pre>
<h2><a class="header" href="#项目重要配置和代码" id="项目重要配置和代码">项目重要配置和代码</a></h2>
<h2><a class="header" href="#思考问题" id="思考问题">思考问题</a></h2>
<h3><a class="header" href="#str和static-str有什么区别" id="str和static-str有什么区别"><code>＆str</code>和<code>＆'static str</code>有什么区别？</a></h3>
<ul>
<li>在语句里，它们是没有任何区别。</li>
<li>在函数返回类型里，它们是有区别的。</li>
</ul>
<h3><a class="header" href="#使用关键词use和extern有什么区别" id="使用关键词use和extern有什么区别">使用关键词use和extern有什么区别？</a></h3>
<ul>
<li>自Rust2018版本以来几乎不再需要extern语句。</li>
<li>关键词use方法与以前相同。</li>
<li>关键词use仅仅是引用标准符号的简写，或者使用trait时必须出现。</li>
</ul>
<h3><a class="header" href="#注解cfgtest有什么意义" id="注解cfgtest有什么意义">注解#[cfg(test)]有什么意义?</a></h3>
<ul>
<li>它告诉编译器在测试环境下进行编译，</li>
<li>仅当使用命令'cargo test'运行测试时，Cargo工具才会编译测试代码。</li>
</ul>
<h2><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/29403920/whats-the-difference-between-use-and-extern">whats-the-difference-between-use-and-extern</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-alpha.2/book/crates-and-modules.html">crates-and-modules</a></li>
<li><a href="https://freyskeyd.fr/cfg-test-and-cargo-test-a-missing-information/">cfg-test-and-cargo-test-a-missing-information</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">ch11-03-test-organization</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://stackoverflow.com/questions/49684657/what-is-the-difference-between-str-and-static-str-in-a-static-or-const">what-is-the-difference-between-str-and-static-str-in-a-static-or-const</a></li>
</ul>
<h1><a class="header" href="#第四章-软件篋borrowing_exerci" id="第四章-软件篋borrowing_exerci">第四章 软件篋borrowing_exerci</a></h1>
<ul>
<li><a href="https://stackoverflow.com/questions/22596920/split-a-module-across-several-files">split-a-module-across-several-files</a></li>
<li><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">ch07-05-separating-modules-into-different-files</a></li>
<li><a href="https://chronicbuildfailure.co/splitting-up-modules-in-rust-5ad7713201d5">splitting-up-modules-in-rust</a></li>
</ul>
<h1><a class="header" href="#关于软件篋borrowing_exerci" id="关于软件篋borrowing_exerci">关于软件篋borrowing_exerci</a></h1>
<h1><a class="header" href="#开发软件篋borrowing_exerci" id="开发软件篋borrowing_exerci">开发软件篋borrowing_exerci</a></h1>
<ul>
<li><a href="https://users.rust-lang.org/t/cargo-test-internal-packages/5187/2">cargo-test-internal-packages</a></li>
</ul>
<h1><a class="header" href="#使用软件篋borrowing_exerci" id="使用软件篋borrowing_exerci">使用软件篋borrowing_exerci</a></h1>
<h1><a class="header" href="#第二章" id="第二章">第二章</a></h1>
<h1><a class="header" href="#关于软件篋trait_exerci" id="关于软件篋trait_exerci">关于软件篋trait_exerci</a></h1>
<h1><a class="header" href="#开发软件篋trait_exerci" id="开发软件篋trait_exerci">开发软件篋trait_exerci</a></h1>
<h1><a class="header" href="#使用软件篋trait_exerci" id="使用软件篋trait_exerci">使用软件篋trait_exerci</a></h1>
<h1><a class="header" href="#第二章-1" id="第二章-1">第二章</a></h1>
<p><a href="https://archive.fosdem.org/2018/schedule/event/rust_testing_mocking/attachments/slides/2113/export/events/attachments/rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf">rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf</a></p>
<h1><a class="header" href="#关于软件篋mod_trait_exerci" id="关于软件篋mod_trait_exerci">关于软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#开发软件篋mod_trait_exerci" id="开发软件篋mod_trait_exerci">开发软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#使用软件篋mod_trait_exerci" id="使用软件篋mod_trait_exerci">使用软件篋mod_trait_exerci</a></h1>
<h1><a class="header" href="#第四章" id="第四章">第四章</a></h1>
<h1><a class="header" href="#关于软件篋deref_exerci" id="关于软件篋deref_exerci">关于软件篋deref_exerci</a></h1>
<h1><a class="header" href="#开发软件篋deref_exerci" id="开发软件篋deref_exerci">开发软件篋deref_exerci</a></h1>
<h1><a class="header" href="#使用软件篋deref_exerci" id="使用软件篋deref_exerci">使用软件篋deref_exerci</a></h1>
<h1><a class="header" href="#软件篋macro_exerci" id="软件篋macro_exerci">软件篋macro_exerci</a></h1>
<h1><a class="header" href="#关于软件篋macro_exerci" id="关于软件篋macro_exerci">关于软件篋macro_exerci</a></h1>
<h1><a class="header" href="#开发软件篋macro_exerci" id="开发软件篋macro_exerci">开发软件篋macro_exerci</a></h1>
<h1><a class="header" href="#使用软件篋macro_exerci" id="使用软件篋macro_exerci">使用软件篋macro_exerci</a></h1>
<h1><a class="header" href="#软件篋generics_exerci" id="软件篋generics_exerci">软件篋generics_exerci</a></h1>
<h1><a class="header" href="#关于软件篋generics_exerci" id="关于软件篋generics_exerci">关于软件篋generics_exerci</a></h1>
<h1><a class="header" href="#开发软件篋generics_exerci" id="开发软件篋generics_exerci">开发软件篋generics_exerci</a></h1>
<h1><a class="header" href="#使用软件篋generics_exerci" id="使用软件篋generics_exerci">使用软件篋generics_exerci</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
