<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>以软件篋学习Rust语言</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Chinese">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="foreword/index.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li><ol class="section"><li><a href="foreword/about.html"><strong aria-hidden="true">1.1.</strong> 本书项目结构</a></li><li><a href="foreword/crate.html"><strong aria-hidden="true">1.2.</strong> 关于作业区和软件篋实例</a></li><li><a href="foreword/cargo.html"><strong aria-hidden="true">1.3.</strong> 关于Cargo工具基础命令</a></li><li><a href="foreword/rust.html"><strong aria-hidden="true">1.4.</strong> Rust语言新思维和新概念</a></li></ol></li><li><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> 软件篋hello_exercism</a></li><li><ol class="section"><li><a href="hello-world/about.html"><strong aria-hidden="true">2.1.</strong> 关于软件篋项目</a></li><li><a href="hello-world/commands-lib.html"><strong aria-hidden="true">2.2.</strong> 共享篋：开发命令</a></li><li><a href="hello-world/lib.html"><strong aria-hidden="true">2.3.</strong> 共享篋：程序代码解释</a></li><li><a href="hello-world/lib-tests.html"><strong aria-hidden="true">2.4.</strong> 共享篋：目录tests的测试代码解释</a></li><li><a href="hello-world/src-tests.html"><strong aria-hidden="true">2.5.</strong> 共享篋：目录src的测试代码解释</a></li><li><a href="hello-world/commands-local.html"><strong aria-hidden="true">2.6.</strong> 本地程序：开发命令</a></li><li><a href="hello-world/bin-local.html"><strong aria-hidden="true">2.7.</strong> 本地程序：程序代码解释</a></li><li><a href="hello-world/commands-bin.html"><strong aria-hidden="true">2.8.</strong> 仓库程序：开发命令</a></li><li><a href="hello-world/bin.html"><strong aria-hidden="true">2.9.</strong> 仓库程序：程序代码解释</a></li><li><a href="hello-world/off-topic.html"><strong aria-hidden="true">2.10.</strong> 题外话</a></li><li><a href="hello-world/debug.html"><strong aria-hidden="true">2.11.</strong> 调试代码</a></li></ol></li><li><a href="hello-trait/index.html"><strong aria-hidden="true">3.</strong> 软件篋trait_exerci</a></li><li><ol class="section"><li><a href="hello-trait/examples-struct.html"><strong aria-hidden="true">3.1.</strong> 类型关键词struct</a></li><li><a href="hello-trait/examples-impl.html"><strong aria-hidden="true">3.2.</strong> 关键词impl与方法代码实现</a></li><li><a href="hello-trait/examples-methods.html"><strong aria-hidden="true">3.3.</strong> 函数与方法代码实现</a></li><li><a href="hello-trait/examples-trait.html"><strong aria-hidden="true">3.4.</strong> 衔接关键词trait</a></li><li><a href="hello-trait/examples-trait-impl.html"><strong aria-hidden="true">3.5.</strong> 特质实现及其对象</a></li><li><a href="hello-trait/examples-trait-default.html"><strong aria-hidden="true">3.6.</strong> 题外话：默认衔接特质Default</a></li><li><a href="hello-trait/lib-structure.html"><strong aria-hidden="true">3.7.</strong> 程序代码结构</a></li><li><a href="hello-trait/about.html"><strong aria-hidden="true">3.8.</strong> 关于软件篋项目</a></li><li><a href="hello-trait/commands-lib.html"><strong aria-hidden="true">3.9.</strong> 共享篋：开发命令</a></li><li><a href="hello-trait/lib-codes.html"><strong aria-hidden="true">3.10.</strong> 共享篋：程序代码解释</a></li><li><a href="hello-trait/lib-tests.html"><strong aria-hidden="true">3.11.</strong> 共享篋：目录测试代码解释</a></li><li><a href="hello-trait/off-topic.html"><strong aria-hidden="true">3.12.</strong> 题外话</a></li></ol></li><li><a href="hello-mod-trait/index.html"><strong aria-hidden="true">4.</strong> 软件篋mod_trait_exerci</a></li><li><ol class="section"><li><a href="hello-mod-trait/about.html"><strong aria-hidden="true">4.1.</strong> 关于软件篋mod_trait_exerci</a></li><li><a href="hello-mod-trait/crate-structure.html"><strong aria-hidden="true">4.2.</strong> 文件与模块</a></li><li><a href="hello-mod-trait/lib-codes.html"><strong aria-hidden="true">4.3.</strong> 共享篋：程序结构和代码解释</a></li><li><a href="hello-mod-trait/exampels-codes.html"><strong aria-hidden="true">4.4.</strong> 三种调用方式解释</a></li><li><a href="hello-mod-trait/examples-dispatch.html"><strong aria-hidden="true">4.5.</strong> 理解动态与静态调度实现</a></li><li><a href="hello-mod-trait/examples-miri.html"><strong aria-hidden="true">4.6.</strong> 深度解析动态与静态调度实现</a></li><li><a href="hello-mod-trait/lib-fn.html"><strong aria-hidden="true">4.7.</strong> 共享篋：简单三层结构实现</a></li><li><a href="hello-mod-trait/lib-static.html"><strong aria-hidden="true">4.8.</strong> 共享篋：基于封装的静态调度实现</a></li><li><a href="hello-mod-trait/lib-dynamic.html"><strong aria-hidden="true">4.9.</strong> 共享篋：基于封装的动态调度实现</a></li><li><a href="hello-mod-trait/lib-tests.html"><strong aria-hidden="true">4.10.</strong> 共享篋：单元测试代码解释</a></li><li><a href="hello-mod-trait/off-topic.html"><strong aria-hidden="true">4.11.</strong> 题外话：泛型实例</a></li></ol></li><li><a href="hello-borrowing/index.html"><strong aria-hidden="true">5.</strong> 软件篋borrowing_exerci（一）</a></li><li><ol class="section"><li><a href="hello-borrowing/about.html"><strong aria-hidden="true">5.1.</strong> 关于应用篋borrowing_exerci</a></li><li><a href="hello-borrowing/clone-copy.html"><strong aria-hidden="true">5.2.</strong> 特质：克隆（Clone）和复制（Copy）</a></li><li><a href="hello-borrowing/cargo-expand.html"><strong aria-hidden="true">5.3.</strong> 可变类型派生分析</a></li><li><a href="hello-borrowing/reference-pointer.html"><strong aria-hidden="true">5.4.</strong> 引用Reference与指针Pointer基本概念</a></li><li><a href="hello-borrowing/reference-type-pointer.html"><strong aria-hidden="true">5.5.</strong> 引用、类型与原始指针解释</a></li><li><a href="hello-borrowing/borrowing-string.html"><strong aria-hidden="true">5.6.</strong> 应用篋：字符串类型借用方法</a></li><li><a href="hello-borrowing/borrowing-fn.html"><strong aria-hidden="true">5.7.</strong> 应用篋：方法借用实例</a></li><li><a href="hello-borrowing/borrowing-closure.html"><strong aria-hidden="true">5.8.</strong> 应用篋：闭包借用实例</a></li><li><a href="hello-borrowing/keyword-move.html"><strong aria-hidden="true">5.9.</strong> 应用篋：移动关键词move借用实例</a></li><li><a href="hello-borrowing/borrowing-for-loop.html"><strong aria-hidden="true">5.10.</strong> 应用篋：循环for语句不可变借用实例</a></li><li><a href="hello-borrowing/ref_and.html"><strong aria-hidden="true">5.11.</strong> 关键词ref与引用符&amp;</a></li></ol></li><li><a href="hello-mut-borrowing/index.html"><strong aria-hidden="true">6.</strong> 软件篋borrowing_exerci（二）</a></li><li><ol class="section"><li><a href="hello-mut-borrowing/about.html"><strong aria-hidden="true">6.1.</strong> 关于应用篋mut_borrowing_exerci</a></li><li><a href="hello-mut-borrowing/borrowing-count.html"><strong aria-hidden="true">6.2.</strong> 应用篋：借用次数实例</a></li><li><a href="hello-mut-borrowing/borrowing-dbg.html"><strong aria-hidden="true">6.3.</strong> 应用篋：宏dbg!与可变实例</a></li><li><a href="hello-mut-borrowing/borrowing-mut.html"><strong aria-hidden="true">6.4.</strong> 应用篋：可变大小类型借用实例</a></li><li><a href="hello-mut-borrowing/borrowing-for-loop-mut.html"><strong aria-hidden="true">6.5.</strong> 应用篋：循环for语句可变借用实例</a></li><li><a href="hello-mut-borrowing/borrowing-mut-fn.html"><strong aria-hidden="true">6.6.</strong> 应用篋：可变类型与函数实例</a></li><li><a href="hello-mut-borrowing/crates.html"><strong aria-hidden="true">6.7.</strong> 题外话：使用工具cargo</a></li></ol></li><li><a href="hello-some/index.html"><strong aria-hidden="true">7.</strong> 软件篋some_exerci</a></li><li><ol class="section"><li><a href="hello-some/about.html"><strong aria-hidden="true">7.1.</strong> 关于软件篋some_exerci</a></li><li><a href="hello-some/stack_head.html"><strong aria-hidden="true">7.2.</strong> 应用篋：栈（Stack）和堆（Head）</a></li><li><a href="hello-some/develop.html"><strong aria-hidden="true">7.3.</strong> 开发软件篋some_exerci</a></li><li><a href="hello-some/apply.html"><strong aria-hidden="true">7.4.</strong> 使用软件篋some_exerci</a></li><li><a href="hello-borrowing/bin-lib.html"><strong aria-hidden="true">7.5.</strong> 题外话：应用篋的软件包结构</a></li><li><a href="hello-some/cargo-features.html"><strong aria-hidden="true">7.6.</strong> 题外话：Cargo工具features功能</a></li></ol></li><li><a href="hello-macro/index.html"><strong aria-hidden="true">8.</strong> 软件篋macro_exerci</a></li><li><ol class="section"><li><a href="hello-macro/about.html"><strong aria-hidden="true">8.1.</strong> 关于软件篋macro_exerci</a></li><li><a href="hello-macro/develop.html"><strong aria-hidden="true">8.2.</strong> 开发软件篋macro_exerci</a></li><li><a href="hello-macro/apply.html"><strong aria-hidden="true">8.3.</strong> 使用软件篋macro_exerci</a></li></ol></li><li><a href="hello-generics/index.html"><strong aria-hidden="true">9.</strong> 软件篋generics_exerci</a></li><li><ol class="section"><li><a href="hello-generics/about.html"><strong aria-hidden="true">9.1.</strong> 关于软件篋generics_exerci</a></li><li><a href="hello-generics/develop.html"><strong aria-hidden="true">9.2.</strong> 开发软件篋generics_exerci</a></li><li><a href="hello-generics/apply.html"><strong aria-hidden="true">9.3.</strong> 使用软件篋generics_exerci</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">以软件篋学习Rust语言</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><em>mdbook version 0.3.4</em> <a href="https://crates.io/crates/mdbook"><img src="https://img.shields.io/crates/v/mdbook.svg" alt="crates.io" /></a>
<a href="https://github.com/rust-lang/rust"><img src="https://img.shields.io/badge/rustc-1.38+-brightgreen" alt="Minimum rustc version" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-borrowing"><img src="https://img.shields.io/appveyor/ci/cnruby/learn-rust-by-crates?label=build%20on%20appveyor.com" alt="Build Status on appveyor.com" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/issues"><img src="https://img.shields.io/github/issues/cnruby/learn-rust-by-crates" alt="GitHub issues" /></a>
<a href="https://mobile.twitter.com/cnruby"><img src="https://img.shields.io/twitter/url?style=social&amp;url=https%3A%2F%2Fmobile.twitter.com%2Fcnruby" alt="Twitter URL" /></a></p>
<blockquote>
<p>$$\text{只有分享知识，才能延续生命}$$</p>
</blockquote>
<h1><a class="header" href="#前言" id="前言">前言</a></h1>
<h2><a class="header" href="#rust语言" id="rust语言">Rust语言</a></h2>
<p>　　Rust是一门可靠高效、保证内存安全、支持安全并发和似C语言同级速度的计算机编程语言。</p>
<h2><a class="header" href="#rustup版本管理工具" id="rustup版本管理工具">rustup版本管理工具</a></h2>
<p>　　rustup是Rust语言官方的版本管理工具，负责安装Rust语言及其版本管理。通过rustup工具实现了Rust语言安装工作。</p>
<h2><a class="header" href="#cargo包管理器" id="cargo包管理器">Cargo包管理器</a></h2>
<p>　　Cargo是一款Rust语言官方的包管理器和开发工具，负责Rust软件篋的依赖管理，并且能够下载、开发、编译、生成和分发的软件篋。一旦安装了Rust语言，该工具也自动完成了安装。</p>
<h2><a class="header" href="#crateio" id="crateio">Crate.io</a></h2>
<p>　　Crate.io是Rust语言软件篋的官方仓库，负责软件篋登记、托管和存储等功能服务。</p>
<h2><a class="header" href="#rust语言编程方法" id="rust语言编程方法">Rust语言编程方法</a></h2>
<p>　　Rust语言是一门多编程（multi-programming）方法的或者说多范式（multi-paradigm）系统编程语言，它包括了：</p>
<ul>
<li>面向对象式编程</li>
<li>命令式编程</li>
<li>函数式编程</li>
<li>声明式编程</li>
<li>响应式编程</li>
<li>...</li>
</ul>
<h2><a class="header" href="#关于本书内容" id="关于本书内容">关于本书内容</a></h2>
<p>　　以开发软件篋过程，学习和理解Rust语言的全新设计思路及其重要概念。</p>
<h2><a class="header" href="#关于本书读者" id="关于本书读者">关于本书读者</a></h2>
<p>　　本书面向的读者是，致在了解Rust语言概念和设计思想，同时也学习具体程序开发的方法。</p>
<h2><a class="header" href="#关于本书使用系统说明" id="关于本书使用系统说明">关于本书使用系统说明</a></h2>
<p>　　本书程序代码使用苹果电脑系统开发的。大部分终端命令也应用适用于其它操作系统。</p>
<h2><a class="header" href="#rust语言重要网站" id="rust语言重要网站">Rust语言重要网站</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/">Rust官方网站</a></li>
<li><a href="https://rustup.rs/">rustup官方网站</a></li>
<li><a href="https://github.com/rust-lang/cargo">Cargo项目源代码</a></li>
<li><a href="https://crates.io/">Crates.io官方网站</a></li>
</ul>
<h2><a class="header" href="#rust语言入门在线图书" id="rust语言入门在线图书">Rust语言入门在线图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/">官方网站: The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">官方网站: Rust by Example</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/index.html">Learning Rust With Entirely Too Many Linked Lists</a></li>
</ul>
<h2><a class="header" href="#rust语言在线图书" id="rust语言在线图书">Rust语言在线图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/">官方网站: The Rustonomicon</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html#a-gentle-introduction-to-rust">A Gentle Introduction To Rust</a></li>
<li><a href="https://zsiciarz.github.io/24daysofrust/index.html">24 days of Rust</a></li>
<li><a href="https://www.ralfj.de/projects/rust-101/main.html">Rust-101</a></li>
</ul>
<h2><a class="header" href="#rust语言开发参考图书" id="rust语言开发参考图书">Rust语言开发参考图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/index.html">官方网站: The Rust Standard Library</a></li>
<li><a href="https://doc.rust-lang.org/reference/">官方网站: The Rust Reference</a></li>
</ul>
<h2><a class="header" href="#重要工具网站" id="重要工具网站">重要工具网站</a></h2>
<ul>
<li><a href="https://www.tablesgenerator.com/">Tables Generator</a></li>
<li><a href="https://markdown-it.github.io/">markdown-it demo</a></li>
<li><a href="https://www.compart.com/de/unicode/category/So">Liste der Unicode-Zeichen der Kategorie „Sonstiges Symbol“</a></li>
<li><a href="https://sketch.io/sketchpad/">Sketchpad - Draw, Create, Share!</a></li>
<li><a href="https://shields.io/">Quality metadata badges</a></li>
<li><a href="https://www.appveyor.com/">Continuous Integration and Deployment service for Windows and Linux | AppVeyor</a></li>
<li><a href="https://github.com/nushell/nushell">Nu Shell</a></li>
<li><a href="https://markdown.de/">Markdown: Syntax</a></li>
<li><a href="https://crates.io/category_slugs">category_slugs from crates.io</a></li>
<li><a href="https://is.gd">Compress That Address</a></li>
<li><a href="https://gist.github.com/rust-play">The Rust Playground Codes</a></li>
<li><a href="https://doc.rust-lang.org/stable/error-index.html">stable error-index</a></li>
<li><a href="https://daringfireball.net/projects/markdown/basics">markdown basics</a></li>
<li><a href="https://lib.rs/">Lib.rs — home for Rust crates</a></li>
</ul>
<h1><a class="header" href="#本书项目结构" id="本书项目结构">本书项目结构</a></h1>
<h2><a class="header" href="#篇目" id="篇目">篇目</a></h2>
<ol>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%92%8C%E7%AF%8B">作业区和篋</a></li>
<li><a href="foreword/about.html#%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">共享篋和应用程序</a></li>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">作业区命名法则</a></li>
<li><a href="foreword/about.html#%E7%AF%8B%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">篋命名法则</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：项目类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：篋类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E4%BD%9C%E4%B8%9A%E5%8C%BA%E6%89%80%E6%9C%89%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">实例：作业区所有目录文件清单</a></li>
<li><a href="foreword/about.html#%E6%9C%AC%E4%B9%A6%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">本书使用符号说明</a></li>
<li><a href="foreword/about.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#作业区和篋" id="作业区和篋">作业区和篋</a></h2>
<p>　　Cargo项目是Cargo工具所生成的目录和文件内容，称之为软件篋，或者简称为篋。</p>
<p>　　软件篋项目是由若干个Cargo项目或者说软件篋组成，在本书里，软件篋项目也简称为作业区（workspace）、整体项目或者项目。所有Cargo项目都是在作业区目录之下，且这些项目在相同目录层上。所有项目名称也是目录名称。每一章最顶层目录是作业区目录。</p>
<h2><a class="header" href="#共享篋和应用程序" id="共享篋和应用程序">共享篋和应用程序</a></h2>
<p>　　每一个软件篋源代码存在于一个Cargo项目里。</p>
<p>　　把Cargo项目软件篋（library package）发布到网站crates.io的共享软件篋，简称共享篋。</p>
<p>　　除了这个共享软件篋的Cargo项目外，还有一个使用本地共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为本地程序。其目的是在发布共享篋之前，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<p>　　另外，一个使用仓库crates.io里共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为仓库程序。其目的是在发布共享软件篋之后，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<h2><a class="header" href="#作业区命名法则" id="作业区命名法则">作业区命名法则</a></h2>
<p>　　作业区目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#篋命名法则" id="篋命名法则">篋命名法则</a></h2>
<p>　　按照Rust语言命名法则，共享软件篋名称使用小蛇式命名（lower snake case）。</p>
<p>　　可执行程序。其目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#实例项目类型清单" id="实例项目类型清单">实例：项目类型清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例篋类型清单" id="实例篋类型清单">实例：篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例作业区所有目录文件清单" id="实例作业区所有目录文件清单">实例：作业区所有目录文件清单</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── hello.rs
    └── lib-hello
        ├── Cargo.lock
        ├── Cargo.toml
        ├── Cargo.txt
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   └── lib.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.r
</code></pre>
<h2><a class="header" href="#本书使用符号说明" id="本书使用符号说明">本书使用符号说明</a></h2>
<table><thead><tr><th>符号</th><th>英文单词</th><th>说明</th><th>要求</th><th>实例</th></tr></thead><tbody>
<tr><td>Ⓓ</td><td>default</td><td>叙述Rust语言默认情况</td><td>必须记住</td><td>Ⓓ 所有模块和函数默认情况下都是私有的。</td></tr>
<tr><td>ⓡ</td><td>regulation</td><td>阐述Rust语言规则</td><td>必须记住</td><td>ⓡ 所有字符串文字类型都是引用，且具有静态生命周期。</td></tr>
<tr><td>Ⓒ</td><td>consensus</td><td>解释约定而非强制方法</td><td>最好记住</td><td>Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</td></tr>
<tr><td>Ⓘ</td><td>idea</td><td>必须记住</td><td>计算机技术和Rust语言基本概念</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于作业区和软件篋crate实例" id="关于作业区和软件篋crate实例">关于作业区和软件篋（Crate）实例</a></h1>
<p>　　软件篋（Crate）是其他语言的库（library）或包（package）的同义词。软件篋可以生成这里称之为应用程序的可执行文件或共享库，</p>
<h2><a class="header" href="#实例创建作业区空间" id="实例创建作业区空间">实例：创建作业区空间</a></h2>
<pre><code class="language-bash"># 创建一个工作空间
mkdir workpsaces &amp;&amp; cd workpsaces
</code></pre>
<h2><a class="header" href="#实例创建作业区" id="实例创建作业区">实例：创建作业区</a></h2>
<pre><code class="language-bash"># 创建一个作业区hello-world
mkdir hello-world &amp;&amp; cd hello-world
# 创建一个作业区配置文件
touch Cargo.toml
# 作业区存在四个软件篋
# 注意：下面两行代码是一行命令
echo '[workspace]
members = [&quot;lib-hello&quot;, &quot;bin-hello&quot;, &quot;bin-local-hello&quot;, &quot;lib-extern&quot;]' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#实例创建默认共享软件篋程序命令" id="实例创建默认共享软件篋程序命令">实例：创建默认共享软件篋程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;crate-project-name&gt;
# 命令实例，如创建名称为lib-hello的共享篋程序项目目录
mkdir lib-hello
# 进入软件篋程序根目录
cd lib-hello
# 命令说明：
# cargo init --name &lt;crate_name&gt; --lib
# 命令实例，如创建名称为hello_exercism的软件篋程序
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#实例创建默认可执行的应用程序命令" id="实例创建默认可执行的应用程序命令">实例：创建默认可执行的应用程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;app-project-name&gt;
# 命令实例，如创建名称为bin-hello的应用程序项目目录
mkdir bin-hello
# 进入应用程序根目录
cd bin-hello
# 命令说明
# cargo init --name &lt;app-name&gt; --bin
# 命令实例，如创建名称为bin-hello的应用程序
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#实例说明共享软件篋结构" id="实例说明共享软件篋结构">实例：说明共享软件篋结构</a></h2>
<p>　　使用软件工具Cargo，在默认Cargo项目基础上，这里除了增加了默认说明文件README.md外，还有增加了两个Cargo默认目录：tests和examples，同时在两个目录下增加了两个rust程序文件，其结果如下：</p>
<pre><code>── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   └── hello.rs
    ├── src
    │   └── lib.rs
    └── tests
        └── hello.rs
</code></pre>
<p>　　在上面的结构里，除了两个文件hello.rs之外，其他都是Cargo项目的默认目录和文件。这些目录和文件都是与Cargo工具默认命令相关的。Cargo项目还有其他默认目录和文件。目录src下的默认文件lib.rs是共享篋的入口文件。</p>
<h2><a class="header" href="#参考资料" id="参考资料">参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html">a4.cargo,crates_and_basic_project_structure</a></li>
</ul>
<h1><a class="header" href="#关于cargo工具基础命令" id="关于cargo工具基础命令">关于Cargo工具基础命令</a></h1>
<p>　　安装Rust语言软件篋存在两个行为，其目的和作用是不同的。使用软件工具rustup安装的软件篋是支持版本管理工具，而使用软件工具Cargo安装的软件篋是支持项目级开发环境。</p>
<h2><a class="header" href="#编写规范格式代码工具-rustfmt" id="编写规范格式代码工具-rustfmt">编写规范格式代码工具 Rustfmt</a></h2>
<h3><a class="header" href="#安装rustfmt命令" id="安装rustfmt命令">安装Rustfmt命令</a></h3>
<pre><code>rustup self update
rustup component add rustfmt
</code></pre>
<h3><a class="header" href="#使用rustfmt命令" id="使用rustfmt命令">使用Rustfmt命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo fmt
</code></pre>
<h2><a class="header" href="#编写有效代码工具-clippy" id="编写有效代码工具-clippy">编写有效代码工具 Clippy</a></h2>
<h3><a class="header" href="#安装clippy命令" id="安装clippy命令">安装Clippy命令</a></h3>
<pre><code>rustup self update
rustup component add clippy
</code></pre>
<h3><a class="header" href="#使用clippy命令" id="使用clippy命令">使用Clippy命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo clippy
</code></pre>
<h2><a class="header" href="#说明cargo软件篋开发命令" id="说明cargo软件篋开发命令">说明Cargo软件篋开发命令</a></h2>
<p>　　除了上面两个开发工具命令之外，Cargo项目还有自身命令：</p>
<h3><a class="header" href="#测试代码运行命令" id="测试代码运行命令">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目和作业区 --
# 进来Cargo项目根目录
# 默认测试命令
# 说明：测试在目录tests下的所有测试文件
cargo test
</code></pre>
<h3><a class="header" href="#运行应用程序命令" id="运行应用程序命令">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目 --
# 进来Cargo项目根目录
# 命令说明：
# cargo run --example &lt;程序文件名称&gt;
# 命令实例，如运行在目录examples下文件名称为hello.rs的应用程序
cargo run --example hello
</code></pre>
<h3><a class="header" href="#运行应用程序命令-1" id="运行应用程序命令-1">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 仅适用于Cargo应用程序项目 --
# 进来Cargo项目根目录
# 默认运行命令
# 说明：运行目录src下默认入口文件main.rs
cargo run
</code></pre>
<h2><a class="header" href="#说明cargo作业区开发命令" id="说明cargo作业区开发命令">说明Cargo作业区开发命令</a></h2>
<h3><a class="header" href="#测试代码运行命令-1" id="测试代码运行命令-1">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区和所有Cargo项目 --
# 进来作业区根目录
# 命令说明：
# cargo test --package &lt;篋名称&gt;
# 或者
# cargo test -p &lt;篋名称&gt;
# 命令实例，如运行在Cargo项目lib-hello下共享篋名称为hello_exercism
cargo test -p hello_exercism
</code></pre>
<h3><a class="header" href="#运行应用程序命令-2" id="运行应用程序命令-2">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区内Cargo应用程序项目 --
# 进来作业区根目录
# 命令说明：
# cargo run --package &lt;篋名称&gt;
# 或者
# cargo run -p &lt;软件篋名称&gt;
# 命令实例，如运行在Cargo项目bin-hello下篋名称为bin-hello
cargo run -p bin-hello
</code></pre>
<p>　　后续还将介绍上面Cargo工具的其他实用命令。</p>
<h1><a class="header" href="#rust语言新思维和新概念" id="rust语言新思维和新概念">Rust语言新思维和新概念</a></h1>
<h2><a class="header" href="#变量生命期" id="变量生命期">变量生命期</a></h2>
<h2><a class="header" href="#不可变量immutable和可变量mutable" id="不可变量immutable和可变量mutable">不可变量(Immutable)和可变量(Mutable)</a></h2>
<h2><a class="header" href="#表达式expression和语句statements" id="表达式expression和语句statements">表达式(Expression)和语句(statements)</a></h2>
<h2><a class="header" href="#方法method和函数function" id="方法method和函数function">方法(method)和函数(function)</a></h2>
<h2><a class="header" href="#类和对象" id="类和对象">类和对象</a></h2>
<h2><a class="header" href="#全局软件篋和项目软件篋" id="全局软件篋和项目软件篋">全局软件篋和项目软件篋</a></h2>
<h2><a class="header" href="#题外话" id="题外话">题外话</a></h2>
<h3><a class="header" href="#工具cargo-play" id="工具cargo-play">工具cargo-play</a></h3>
<ul>
<li>https://journal.zeyi.fan/2019/08/20/announce-cargo-play.html</li>
</ul>
<p><a href="https://crates.io/crates/hello_exercism"><img src="https://img.shields.io/crates/v/hello_exercism?label=hello_exercism" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world"><img src="https://img.shields.io/badge/hello--world-code-yellowgreen" alt="The Crate hello_exercism Code" /></a></p>
<h1><a class="header" href="#关于软件篋项目hello-world" id="关于软件篋项目hello-world">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#项目目标" id="项目目标">项目目标</a></h2>
<p>　　学习和理解如何开发Rust语言的软件篋基本思路和方法，同时了解该项目的其他Cargo项目开发过程和方法。</p>
<h2><a class="header" href="#主题内容" id="主题内容">主题内容</a></h2>
<ul>
<li>了解和学习Cargo工具作业区概念</li>
<li>学习和理解共享软件篋整个开发过程</li>
<li>了解和学习单元测试和集成测试基本概念</li>
</ul>
<h2><a class="header" href="#关键词内容" id="关键词内容">关键词内容</a></h2>
<table><thead><tr><th>说明</th><th>关键词</th><th>链接</th></tr></thead><tbody>
<tr><td>实例定义</td><td>let</td><td></td></tr>
<tr><td>公共修饰</td><td>pub</td><td></td></tr>
<tr><td>函数和方法</td><td>fn</td><td></td></tr>
<tr><td>模块定义</td><td>mod</td><td></td></tr>
<tr><td>生命周期修饰</td><td>'</td><td></td></tr>
<tr><td>静态修饰</td><td>static</td><td></td></tr>
<tr><td>模块关联</td><td>super</td><td></td></tr>
<tr><td>无名氏</td><td>_</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#类型内容" id="类型内容">类型内容</a></h2>
<table><thead><tr><th>归类</th><th>数据类型</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>基本数据类型</td><td>&amp;str</td><td>字符串文字</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#宏内容" id="宏内容">宏内容</a></h2>
<table><thead><tr><th>归类</th><th>宏名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库宏</td><td>println!</td><td>打印输出</td><td></td></tr>
<tr><td>标准库宏</td><td>assert_eq!</td><td>相同值测试</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#注释内容" id="注释内容">注释内容</a></h2>
<table><thead><tr><th>归类</th><th>注释名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库注释</td><td>#[test]</td><td>注释测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[cfg(test)]</td><td>注释有条件运行测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[path=&quot;.&quot;]</td><td>注释模块路径</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#命名规范" id="命名规范">命名规范</a></h2>
<table><thead><tr><th>命名对象</th><th>命名规范</th><th>实例</th><th>链接</th></tr></thead><tbody>
<tr><td>共享软件箧</td><td>小蛇式命名</td><td>hello_exercism</td><td></td></tr>
<tr><td>程序软件箧</td><td>小蛇式命名或短横线命名</td><td>bin-hello</td><td></td></tr>
<tr><td>函数和方法</td><td>小蛇式命名</td><td>it_works_at_private()</td><td></td></tr>
<tr><td>模块</td><td>小蛇式命名</td><td>owned_hello</td><td></td></tr>
<tr><td>变量</td><td>小蛇式命名</td><td>_</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于软件篋项目hello-world-1" id="关于软件篋项目hello-world-1">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#学习内容" id="学习内容">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
<li>了解项目目录和文件结构</li>
</ul>
<h2><a class="header" href="#篇目-1" id="篇目-1">篇目</a></h2>
<ol>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-world/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%B8%85%E5%8D%95">项目目录清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">项目文件清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A0%91">项目结构树</a></li>
<li><a href="hello-world/about.html#%E9%A2%98%E5%A4%96%E8%AF%9D%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%91%BD%E4%BB%A4">题外话：目录与命令</a></li>
</ol>
<h2><a class="header" href="#项目名称清单" id="项目名称清单">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
<tr><td>共享篋</td><td>lib-extern</td><td>./hello-world/lib-extern</td><td>作为第三方共享篋实例使用</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单" id="软件篋类型清单">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
<tr><td>共享软件篋</td><td>hello_extern</td><td>./hello-world/lib-extern</td></tr>
</tbody></table>
<h2><a class="header" href="#项目目录清单" id="项目目录清单">项目目录清单</a></h2>
<table><thead><tr><th>目录名称</th><th>根目录说明</th><th>生成方式</th></tr></thead><tbody>
<tr><td>src</td><td>篋源代码目录</td><td>Cargo命令</td></tr>
<tr><td>src/integration_tests</td><td>篋源代码集成测试目录</td><td>用户手动命令</td></tr>
<tr><td>src/private_tests</td><td>篋源代码私有代码测试目录</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>篋测试源代码目录</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>篋实例源代码目录</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>篋构建目录</td><td>Cargo命令</td></tr>
<tr><td>debug</td><td>篋调试构建目录</td><td>Cargo命令</td></tr>
<tr><td>release</td><td>篋版本构建目录</td><td>Cargo命令</td></tr>
</tbody></table>
<h2><a class="header" href="#项目文件清单" id="项目文件清单">项目文件清单</a></h2>
<table><thead><tr><th>名称</th><th>说明</th><th>内容属性</th><th>名称属性</th></tr></thead><tbody>
<tr><td>README.md</td><td>项目说明文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.lock</td><td>项目配置锁定文件</td><td>不可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.toml</td><td>项目配置锁定文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>main.rs</td><td>可执行软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>lib.rs</td><td>共享软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>mod.rs</td><td>篋模块的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>i_hello.rs</td><td>集成测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>u_hello.rs</td><td>单元测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>owned_hello.rs</td><td>私有代码测试文件</td><td>可修改</td><td>可修改</td></tr>
</tbody></table>
<h2><a class="header" href="#项目结构树" id="项目结构树">项目结构树</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── i_hello.rs
    ├── lib-extern
    │   ├── Cargo.toml
    │   ├── README.md
    │   ├── src
    │   │   └── lib.rs
    │   └── tests
    │       └── u_hello.rs
    └── lib-hello
        ├── Cargo.toml
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   ├── integration_tests
        │   │   ├── i_hello.rs
        │   │   └── mod.rs
        │   ├── lib.rs
        │   └── private_tests
        │       ├── mod.rs
        │       └── owned_hello.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.rs
</code></pre>
<h2><a class="header" href="#题外话目录与命令" id="题外话目录与命令">题外话：目录与命令</a></h2>
<table><thead><tr><th>目录名称</th><th>生成命令</th><th>删除命令</th></tr></thead><tbody>
<tr><td>src</td><td>cargo new &lt;project_name&gt; <br/> cargo new &lt;project_name&gt; --lib <br/> cargo new &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; <br/> cargo init --name &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; --lib</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>随下面命令自动生成</td><td>cargo clean</td></tr>
<tr><td>debug</td><td>cargo build 或者 cargo run</td><td>cargo clean --target-dir target/debug</td></tr>
<tr><td>release</td><td>cargo build --release <br/> cargo run --release</td><td>cargo clean --release <br/> cargo clean --target-dir target/release</td></tr>
</tbody></table>
<h1><a class="header" href="#共享篋开发命令" id="共享篋开发命令">共享篋：开发命令</a></h1>
<h2><a class="header" href="#学习内容-1" id="学习内容-1">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用共享篋项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-2" id="篇目-2">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-lib.html#%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%AF%8B%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建共享篋项目命令</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和单元测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和集成测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">执行共享篋和测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">执行共享篋的实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E6%96%87%E6%A1%A3">开发共享篋文档</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">发布共享篋准备工作</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B">发布共享篋</a></li>
</ol>
<h2><a class="header" href="#创建共享篋项目命令" id="创建共享篋项目命令">创建共享篋项目命令</a></h2>
<pre><code class="language-bash"># 创建共享篋项目命令
# 先进入作业区根目录，且创建项目目录，然后进入共享篋根目录
mkdir lib-hello &amp;&amp; cd lib-hello
# 创建名称为hello_exercism的共享篋
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#开发共享篋和单元测试代码" id="开发共享篋和单元测试代码">开发共享篋和单元测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和单元测试代码
vi Cargo.toml
vi src/lib.rs
mkdir tests
touch tests/u_hello.rs
vi tests/u_hello.rs
touch tests/i_hello.rs
vi tests/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码" id="开发共享篋的单元实例代码">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码-1" id="开发共享篋的单元实例代码-1">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋和集成测试代码" id="开发共享篋和集成测试代码">开发共享篋和集成测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和集成测试代码
echo 'i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}' &gt;&gt; Cargo.toml
touch tests/i_hello.rs
vi tests/i_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#执行共享篋和测试代码" id="执行共享篋和测试代码">执行共享篋和测试代码</a></h2>
<pre><code class="language-bash"># 执行共享篋和测试代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo test
</code></pre>
<h2><a class="header" href="#执行共享篋的实例代码" id="执行共享篋的实例代码">执行共享篋的实例代码</a></h2>
<pre><code class="language-bash"># 执行共享篋的实例代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo run --example u_hello
cargo run --example i_hello
</code></pre>
<h2><a class="header" href="#开发共享篋文档" id="开发共享篋文档">开发共享篋文档</a></h2>
<pre><code class="language-bash"># 开发共享篋文档
mkdir -p ../../docs/hello-world
cargo doc
cp -rf ../target/doc/. ../../docs/hello-world/.
</code></pre>
<h2><a class="header" href="#发布共享篋准备工作" id="发布共享篋准备工作">发布共享篋准备工作</a></h2>
<pre><code class="language-bash"># 发布共享篋准备工作
# 注册网站crates.io帐号
# 登录网站crates.io
# 从网站crates.io获取token，如下所示
# 在本地电脑运行下面命令
cargo login &lt;token&gt;
</code></pre>
<p><img src="hello-world/../../images/crates_io_api_access_new_token.png" alt="image" />
<img src="hello-world/../../images/crates_io_api_access_create.png" alt="image" /></p>
<h2><a class="header" href="#发布共享篋" id="发布共享篋">发布共享篋</a></h2>
<pre><code class="language-bash">## 提交代码
cargo package
cargo publish
</code></pre>
<h1><a class="header" href="#共享软件篋hello_exercism程序代码解释" id="共享软件篋hello_exercism程序代码解释">共享软件篋hello_exercism：程序代码解释</a></h1>
<p>　　共享软件篋本身只能提供给其他共享篋和应用程序使用。Cargo工具实现了项目内所有目录和文件有机联系在一起。当运行测试代码或者实例代码时，这些代码都知道应该怎么样连接到正在开发的共享篋。</p>
<h2><a class="header" href="#学习内容-2" id="学习内容-2">学习内容</a></h2>
<ul>
<li>阐述共享篋文件功能</li>
<li>理解项目共享篋程序代码</li>
</ul>
<h2><a class="header" href="#篇目-3" id="篇目-3">篇目</a></h2>
<ol>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/lib.html#%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6librs%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">程序文件lib.rs的核心代码</a></li>
<li><a href="hello-world/lib.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B">静态生命周期的字符串文字类型</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dmod%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8Dpub">关键词mod与关键词pub</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的单元实例文件</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E9%9B%86%E6%88%90%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的集成实例文件</a></li>
<li><a href="hello-world/lib.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-world/lib.html#rust%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8D">Rust语言类型与关键词</a></li>
<li><a href="hello-world/lib.html#%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9A%84%E6%A8%A1%E5%9D%97">浅谈软件篋的模块</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dlet">关键词let</a></li>
<li><a href="hello-world/lib.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A8%A1%E5%9D%97">表达式、语句和模块</a></li>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">项目配置文件</a></li>
<li><a href="hello-world/lib.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml" id="项目配置文件cargotoml">项目配置文件Cargo.toml</a></h2>
<p>　　文件Cargo.toml是由用户编写的描述项目共享篋依赖关系。而文件Cargo.lock包含有关共享软件篋的依赖项的确切信息。它是由Cargo工具自动生成和维护的，不应手动对其进行编辑。</p>
<pre><code class="language-toml"># Crate Configuration File: ./Cargo.toml
[package]
name = &quot;hello_exercism&quot;
version = &quot;0.5.5&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
repository = &quot;https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world&quot;
homepage = &quot;https://crates.io/crates/hello_exercism&quot;
documentation = &quot;https://cnruby.github.io/learn-rust-by-crates/hello-world/hello_exercism/&quot;
categories = [&quot;development-tools::testing&quot;]
description = &quot;how to create an own crate&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#hello_extern = { version = &quot;0.1.1&quot;}
i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}

</code></pre>
<p>　　在文件Cargo.toml里，最重要的一项是共享软件篋名称：name。这是使用该共享篋的入口名称。这里默认模块名称为hello_exercism。</p>
<p>　　最常用的一节是共享篋依赖关系：[dependencies]。这里有一行依赖关系代码，说明共享篋有赖于外部共享篋。这里使用了软件篋hello_exercism的已经发布的版本，只是为了解释问题和说明方便，实际上可以依赖所有需要的共享篋。</p>
<h2><a class="header" href="#程序文件librs的核心代码" id="程序文件librs的核心代码">程序文件lib.rs的核心代码</a></h2>
<p>　　程序文件lib.rs是由三部分代码。第一部分是共享篋核心代码：两个函数hello()和hallo()。第二部分是私有代码测试函数。第三部分是集成测试函数。这里仅仅说明该程序两个函数的功能，将在后面章节说明其它两个部分的测试代码。</p>
<p>　　程序文件lib.rs是共享篋的入口文件。它有两个函数hello()和hallo()，其功能都是返回一个字符串文字。hello()返回英文问候，而hallo()返回德文问候。它们返回的类型也都是&amp;'static str的字符串，这一类型是静态生命周期的字符串文字。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#静态生命周期的字符串文字类型" id="静态生命周期的字符串文字类型">静态生命周期的字符串文字类型</a></h2>
<p>　　程序文件lib.rs里，两个函数的返回类型都是：静态生命周期的字符串文字类型。</p>
<p>　　ⓡ 所有字符串文字类型都是引用，且具有静态生命周期的功能。</p>
<p>　　↳ 这里的函数返回值是包含一个引用字符串文字类型值，所以函数返回类型也要此类型<code>&amp;str</code>。因为在整个程序过程中需要该类型是有效的，所以此类型还要增加静态生命周期<code>'static</code>修饰关键词。</p>
<h2><a class="header" href="#关键词mod与关键词pub" id="关键词mod与关键词pub">关键词mod与关键词pub</a></h2>
<p>　　Ⓓ 在默认情况下，无论使用关键词mod定义的模块，还使用关键词fn定义的函数，它们都是私有的。要使得它们可公开访问的话，就需要使用修饰词关键词'pub'。</p>
<p>　　↳ 程序文件lib.rs里，hello()是公共可访问的函数，而hallo()只是模块hello_exercism内可访问的私有函数。该软件篋的公共接口只有：函数hello()。</p>
<p>　　Ⓓ 共享篋模块默认是公开的。</p>
<p>　　↳ 这里共享篋模块名称是hello_exercism，尽管既没有关键词mod也没有关键词pub出现，但是Rust语言已经给了该模块名称这两个关键词。</p>
<h2><a class="header" href="#实例目录的单元实例文件" id="实例目录的单元实例文件">实例目录的单元实例文件</a></h2>
<p>　　单元实例仅仅测试此软件篋自身的功能。</p>
<p>　　ⓡ 凡是存在main()函数的Rust程序都是可执行的。</p>
<p>　　这个程序的功能是调用了该项目的软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。</p>
<p>　　Ⓓ 在运行实例目录下可执行文件时，Cargo工具自动会调用程序lib.rs。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/u_hello.rs
fn main() {
    println!(&quot;{}&quot;, hello_exercism::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example u_hello -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#实例目录的集成实例文件" id="实例目录的集成实例文件">实例目录的集成实例文件</a></h2>
<p>　　集成实例测试此共享篋与外部其它共享篋的功能。</p>
<p>　　这个程序的功能是调用了外部软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。此外，还比较了正在开发的软件篋与外部软件篋的函数返回值。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/i_hello.rs
fn main() {
    println!(&quot;{}&quot;, i_crate::hello());
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example i_hello -q
Hello, World!
Hallo, Welt!
</code></pre>
<h2><a class="header" href="#题外话-1" id="题外话-1">题外话</a></h2>
<h3><a class="header" href="#rust语言类型与关键词" id="rust语言类型与关键词">Rust语言类型与关键词</a></h3>
<p>　　对于修饰词关键词'static'，Rust语言以与常量类似的方式提供了类似“全局变量”的功能。对每一个值只有一个实例，并且位于内存中的固定位置。</p>
<p>　　在Rust语言里，存在一类关键词是修饰词关键词，如关键词&quot;pub&quot;和“static”。</p>
<table><thead><tr><th>类型</th><th>关键词</th><th>类型说明</th></tr></thead><tbody>
<tr><td>&amp;str</td><td></td><td>字符串文字</td></tr>
<tr><td></td><td>static</td><td>静态修饰词关键词</td></tr>
<tr><td></td><td>'</td><td>生命周期关键词</td></tr>
<tr><td></td><td>'static</td><td>静态生命周期关键词</td></tr>
<tr><td>&amp;'static str</td><td></td><td>静态生命周期字符串文字</td></tr>
</tbody></table>
<h3><a class="header" href="#浅谈软件篋的模块" id="浅谈软件篋的模块">浅谈软件篋的模块</a></h3>
<p>　　每一个共享篋都有自己的入口模块名称，这里是hello_exercism，使用共享篋都要从这个名称开始，这里模块hello_exercism有自己的函数hello()。在程序文件lib.rs内还，可以使用关键词mod再定义模块名称，但是它们都是hello_exercism的子模块。</p>
<h3><a class="header" href="#关键词let" id="关键词let">关键词let</a></h3>
<p>　　从作用意义上，共享篋的函数hello()类似于使用关键词let语句，即可把它看作为一个类型为&amp;str的字符串文字与一个变量绑定，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">// Rust File: examples/main.rs
fn main() {
    let _: &amp;'static str = &quot;Hello, World!&quot;;
    let _: &amp;str = &quot;Hello, World!&quot;;
}

</code></pre></pre>
<h3><a class="header" href="#表达式语句和模块" id="表达式语句和模块">表达式、语句和模块</a></h3>
<p>　　在Rust语言里，表达式和语句都可以作为一行代码。要是一行代码，最后没有分号就是表达式，而有分号就是语句。表达式只有作为函数的返回值。</p>
<p>　　表达式和语句可以汇聚成一个由{}内的代码块和由关键词fn开始的函数与方法。函数和方法可以组成一个由关键词mod开始的模块。若干个模块可以形成由关键词mod开始的父模块。</p>
<h3><a class="header" href="#项目配置文件" id="项目配置文件">项目配置文件</a></h3>
<p>　　除了项目配置文件Cargo.toml之外，还可以有其它功能的配置文件，如工具rustfmt的配置文件。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://blog.csdn.net/s_lisheng/article/details/79287713">Rust中的const和static</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying-dependencies</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录tests的测试代码解释" id="共享篋hello_exercism目录tests的测试代码解释">共享篋hello_exercism：目录tests的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-3" id="学习内容-3">学习内容</a></h2>
<ul>
<li>理解开发共享篋的测试代码</li>
<li>了解公共接口的单元测试方法</li>
<li>了解目录tests的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-4" id="篇目-4">篇目</a></h2>
<ol>
<li><a href="hello-world/lib-tests.html#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6u_hellors">公共接口的单元测试文件u_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试与公共接口的单元测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">基于目录tests的集成测试文件i_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%9F%BA%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试与基于测试目录tests的集成测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#公共接口的单元测试文件u_hellors" id="公共接口的单元测试文件u_hellors">公共接口的单元测试文件u_hello.rs</a></h2>
<p>　　在下面的单元测试程序里，只有一个测试函数，其功能是判断函数hello()返回值与字符串文字“Hello, World!”是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/u_hello.rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works_at_uint() {
        assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
    }
}
</code></pre></pre>
<h2><a class="header" href="#单元测试与公共接口的单元测试" id="单元测试与公共接口的单元测试">单元测试与公共接口的单元测试</a></h2>
<p>　　Ⓘ 单元测试（Unit tests）是单个模块或者说单个软件篋的单独测试。</p>
<p>　　一般情况下，单元测试很小且可以测试私有代码。它们的目的是软件篋每一个功能能否正常工作。Rust语言将单元测试分成两类：这里探讨公共接口的单元测试和下面将要说明的私有代码的单元测试。</p>
<p>　　ⓡ 从模块范围之外只能访问模块的公共接口，而不能访问模块的私有内容。</p>
<p>　　Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</p>
<p>　　ⓡ 每一个单元测试函数带有'#[test]'注解标记。测试文件名称命名是由用户自己确定的。</p>
<p>　　每个测试函数都是单独地调用正在开发的共享软件篋进行运行的。因此Cargo工具将共享软件篋纳入到每个测试函数的范围里。</p>
<p>　　Ⓓ 所有公共接口的单元测试文件存储于默认测试目录tests下。</p>
<h2><a class="header" href="#基于目录tests的集成测试文件i_hellors" id="基于目录tests的集成测试文件i_hellors">基于目录tests的集成测试文件i_hello.rs</a></h2>
<p>　　在下面的集成测试程序里，有两个测试函数，第一个函数功能是判断外部共享篋的函数hello()返回值与字符串文字“Hello, World!”是否完全一致。第二个函数功能是判断正在开发共享篋与外部共享篋的函数hello()返回值是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/i_hello.rs
#[test]
fn it_works_with_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试与基于测试目录tests的集成测试" id="集成测试与基于测试目录tests的集成测试">集成测试与基于测试目录tests的集成测试</a></h2>
<p>　　Ⓘ 集成测试（Integration tests）是与外部的多个共享篋的测试。它们比较大，但仅测试正在开发共享篋的公共接口。它们的目的是与其它篋能否正常协同工作。</p>
<p>　　集成测试可以存储于这里探讨的基于测试目录tests，也可以存储于下面将要解释的基于共享篋目录src。但是它们处理代码的方式是完全不同的。</p>
<p>　　Ⓒ 集成测试不需要使用注释'#[cfg(test)]'来注释任何测试代码。</p>
<p>　　ⓡ 每一个单元测试函数注解带有'#[test]'标记。</p>
<p>　　ⓡ 在默认情况下，集成测试文件存储于测试目录tests下。</p>
<h2><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录src的测试代码解释" id="共享篋hello_exercism目录src的测试代码解释">共享篋hello_exercism：目录src的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-4" id="学习内容-4">学习内容</a></h2>
<ul>
<li>了解共享篋目录src下的测试代码结构</li>
<li>了解私有代码的单元测试方法</li>
<li>了解目录src下的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-5" id="篇目-5">篇目</a></h2>
<ol>
<li><a href="hello-world/src-tests.html#%E7%9B%AE%E5%BD%95src%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">目录src测试代码结构</a></li>
<li><a href="hello-world/src-tests.html#%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6modrs">默认模块文件mod.rs</a></li>
<li><a href="hello-world/src-tests.html#%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">私有代码的单元测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95src%E5%86%85%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">基于目录src内的集成测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#目录src测试代码结构" id="目录src测试代码结构">目录src测试代码结构</a></h2>
<pre><code class="language-bash">$ tree ./src -L 3
./src
├── integration_tests
│   ├── i_hello.rs
│   └── mod.rs
├── lib.rs
└── private_tests
    ├── mod.rs
    └── owned_hello.rs
</code></pre>
<h2><a class="header" href="#默认模块文件modrs" id="默认模块文件modrs">默认模块文件mod.rs</a></h2>
<p>　　Ⓓ 从目录src开始，Cargo项目共享篋程序目录名称就是模块名称。目录src就是共享篋模块名称，其模块文件就是lib.rs。</p>
<p>　　如：这里共享篋名称hello_exercism就是模块名称</p>
<p>　　Ⓓ 所有目录src的子目录也是模块名称，其模块文件就是mod.rs。</p>
<p>　　如，目录private_tests就是模块hello_exercism的子模块。</p>
<p>　　Ⓓ 除了lib.rs和mod.rs文件以外，所有其它文件名称也就是模块名称，且其文件名称就是模块名称。</p>
<p>　　如，文件i_hello.rs就是一个模块，其模块名称为i_hello。</p>
<h2><a class="header" href="#私有代码的单元测试" id="私有代码的单元测试">私有代码的单元测试</a></h2>
<p>　　↳ 所有私有函数的单元测试代码必须在其相关的程序文件内。</p>
<p>　　Cargo项目私有代码的单元测试思路：单元测试与共享篋程序代码是融为一体的。所以测试代码都是在私有代码相关的可访问模块里，是不可分开的。</p>
<h2><a class="header" href="#程序文件srclibrs与私有代码的单元测试" id="程序文件srclibrs与私有代码的单元测试">程序文件src/lib.rs与私有代码的单元测试</a></h2>
<p>　　为了测试共享篋程序文件src/lib.rs的私有函数hallo()，需要将测试代码存放在该文件的可访问模块里，或者分离到另外若干个文件里。</p>
<p>　　这里说明程序文件src/lib.rs的第二部分私有代码的单元测试代码，有四段单元测试代码，它们是为三个不同模块：hello_exercism::private_tests::owned_hello、hello_exercism::private_tests_with_use和hello_exercism::private_tests_without_use，而每一个模块都有一个单元测试函数，其测试目的和代码含义都是完全一样的，只是代码形式不一样。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
#[cfg(test)]
#[path = &quot;./private_tests/owned_hello.rs&quot;]
mod owned_hello;

// code 2
#[cfg(test)]
#[path = &quot;./private_tests/mod.rs&quot;]
mod private_tests;

// code 3
#[cfg(test)]
mod private_tests_with_use {
    use super::*;
    //use super::hallo;

    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
#[cfg(test)]
mod private_tests_without_use {
    #[test]
    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
#[cfg(test)]
#[path = &quot;./integration_tests/i_hello.rs&quot;]
mod i_hello;

#[cfg(test)]
#[path = &quot;./integration_tests/mod.rs&quot;]
mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#多文件结构的私有代码的单元测试" id="多文件结构的私有代码的单元测试">多文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的单元测试文件或者说模块。分离文件'src/private_tests/owned_hello.rs'如下所示里。它们的第二行说明其下一行模块的位置。</p>
<p>　　Ⓓ 因为第二段代码的访问模块方式是默认方式，所以第二行代码可以省略。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/owned_hello.rs
use super::*;
//use super::hallo;

#[test]
fn it_works_at_private() {
    assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
}
</code></pre></pre>
<p>　　在程序文件mod.rs和owned_hello.rs里，第一行代码都是需要访问其父模块的所有函数。因为从模块owned_hello出发，需要访问其上两层模块，所以两个模块里都需要使用super语句。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/mod.rs
use super::*;
mod owned_hello;
</code></pre></pre>
<h2><a class="header" href="#单一文件结构的私有代码的单元测试" id="单一文件结构的私有代码的单元测试">单一文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第三段代码和第四段代码方法是把测试代码存放在可访问私有代码的模块里。它们仅仅是否使用了关键词use不同而已。</p>
<p>　　第三段代码的第三行说明该模块hello_exercism::private_tests_with_use需要访问其父模块hello_exercism的所有函数。</p>
<p>　　第四段代码里super也是说明了需要使用期父模块的函数hallo()。</p>
<h2><a class="header" href="#基于目录src内的集成测试" id="基于目录src内的集成测试">基于目录src内的集成测试</a></h2>
<p>　　基于共享篋目录src内的集成测试，与私有代码的单元测试思路有类似性，其测试代码也都是在模块程序代码里，但是有本质上区别，它仅仅使用了共享篋模块结构属性，而非共享篋的原代码，因此它是只能访问共享篋的公共接口。</p>
<p>　　这里说明程序文件src/lib.rs的第三部分集成测试代码，存在两段测试代码。第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的集成测试文件或者说模块。代码原理与前面私有代码的单元测试是完全一样的。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/mod.rs
mod i_hello;
</code></pre></pre>
<p>　　不同代码的是，程序文件mod.rs和集成测试文件i_hello.rs。程序文件mod.rs没有super相关语句，只是说明了使用i_hello模块。集成测试文件i_hello.rs也是不一样的，也没有super相关语句，而是引用了一行使用自己模块的语句，且把自己也称之为模块hello_exercism，这个模块名称可以随意自己命名。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/i_hello.rs
use crate as hello_exercism;

#[test]
fn it_works_with_only_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

#[test]
fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#本地程序开发命令" id="本地程序开发命令">本地程序：开发命令</a></h1>
<h2><a class="header" href="#学习内容-5" id="学习内容-5">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用本地程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-6" id="篇目-6">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-local.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
</ol>
<h2><a class="header" href="#创建项目命令" id="创建项目命令">创建项目命令</a></h2>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入本地程序项目根目录
mkdir bin-local-hello &amp;&amp; cd bin-local-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-local-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件" id="修改项目配置文件">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
echo 'hello_exercism = { path = &quot;../lib-hello&quot;}' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码" id="开发主程序文件代码">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
vi src/main.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件" id="运行主程序文件">运行主程序文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
cargo run
</code></pre>
<h1><a class="header" href="#子项目本地程序项目bin-local-hello" id="子项目本地程序项目bin-local-hello">子项目：本地程序项目bin-local-hello</a></h1>
<p>　　在共享篋hello_exercism发布以前，Cargo项目本地程序可以以独立的Cargo项目使用该共享篋，且开发应用和检查代码。</p>
<h2><a class="header" href="#学习内容-6" id="学习内容-6">学习内容</a></h2>
<ul>
<li>阐述项目本地程序开发方法</li>
<li>理解项目本地程序代码</li>
</ul>
<h2><a class="header" href="#篇目-7" id="篇目-7">篇目</a></h2>
<ol>
<li><a href="hello-world/bin-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">修改项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">开发主程序文件main.rs</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行主程序及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行测试代码及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#修改项目配置文件cargotoml" id="修改项目配置文件cargotoml">修改项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了共享篋源代码所处的位置。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-local-hello&quot;
version = &quot;0.1.0&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
hello_exercism = { path = &quot;../lib-hello&quot;}
</code></pre>
<h2><a class="header" href="#开发主程序文件mainrs" id="开发主程序文件mainrs">开发主程序文件main.rs</a></h2>
<p>　　主程序文件main.rs与前面代码非常类似，但是这个程序的执行命令与以前是不一样的，并且代码文件结构形式也是不一样的，程序代码和测试代码存在于一个文件里。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

#[test]
fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
</code></pre></pre>
<h2><a class="header" href="#运行主程序及其结果" id="运行主程序及其结果">运行主程序及其结果</a></h2>
<pre><code class="language-bash"># 运行主程序及其结果
$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#运行测试代码及其结果" id="运行测试代码及其结果">运行测试代码及其结果</a></h2>
<pre><code class="language-bash"># 运行测试代码及其结果
$ cargo test -q

running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/33025887/how-to-use-a-local-unpublished-crate">how-to-use-a-local-unpublished-crate</a></li>
</ul>
<h1><a class="header" href="#仓库程序开发命令" id="仓库程序开发命令">仓库程序：开发命令</a></h1>
<p>　　只有发布了自己共享软件篋以后，才能开发这个项目。</p>
<h2><a class="header" href="#学习内容-7" id="学习内容-7">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用仓库程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-8" id="篇目-8">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-bin.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-bin.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%AE%89%E8%A3%85%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F">安装仓库程序于本地系统</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E5%AE%89%E8%A3%85%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">运行安装于本地系统的仓库程序</a></li>
<li><a href="hello-world/commands-bin.html#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">删除本地系统的仓库程序</a></li>
</ol>
<h2><a class="header" href="#创建项目命令-1" id="创建项目命令-1">创建项目命令</a></h2>
<pre><code class="language-bash"># 创建项目命令
# 先进入作业区根目录，且创建项目目录，然后进入仓库程序项目根目录
mkdir bin-hello &amp;&amp; cd bin-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件-1" id="修改项目配置文件-1">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 修改项目配置文件
# 进入仓库程序项目根目录
echo 'hello_exercism = &quot;0.4.1&quot;' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码-1" id="开发主程序文件代码-1">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 开发主程序文件代码
# 进入仓库程序项目根目录
rm src/main.rs
mkdir -p src/bin
touch src/bin/hello.rs
vi src/bin/hello.rs
touch src/bin/hallo.rs
vi src/bin/hallo.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件-1" id="运行主程序文件-1">运行主程序文件</a></h2>
<pre><code class="language-bash"># 运行主程序文件
# 进入仓库程序项目根目录
cargo run --bin hello
cargo run --bin hallo
</code></pre>
<h2><a class="header" href="#安装仓库程序于本地系统" id="安装仓库程序于本地系统">安装仓库程序于本地系统</a></h2>
<pre><code class="language-bash"># 安装仓库程序于本地系统
# 进入仓库程序项目根目录
# 所有Cargo软件篋都安装于目录~/.cargo/bin/
ls ~/.cargo/bin/
cargo install --path .
ls ~/.cargo/bin/
</code></pre>
<h2><a class="header" href="#运行安装于本地系统的仓库程序" id="运行安装于本地系统的仓库程序">运行安装于本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 运行安装于本地系统的仓库程序
# 可以在本地系统任何目录下运行下面命令
hello
hallo
</code></pre>
<h2><a class="header" href="#删除本地系统的仓库程序" id="删除本地系统的仓库程序">删除本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 删除本地系统的仓库程序
# 进入仓库程序项目根目录
ls ~/.cargo/bin/
# cargo uninstall &lt;来自于Cargo.toml里的仓库程序名称&gt;
cargo uninstall bin-hello
ls ~/.cargo/bin/
</code></pre>
<h1><a class="header" href="#子项目仓库程序项目bin-hello" id="子项目仓库程序项目bin-hello">子项目：仓库程序项目bin-hello</a></h1>
<p>　　在共享篋hello_exercism发布以后，Cargo项目仓库程序可以以独立的Cargo项目使用共享篋，且开发应用和检查代码。一般情况下。用户使用共享篋是以这种项目形式出现的。</p>
<p>　　这个仓库程序项目介绍了一种方法，在一个可执行的软件篋里，存在多个独立的可执行程序。</p>
<h2><a class="header" href="#学习内容-8" id="学习内容-8">学习内容</a></h2>
<ul>
<li>阐述项目仓库程序开发方法</li>
<li>理解项目仓库程序代码</li>
</ul>
<h2><a class="header" href="#篇目-9" id="篇目-9">篇目</a></h2>
<ol>
<li><a href="hello-world/bin.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin.html#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">主程序文件main.rs</a></li>
<li><a href="hello-world/bin.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">集成测试文件i_hello.rs</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml-1" id="项目配置文件cargotoml-1">项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了所使用的共享篋，包括共享篋名称和版本号。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-hello&quot;
version = &quot;0.5.3&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# https://crates.io/crates/hello_exercism
# change the follow version to current version
hello_exercism = &quot;0.5.3&quot;
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhellors" id="主程序文件srcbinhellors">主程序文件src/bin/hello.rs</a></h2>
<p>　　下面主程序文件main.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

</code></pre></pre>
<p>　　执行上面程序的命令及其结果，如下所示：</p>
<pre><code class="language-bash">$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhallors" id="主程序文件srcbinhallors">主程序文件src/bin/hallo.rs</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试文件i_hellors" id="集成测试文件i_hellors">集成测试文件i_hello.rs</a></h2>
<p>　　下面的集成测试文件i_hello.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
#}</code></pre></pre>
<h1><a class="header" href="#题外话-2" id="题外话-2">题外话</a></h1>
<h2><a class="header" href="#篇目-10" id="篇目-10">篇目</a></h2>
<ol>
<li><a href="hello-world/off-topic.html#cargo%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4">Cargo工具命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9B%AE%E5%BD%95examples%E4%B8%8B%E6%96%87%E4%BB%B6">构建和运行软件篋目录examples下文件</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4">Cargo项目构建命令</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4">Cargo项目测试特定代码命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98">思考问题</a></li>
<li><a href="hello-world/off-topic.html#%E7%B1%BB%E5%9E%8Bstr%E5%92%8Cstatic-str%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8Duse%E5%92%8Cextern%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">使用关键词use和extern有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E6%B3%A8%E8%A7%A3cfgtest%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89">注解#[cfg(test)]有什么意义?</a></li>
<li><a href="hello-world/off-topic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#cargo工具命令" id="cargo工具命令">Cargo工具命令</a></h2>
<h3><a class="header" href="#构建和运行软件篋目录examples下文件" id="构建和运行软件篋目录examples下文件">构建和运行软件篋目录examples下文件</a></h3>
<pre><code class="language-bash"># cargo build --example &lt;目录examples下无扩展名的文件名称&gt;
# cargo run --example &lt;目录examples下无扩展名的文件名称&gt;
cargo build --example i_hello
cargo run --example i_hello
</code></pre>
<h3><a class="header" href="#cargo项目构建命令" id="cargo项目构建命令">Cargo项目构建命令</a></h3>
<pre><code class="language-bash">cargo build
cargo build --release
</code></pre>
<h3><a class="header" href="#cargo项目测试特定代码命令" id="cargo项目测试特定代码命令">Cargo项目测试特定代码命令</a></h3>
<pre><code class="language-bash">cargo test tests::it_works_at_uint
cargo test test_hello_world
</code></pre>
<h2><a class="header" href="#思考问题" id="思考问题">思考问题</a></h2>
<h3><a class="header" href="#类型str和static-str有什么区别" id="类型str和static-str有什么区别">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></h3>
<ul>
<li>在语句里，它们是没有任何区别。</li>
<li>在函数返回类型里，它们是有区别的。</li>
</ul>
<h3><a class="header" href="#使用关键词use和extern有什么区别" id="使用关键词use和extern有什么区别">使用关键词use和extern有什么区别？</a></h3>
<ul>
<li>自Rust2018版本以来几乎不再需要extern语句。</li>
<li>关键词use方法与以前相同。</li>
<li>关键词use仅仅是引用标准符号的简写，或者使用trait时必须出现。</li>
</ul>
<h3><a class="header" href="#注解cfgtest有什么意义" id="注解cfgtest有什么意义">注解#[cfg(test)]有什么意义?</a></h3>
<ul>
<li>它告诉编译器在测试环境下进行编译，</li>
<li>仅当使用命令'cargo test'运行测试时，Cargo工具才会编译测试代码。</li>
</ul>
<h2><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/29403920/whats-the-difference-between-use-and-extern">whats-the-difference-between-use-and-extern</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-alpha.2/book/crates-and-modules.html">crates-and-modules</a></li>
<li><a href="https://freyskeyd.fr/cfg-test-and-cargo-test-a-missing-information/">cfg-test-and-cargo-test-a-missing-information</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">ch11-03-test-organization</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://stackoverflow.com/questions/49684657/what-is-the-difference-between-str-and-static-str-in-a-static-or-const">what-is-the-difference-between-str-and-static-str-in-a-static-or-const</a></li>
</ul>
<h2><a class="header" href="#install-macos" id="install-macos">install MacOS</a></h2>
<p>Install Rust
Install Visual Studio Code 
Install VS Code Extensions: Rust (rls)
Install VS Code Extensions: CodeLLDB</p>
<h2><a class="header" href="#use-vscode-on-macos" id="use-vscode-on-macos">use vscode on MacOS</a></h2>
<ul>
<li>select Cargo Project</li>
<li>Menu &gt;&gt; Click Debug -&gt; Add Configuration &gt;&gt; LLDB: Custom Launch &gt;&gt; This should create and open launch.json</li>
<li>Next, you should verify breakpoints are enabled.</li>
<li>F5</li>
</ul>
<h2><a class="header" href="#install-codelldb-comm-to-result" id="install-codelldb-comm-to-result">install CodeLLDB, comm to result</a></h2>
<pre><code>Acquiring platform package for CodeLLDB.
Package is located at https://github.com/vadimcn/vscode-lldb/releases/download/v1.4.0/vscode-lldb-x86_64-darwin.vsix
Downloading...
Downloaded 0%
Downloaded 5%
Downloaded 10%
Downloaded 15%
Downloaded 20%
Downloaded 25%
Downloaded 30%
Downloaded 35%
Downloaded 40%
Downloaded 45%
Downloaded 50%
Downloaded 55%
Downloaded 60%
Downloaded 65%
Downloaded 70%
Downloaded 75%
Downloaded 80%
Downloaded 85%
Downloaded 90%
Downloaded 95%
Downloaded 100%
Installing...
Done.
</code></pre>
<h2><a class="header" href="#use-gdbgui" id="use-gdbgui">use gdbgui</a></h2>
<p>https://github.com/cs01/gdbgui/tree/master/examples/rust
https://www.gdbgui.com/</p>
<h2><a class="header" href="#参考资料-6" id="参考资料-6">参考资料</a></h2>
<ul>
<li><a href="https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/">How to Debug Rust with Visual Studio Code</a></li>
<li><a href="https://lustysociety.org/programming/rust_language/rust-language-linux.html">rust-language-linux</a></li>
<li><a href="https://stackoverflow.com/questions/37586216/step-by-step-interactive-debugger-for-rust">Step by step interactive debugger for Rust?</a></li>
</ul>
<p><a href="https://crates.io/crates/trait_exerci"><img src="https://img.shields.io/crates/v/trait_exerci?label=trait_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-trait"><img src="https://img.shields.io/badge/hello--trait-code-yellowgreen" alt="The Crate trait_exerci Code" /></a></p>
<h1><a class="header" href="#软件篋trait_exerci" id="软件篋trait_exerci">软件篋trait_exerci</a></h1>
<h3><a class="header" href="#本章学习内容" id="本章学习内容">本章学习内容</a></h3>
<ul>
<li>什么是Rust语言衔接关键词trait</li>
<li>为什么需要衔接关键词trait</li>
<li>怎么样实现Rust语言衔接关键词trait</li>
<li>实现关键词impl与衔接关键词trait是什么关系</li>
</ul>
<h3><a class="header" href="#本节篇目" id="本节篇目">本节篇目</a></h3>
<ul>
<li><a href="hello-trait/index.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a>
<ul>
<li><a href="hello-trait/index.html#%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8rust%E8%AF%AD%E8%A8%80nightly%E7%89%88%E6%9C%AC">怎么样使用Rust语言nightly版本</a></li>
<li><a href="hello-trait/index.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
<li><a href="hello-trait/index.html#%E6%9C%AC%E7%AB%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">本章参考资料</a></li>
</ul>
<h2><a class="header" href="#题外话-3" id="题外话-3">题外话</a></h2>
<h3><a class="header" href="#怎么样使用rust语言nightly版本" id="怎么样使用rust语言nightly版本">怎么样使用Rust语言nightly版本</a></h3>
<pre><code class="language-bash">rustc --version
rustup default nightly
rustc --version
rustup default stable
rustup update
rustup show
</code></pre>
<h3><a class="header" href="#参考资料-7" id="参考资料-7">参考资料</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rustup.rs/issues/451">Setting &quot;rustup default nightly&quot; and back to stable ends up</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/55571">Toolchain 'nightly-x86_64-apple-darwin' missing</a></li>
</ul>
<h2><a class="header" href="#本章参考资料" id="本章参考资料">本章参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">Impls &amp; Traits</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">Traits from 'rust-by-example'</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/traits.html">Traits from 'The Rust Programming Language'</a></li>
<li><a href="https://doc.rust-lang.org/beta/book/ch10-02-traits.html">Traits: Defining Shared Behavior</a></li>
</ul>
<h1><a class="header" href="#类型关键词struct" id="类型关键词struct">类型关键词<code>struct</code></a></h1>
<p>　　通过了解和学习本节Rust语言的基本概念，可以实现本章需要开发的共享软件篋程序代码。</p>
<h2><a class="header" href="#学习内容-9" id="学习内容-9">学习内容</a></h2>
<ul>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>定义形式</li>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>实例化方式</li>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>调用手段</li>
</ul>
<h2><a class="header" href="#篇目-11" id="篇目-11">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-struct.html#%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E6%98%AF%E4%BB%80%E4%B9%88">类型关键词<code>struct</code>是什么</a></li>
<li><a href="hello-trait/examples-struct.html#C%E8%AF%AD%E8%A8%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E4%BB%A3%E7%A0%81">C语言形式的类型关键词<code>struct</code>代码</a></li>
<li><a href="hello-trait/examples-struct.html#%E5%85%83%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct">元组形式的类型关键词<code>struct</code></a></li>
<li><a href="hello-trait/examples-struct.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#类型关键词struct是什么" id="类型关键词struct是什么">类型关键词<code>struct</code>是什么</a></h2>
<p>　　类型关键词struct提供定义一种结构性的类型方式。这种类型的定义分析如下：</p>
<table><thead><tr><th>名称</th><th>事物描述</th><th>Rust语言描述</th></tr></thead><tbody>
<tr><td>结构性事物</td><td>类别</td><td>struct</td></tr>
<tr><td>事物名称</td><td>人</td><td>Person</td></tr>
<tr><td>事物属性</td><td>姓名，年龄</td><td>name: string, age:u32</td></tr>
</tbody></table>
<p><img src="hello-trait/../../images/hello-trait-11-struct.png" alt="image" /></p>
<p>　　从上图所示，可以理解到，结构类型关键词struct将一组不同的数据类型作为整体在一起分析和处理。</p>
<p>　　同时还可以看到，在Rust语言里，结构类型关键词struct可以将这种结构性事物以两种不同的表达形式进行定义。它们分别称之为：C语言形式和元组形式。图上左边的C语言形式是以哈希结构表达的类型，而图上右边的元组形式是以数组结构表达的类型。</p>
<h2><a class="header" href="#类型关键词struct的私有性" id="类型关键词struct的私有性">类型关键词<code>struct</code>的私有性</a></h2>
<p>　　Rust语言规定，Ⓓ 默认情况下，关键词struct定义的类型及其属性都是私有的，默认实例代码如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    name: String,
    age: u32,
}
#}</code></pre></pre>
<h2><a class="header" href="#c语言形式的类型关键词struct代码" id="c语言形式的类型关键词struct代码">C语言形式的类型关键词<code>struct</code>代码</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>使用关键词mod，关键词<code>struct</code>定义结构类型的方式。</li>
<li>使用关键词pub，实现关键词<code>struct</code>定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。</li>
<li>结构类型的实例调用结构类型的属性手法。</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct ClikeStructType {
        // data: u32,
        pub data: u32,
    }
}

// cargo run --example pub_field
fn main() {
    let instance = trait_exerci::ClikeStructType { data: 0 };
    let data = instance.data;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#元组形式的类型关键词struct" id="元组形式的类型关键词struct">元组形式的类型关键词<code>struct</code></a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>mod</code>，关键词struct定义结构类型的方式。<br/>ⓡ 注意：元组形式的类型关键词<code>struct</code>定义的类型是以分号结束的，而C语言形式的类型关键词<code>struct</code>代码是没有分号的。</li>
<li>使用关键词<code>pub</code>，实现关键词<code>struct</code>定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。两种形式的类型不同的。</li>
<li>结构类型的实例调用结构类型的属性手法。元组形式的类型是以其属性的顺序号实现调用的，而C语言形式的类型是以其公开性属性实现调用的。</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct TupleStructType (pub u32);
}

// cargo run --example tuple_struct
fn main() {
    let instance = trait_exerci::TupleStructType(0);
    let data = instance.0;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-8" id="参考资料-8">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/structs.html">structs from 'rust-by-example '</a></li>
</ul>
<h1><a class="header" href="#关键词impl与方法代码实现" id="关键词impl与方法代码实现">关键词<code>impl</code>与方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-10" id="学习内容-10">学习内容</a></h2>
<ul>
<li>阐述关键词<code>impl</code>基本概念</li>
<li>理解关键词<code>impl</code>实现代码的方式</li>
</ul>
<h2><a class="header" href="#篇目-12" id="篇目-12">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-impl.html#%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E6%A6%82%E5%BF%B5">关键词<code>impl</code>概念</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl">实现功能关键词<code>impl</code></a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">实现功能关键词<code>impl</code>与函数代码实现</a></li>
<li><a href="hello-trait/examples-impl.html#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl">程序结构图与功能关键词impl</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#关键词impl概念" id="关键词impl概念">关键词impl概念</a></h2>
<p>　　关键词<code>impl</code>是为类型实现结构类型或者其它一些类型的不同行为功能。这里仅仅说明了直接针对结构类型本身的不同行为实现方式。</p>
<p><img src="hello-trait/../../images/hello-trait-12-impl.png" alt="image" /></p>
<h2><a class="header" href="#实现功能关键词impl" id="实现功能关键词impl">实现功能关键词impl</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>Ⓓ 关键词<code>impl</code>始终是公开的，且不可增加修饰关键词<code>pub</code>；</li>
<li>Ⓓ 关键词<code>impl</code>实现的函数和方法默认都是私有的，且可增加修饰关键词<code>pub</code>。</li>
</ul>
<p>　　默认实例代码如下所示。尽管下面代码已实现了函数<code>new()</code>，但是该函数外部还是不可访问的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#struct Person {
#    name: String,
#    age: u32,
#}

impl Person {
    fn new(name: String, age: u32) -&gt; Person {
        Person {
            name: name,
            age: age,
        }
    }
}
#}</code></pre></pre>
<h2><a class="header" href="#实现功能关键词impl与函数代码实现" id="实现功能关键词impl与函数代码实现">实现功能关键词impl与函数代码实现</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>impl</code>，实现结构类型<code>StructType</code>的实例化函数<code>new()</code>；</li>
<li>使用关键词<code>pub</code>，实现结构类型<code>StructType</code>的函数<code>new()</code>公开性；</li>
<li>实例是一种类型的具体对象；</li>
<li>借助于公开性函数<code>new()</code>，实现该结构类型的实例化方式；</li>
<li>借助于结构类型属性的公开性，实现了实例调用结构类型的属性手法；</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

// cargo run --example function_instance
fn main() {
    let instance = trait_exerci::StructType::new(0);
    println!(&quot;instance.data = {}&quot;, instance.data);

    let instance = trait_exerci::StructType{ data:0, };
    println!(&quot;instance.data = {}&quot;, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#程序结构图与功能关键词impl" id="程序结构图与功能关键词impl">程序结构图与功能关键词impl</a></h2>
<p><img src="hello-trait/../../images/hello-trait-02-only-impl.png" alt="image" /></p>
<h2><a class="header" href="#参考资料-9" id="参考资料-9">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.impl.html">std keyword impl</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html">reference implementations</a></li>
</ul>
<h1><a class="header" href="#函数与方法代码实现" id="函数与方法代码实现">函数与方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-11" id="学习内容-11">学习内容</a></h2>
<ul>
<li>阐述Rust语言函数与方法概念区别</li>
<li>理解实现函数与方法手段</li>
</ul>
<h2><a class="header" href="#篇目-13" id="篇目-13">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-methods.html#%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%85%B3%E9%94%AE%E8%AF%8Dmut%E6%A6%82%E5%BF%B5">修饰实例关键词<code>mut</code>概念</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E6%A6%82%E5%BF%B5">函数与方法概念</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81">实现方法代码</a></li>
<li><a href="hello-trait/examples-methods.html#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A7%81%E6%9C%89%E6%80%A7">结构类型属性的私有性</a></li>
<li><a href="hello-trait/examples-methods.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%9C%A8%E7%BB%88%E7%AB%AF%E9%87%8C%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F">在终端里怎么样使用表格形式</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#修饰实例关键词mut概念" id="修饰实例关键词mut概念">修饰实例关键词<code>mut</code>概念</a></h2>
<p>　　关键词<code>let</code>用来定义实例变量，其值是不可改变的，而在一组关键词<code>let mut</code>也用来定义实例变量，但其值是可改变的。</p>
<p>　　下面具体实际代码，这样执行的话，一切正常，但是去掉注释行，就会出现编译错误。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let instance = 1;
    // instance = 2;
    let mut instance = 1;
    instance = 2;
}
</code></pre></pre>
<h2><a class="header" href="#函数与方法概念" id="函数与方法概念">函数与方法概念</a></h2>
<p>　　在Rust语言里，给予了函数（function）或者更明确地说关联函数（associated function）与方法（method）两个名称不同的概念。</p>
<p>　　<a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">引用</a>：Methods are functions attached to objects，直接翻译：方法是附加到对象的函数（行为功能），可以这么理解，方法是附属于类实例的行为功能。</p>
<p>　　而关联函数是附属于类的功能。在前面一节里，可以看到，实现类的关联函数代码方法及其调用手法。下面通过代码详细说明它们的区别。</p>
<h2><a class="header" href="#实现方法代码" id="实现方法代码">实现方法代码</a></h2>
<p>　　通过下面代码，实现了如下内容：</p>
<ul>
<li>实现结构类型<code>StructType</code>的实例化函数<code>new()</code>；</li>
<li>实现结构类型<code>StructType</code>获取其属性的方法<code>get_data()</code>；</li>
<li>实现结构类型<code>StructType</code>变更其属性的方法<code>set_data()</code>；</li>
<li>实现结构类型<code>StructType</code>的属性<code>data</code>是私有的；</li>
<li>借助于公开性方法<code>get_data()</code>，实现结构类型的属性内容获取手法；</li>
<li>借助于公开性方法<code>set_data()</code>，实现结构类型的属性内容变更手法；</li>
</ul>
<p>　　在Rust语言里，ⓡ 方法的第一个参数使用其本身的引用如<code>&amp;self</code>或者<code>&amp;mut self</code>，且在调用该函数时不需要传递该参数。凡是第一个参数不是引用的就是函数。</p>
<p>　　调用函数如<code>new()</code>是使用类型名称如<code>StructType</code>实现的，其调用函数new()的手法是使用<code>::</code>的形式，而调用函数方法如<code>get_data()</code>是使用类型的实例变量如<code>instance</code>实现的，其调用方法的手法是使用<code>.</code>的形式。</p>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct StructType {
        data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }

        pub fn get_data(&amp;self) -&gt; u32 {
            self.data
        }

        pub fn set_data(&amp;mut self, data: &amp;u32) {
            self.data = *data;
        }
    }
}

// cargo run --example function_methods
fn main() {
    let instance = trait_exerci::StructType::new(0);
    let data = instance.get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;instance data&quot;, data);

    let mut instance = trait_exerci::StructType::new(0);
    instance.set_data(&amp;10);
    let data = instance.get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;mut instance data&quot;, data);

    let data = trait_exerci::StructType::new(20).get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
}
</code></pre></pre>
<h2><a class="header" href="#结构类型属性的私有性" id="结构类型属性的私有性">结构类型属性的私有性</a></h2>
<p>　　结构类型<code>StructType</code>的属性是私有的，所以模块之外是不可访问的，如使用语句<code>instance.data;</code>是不可以的。但是使用方法<code>get_data()</code>可以实现了对该属性的访问。</p>
<p>　　结构类型属性私有性的好处是隐蔽了结构类型的属性。</p>
<h2><a class="header" href="#题外话-4" id="题外话-4">题外话</a></h2>
<h3><a class="header" href="#在终端里怎么样使用表格形式" id="在终端里怎么样使用表格形式">在终端里怎么样使用表格形式</a></h3>
<p>　　下面打印宏<code>println!</code>语句，实现了第一列和第二列占位20个字符的输出。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = 10;
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
#}</code></pre></pre>
<h2><a class="header" href="#参考资料-10" id="参考资料-10">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">rust-by-example methods</a></li>
<li><a href="https://stackoverflow.com/questions/30379341/how-to-print-well-formatted-tables-to-the-console">how-to-print-well-formatted-tables-to-the-console</a></li>
</ul>
<h1><a class="header" href="#衔接关键词trait" id="衔接关键词trait">衔接关键词<code>trait</code></a></h1>
<h2><a class="header" href="#学习内容-12" id="学习内容-12">学习内容</a></h2>
<ul>
<li>阐述衔接类型关键词<code>trait</code>基本概念</li>
</ul>
<h2><a class="header" href="#篇目-14" id="篇目-14">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-trait.html#%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5%E8%A1%A8%E8%BF%B0">关键词trait概念表述</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E5%92%8Cfor%E6%A6%82%E5%BF%B5">关键词<code>impl</code>和<code>for</code>概念</a></li>
<li><a href="hello-trait/examples-trait.html#%E8%A1%94%E6%8E%A5%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5">衔接类型关键词<code>trait</code>概念</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">实现类型关键词<code>trait</code></a></li>
<li><a href="hello-trait/examples-trait.html#%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E4%BB%A3%E7%A0%81">实现关键词<code>trait</code>代码</a></li>
<li><a href="hello-trait/examples-trait.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-trait/../../images/hello-trait-21-oop.png" alt="image" /></p>
<h2><a class="header" href="#关键词trait概念表述" id="关键词trait概念表述">关键词trait概念表述</a></h2>
<p>　　关键词trait概念表述之一：</p>
<p>　　<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">关键词trait</a>是Rust语言的一项功能，可以告诉Rust编译器一种类型必须提供的功能。</p>
<p>　　关键词trait概念表述之二：</p>
<p>　　<a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">关键词trait</a>是为任何未知类型定义方法的集合。</p>
<p>　　关键词trait概念表述之三：</p>
<p>　　<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">关键词trait</a>告诉Rust编译器一种特定的类型具有且可与其他类型共享的功效性质。</p>
<p>　　关键词trait提供了一种类型或者几种类型之间的衔接方式。它应该包含下面内容：</p>
<ul>
<li>存在一种类型或者几种类型</li>
<li>使用关键词trait定义衔接特质名称</li>
<li>使用关键词trait代码块定义默认方法和函数</li>
<li>使用关键词&quot;impl&quot;和&quot;for&quot;组合，实现针对这一种类型或者这几种类型的方法和函数</li>
</ul>
<h2><a class="header" href="#衔接类型关键词trait概念" id="衔接类型关键词trait概念">衔接类型关键词trait概念</a></h2>
<p>　　<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">引用</a></p>
<blockquote>
<p>Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
</blockquote>
<p>　　直接翻译：特质(Trait)定义是一种途径，将方法一部分进行分组在一起，为实现某些目的所需以定义行为。</p>
<p>　　衔接类型关键词<code>trait</code>包含这些信息：</p>
<ul>
<li>衔接类型关键词<code>trait</code>提供了类型的一种通道。</li>
<li>衔接类型关键词<code>trait</code>定义了类型行为功能的一部分，且也可实现行为功能。</li>
<li>这一组或者部分类型的行为功能是为了完成一项特有明确的任务。</li>
<li>单个类型可以使用关键词trait定义多组类型行为功能，来实现不同任务。</li>
</ul>
<h2><a class="header" href="#实现类型关键词trait" id="实现类型关键词trait">实现类型关键词trait</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>关键词<code>trait</code>默认是私有的，但可增加修饰关键词<code>pub</code>；</li>
<li>使用关键词<code>trait</code>可以定义一个称之为特质的一组类型行为功能；</li>
<li>一旦定义了衔接类型特质，其函数和方法都是公共的，且且不可增加修饰关键词<code>pub</code>；</li>
</ul>
<p>　　默认实例代码如下所示。尽管下面代码已定义了函数<code>new()</code>或者实现了默认函数<code>init()</code>，但是该函数外部还是不可访问的，因为该特质是私有的。注意，定义了函数<code>new()</code>是语句，是带分号<code>;</code>，而实现了默认函数<code>init()</code>是表达式，是无分号<code>;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#struct Person {
#    name: String,
#    age: u32,
#}
#
trait TraitPerson {
    fn new(name: String, age: u32) -&gt; Person;
    fn init() -&gt; Person { Person { name: String::new(), age: 0, } }
}
#}</code></pre></pre>
<h2><a class="header" href="#关键词impl和for概念" id="关键词impl和for概念">关键词<code>impl</code>和<code>for</code>概念</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>关键词<code>impl</code>和<code>for</code>默认是公开的；</li>
<li>使用关键词<code>impl</code>和<code>for</code>实现的函数或者方法是不可增加修饰关键词<code>pub</code>；</li>
</ul>
<p>　　默认实例代码如下所示。尽管使用关键词<code>impl</code>和<code>for</code>实现了特质<code>TraitPerson</code>，且其默认是公开的，但是为了使用其功能，其相关的类型<code>Person</code>和特质<code>TraitPerson</code>必须要公开的。</p>
<pre><pre class="playpen"><code class="language-rust">##![allow(dead_code)]
#mod trait_exerci {
#    pub struct Person {
#        name: String,
#        age: u32,
#    }
#
#    pub trait TraitPerson {
#        fn new(name: String, age: u32) -&gt; Person;
#        fn init() -&gt; Person {
#            Person {
#                name: String::new(),
#                age: 0,
#            }
#        }
#    }
#
    impl TraitPerson for Person {
        fn new(name: String, age: u32) -&gt; Person {
            Person {
                name: name,
                age: age,
            }
        }
    }
#}
#
#//use self::trait_exerci::TraitPerson;
#use crate::trait_exerci::TraitPerson;
#
#fn main() {
#    trait_exerci::Person::init();
#    trait_exerci::Person::new(String::from(&quot;Leo&quot;), 24);
#}
</code></pre></pre>
<h2><a class="header" href="#实现关键词trait代码" id="实现关键词trait代码">实现关键词trait代码</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>trait</code>，定义了特质<code>TraitCanal</code>的函数<code>new()</code>；</li>
<li>使用关键词<code>impl</code>和<code>for</code>，基于结构类型<code>StructType</code>，为特质<code>TraitCanal</code>实现了实例化函数<code>new()</code>；</li>
<li>借助于特质<code>TraitCanal</code>，实现该结构类型的实例化方式；</li>
<li>借助于结构类型属性的公开性，实现了实例调用结构类型的属性手法；</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    pub trait TraitCanal {
        fn new(data: u32) -&gt; StructType;
    }

    impl TraitCanal for StructType {
        fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

use self::trait_exerci::TraitCanal;

// cargo run --example trait
fn main() {
    let instance = trait_exerci::StructType::new(0);
    assert_eq!(0, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#题外话-5" id="题外话-5">题外话</a></h2>
<h2><a class="header" href="#参考资料-11" id="参考资料-11">参考资料</a></h2>
<h1><a class="header" href="#特质实现及其对象" id="特质实现及其对象">特质实现及其对象</a></h1>
<h2><a class="header" href="#学习内容-13" id="学习内容-13">学习内容</a></h2>
<ul>
<li>理解衔接类型关键词<code>trait</code>的实现</li>
</ul>
<h2><a class="header" href="#篇目-15" id="篇目-15">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-trait-impl.html#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E4%B8%8E%E8%A1%94%E6%8E%A5%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">程序结构图与衔接类型关键词<code>trait</code></a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E4%BB%A3%E7%A0%81">实现基于默认方法的关键词<code>trait</code>代码</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E7%89%B9%E8%B4%A8%E5%AF%B9%E8%B1%A1%E8%A7%A3%E9%87%8A">特质对象解释</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A1%8D%E7%94%9F%E7%89%B9%E8%B4%A8">什么是可衍生特质</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#程序结构图与衔接类型关键词trait" id="程序结构图与衔接类型关键词trait">程序结构图与衔接类型关键词trait</a></h2>
<p><img src="hello-trait/../../images/hello-trait-03-trait-impl.png" alt="image" /></p>
<h2><a class="header" href="#实现基于默认方法的关键词trait代码" id="实现基于默认方法的关键词trait代码">实现基于默认方法的关键词trait代码</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>trait</code>，定义了特质<code>TraitCanal</code>的默认实例化函数<code>init()</code>；</li>
<li>使用关键词<code>impl</code>和<code>for</code>，基于结构类型<code>StructType</code>，为特质<code>TraitCanal</code>实现了方法<code>new()</code>、get_data()<code>和</code>set_data()`；</li>
<li>借助于特质<code>TraitCanal</code>的默认实例化函数<code>init()</code>，实现该结构类型的实例化方式；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    #[derive(Debug)]
    pub struct StructType {
        pub data: u32,
    }

    pub trait TraitCanal {
        fn new(data: u32) -&gt; StructType;
        fn init() -&gt; StructType { StructType{data:0} }
        fn get_data(&amp;self) -&gt; u32;
        fn set_data(&amp;mut self, data: &amp;u32);
    }

    impl TraitCanal for StructType {
        fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }

        fn get_data(&amp;self) -&gt; u32 {
            self.data
        }

        fn set_data(&amp;mut self, data: &amp;u32) {
            self.data = *data;
        }
    }
}

use self::trait_exerci::TraitCanal;

// cargo run --example trait_with_default_method
fn main() {
    let mut instance = trait_exerci::StructType::new(10);
    instance.set_data(&amp;11);
    println!(&quot;new {:?}&quot;, instance);

    let mut instance = trait_exerci::StructType::init();
    instance.set_data(&amp;12);
    println!(&quot;init {:?}&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#特质对象解释" id="特质对象解释">特质对象解释</a></h2>
<p>　　特质本身不能定义特质对象，而是通过类型的对象，进行强制转换得到的特质对象。特质对象可以访问类型的公共数据和公共特质的行为。</p>
<p>　　Rust语言把面向对象编程的思想更加深化了。把类的数据与行为分散化定义，而把类的实例集成化使用。不仅如此，而且Rust语言在代码里完全把这种过程都隐藏起来了。</p>
<p><img src="hello-trait/../../images/hello-trait-31-trait-object.png" alt="image" /></p>
<h2><a class="header" href="#题外话-6" id="题外话-6">题外话</a></h2>
<h3><a class="header" href="#什么是可衍生特质" id="什么是可衍生特质">什么是可衍生特质</a></h3>
<p>　　Rust语言标准库或者第三方提供了一些非常有用的特质，称之为可衍生特质（Derivable Trait）。通过注释<code>#[derive(特质名称)]</code>，编译器能够为这些特质提供实现。比如，要求类型实现是可打印的，可以使用特质std::fmt::Debug。具体说，使用可衍生特质#[derive(Debug)]，所有类型都可以自动创建地实现std::fmt::Debug。</p>
<p>　　下面的代码里第一行就是注释可衍生特质<code>Debug</code>，为类型<code>Person</code>实现了特质<code>Debug</code>，这些后面的宏<code>println!()</code>就可以使用了这个特质。</p>
<p>　　注意，使用注释<code>#[derive(特质名称)]</code>，必须紧挨着类型定义之上。</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Person {
  name: String,
  age: u32,
}

impl Person {
    fn init() -&gt; Person {
        Person {
            name: String::new(),
            age: 0,
        }
    }
}

fn main() {
    let person = Person::init();
    println!(&quot;{:?}&quot;, person);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-12" id="参考资料-12">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">trait std::fmt::Debug</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">rust-by-example derive</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello/print/print_debug.html">rust-by-example print_debug</a></li>
<li><a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html#appendix-c-derivable-traits">appendix-03-derivable-traits</a></li>
</ul>
<h1><a class="header" href="#题外话标准库默认衔接特质default" id="题外话标准库默认衔接特质default">题外话：标准库默认衔接特质<code>Default</code></a></h1>
<h2><a class="header" href="#学习内容-14" id="学习内容-14">学习内容</a></h2>
<ul>
<li>理解标准库默认衔接特质<code>Default</code></li>
</ul>
<h2><a class="header" href="#篇目-16" id="篇目-16">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-trait-default.html#%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default%E5%8A%9F%E8%83%BD">默认衔接特质<code>Default</code>功能</a></li>
<li><a href="hello-trait/examples-trait-default.html#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default">使用默认衔接特质<code>Default</code></a></li>
<li><a href="hello-trait/examples-trait-default.html#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default">实现自己默认衔接特质<code>Default</code></a></li>
<li><a href="hello-trait/examples-trait-default.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#默认衔接特质default功能" id="默认衔接特质default功能">默认衔接特质<code>Default</code>功能</a></h2>
<p>　　标准库默认衔接特质<code>Default</code>也是一个有用的可衍生特质，为类型提供默认值的特质，也就是为类型提供默认的实例化手法。</p>
<h2><a class="header" href="#使用默认衔接特质default" id="使用默认衔接特质default">使用默认衔接特质<code>Default</code></a></h2>
<p>　　在使用默认衔接特质<code>Default</code>的函数default()定义变量时，必须说明变量类型。</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

mod trait_exerci {
    #[derive(Default, Debug)]
    pub struct StructType {
        pub data: u32,
    }
}

// cargo run --example trait_default
fn main() {
    let instance: trait_exerci::StructType = Default::default();
    println!(&quot;{0: &lt;20} = {1}&quot;, &quot;instance.data&quot;, instance.data);
    println!(&quot;{0: &lt;20} = {1:?}&quot;, &quot;instance&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#实现自己默认衔接特质default" id="实现自己默认衔接特质default">实现自己默认衔接特质<code>Default</code></a></h2>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]``
pub struct Person {
    name: String,
    age: u32,
}

impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;Leo&quot;),
            age: 24,
        }
    }
}

fn main() {
    let instance: Person = Default::default();
    println!(&quot;{:?}&quot;, instance);
    let mut instance = Person { age: 23, ..Default::default() };
    instance.age = 24;
    println!(&quot;{:?}&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-13" id="参考资料-13">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html">std::default::Default</a></li>
</ul>
<h1><a class="header" href="#共享篋程序代码结构" id="共享篋程序代码结构">共享篋：程序代码结构</a></h1>
<p>　　这一节总结前面程序代码结构。</p>
<h2><a class="header" href="#篇目-17" id="篇目-17">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-structure.html#%E7%89%B9%E8%B4%A8%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">特质与类型实现方式结构示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E4%BB%85%E4%BB%85%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">仅仅类型实现方式示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E4%BB%85%E4%BB%85%E7%89%B9%E8%B4%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">仅仅特质实现方式示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E7%89%B9%E8%B4%A8%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E7%A4%BA%E6%84%8F%E5%9B%BE">特质与类型实现比较示意图</a></li>
</ol>
<h1><a class="header" href="#特质与类型实现方式结构示意图" id="特质与类型实现方式结构示意图">特质与类型实现方式结构示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-01.png" alt="image" /></p>
<h1><a class="header" href="#仅仅类型实现方式示意图" id="仅仅类型实现方式示意图">仅仅类型实现方式示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-02-only-impl.png" alt="image" /></p>
<h1><a class="header" href="#仅仅特质实现方式示意图" id="仅仅特质实现方式示意图">仅仅特质实现方式示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-03-trait-impl.png" alt="image" /></p>
<h1><a class="header" href="#特质与类型实现比较示意图" id="特质与类型实现比较示意图">特质与类型实现比较示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-04-all.png" alt="image" /></p>
<h1><a class="header" href="#关于软件篋trait_exerci" id="关于软件篋trait_exerci">关于软件篋<code>trait_exerci</code></a></h1>
<h2><a class="header" href="#学习内容-15" id="学习内容-15">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
</ul>
<h2><a class="header" href="#篇目-18" id="篇目-18">篇目</a></h2>
<ol>
<li><a href="hello-trait/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-trait/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
</ol>
<h2><a class="header" href="#项目名称清单-1" id="项目名称清单-1">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-trait</strong></td><td>./hello-trait</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-trait/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-trait/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-trait/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单-1" id="软件篋类型清单-1">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>trait_exerci</strong></td><td>./hello-trait/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-trait/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-trait/bin-hello</td></tr>
</tbody></table>
<h2><a class="header" href="#共享篋开发命令-1" id="共享篋开发命令-1">共享篋：开发命令</a></h2>
<h2><a class="header" href="#篇目-19" id="篇目-19">篇目</a></h2>
<ul>
<li><a href="hello-trait/commands-lib.html#%e5%88%9b%e5%bb%ba%e5%85%b1%e4%ba%ab%e7%af%8b">创建共享篋</a></li>
<li><a href="hello-trait/commands-lib.html#%e5%88%9b%e5%bb%ba%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">创建应用程序</a></li>
</ul>
<h1><a class="header" href="#创建共享篋" id="创建共享篋">创建共享篋</a></h1>
<pre><code class="language-bash">mkdir lib-hello &amp;&amp; cd lib-hello
cargo init --name trait_exerci --lib
</code></pre>
<h1><a class="header" href="#创建应用程序" id="创建应用程序">创建应用程序</a></h1>
<pre><code class="language-bash">mkdir bin-hello &amp;&amp; cd bin-hello
cargo init --name hello-trait --bin
</code></pre>
<h1><a class="header" href="#共享篋程序代码解释" id="共享篋程序代码解释">共享篋：程序代码解释</a></h1>
<h2><a class="header" href="#学习内容-16" id="学习内容-16">学习内容</a></h2>
<ul>
<li>学习和理解关键词<code>trait</code>开发过程</li>
</ul>
<h2><a class="header" href="#篇目-20" id="篇目-20">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-codes.html#%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">项目共享篋程序结构示意图</a></li>
<li><a href="hello-trait/lib-codes.html#%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A">程序代码解释</a></li>
<li><a href="hello-trait/lib-codes.html#%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E5%92%8Cimpl%E5%85%B3%E7%B3%BB">理解关键词<code>trait</code>和<code>impl</code>关系</a></li>
<li><a href="hello-trait/lib-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/lib-codes.html#%E6%A0%87%E5%87%86%E5%BA%93%E5%B9%B3%E7%AD%89%E6%AF%94%E8%BE%83%E7%89%B9%E8%B4%A8PartialEq">标准库平等比较特质<code>PartialEq</code></a></li>
<li><a href="hello-trait/lib-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#项目共享篋程序结构示意图" id="项目共享篋程序结构示意图">项目共享篋程序结构示意图</a></h2>
<p>　　下面示意图是共享篋<code>trait_exerci</code>程序的结构。该共享篋提供了对外三个衔接通道：两个特质<code>TraitCanal</code>和<code>TraitKanal</code>以及一个类型的自我实现<code>StructType</code>。</p>
<p><img src="hello-trait/../../images/hello-trait-05-complex.png" alt="image" /></p>
<h2><a class="header" href="#程序代码解释" id="程序代码解释">程序代码解释</a></h2>
<p>　　通过下面代码，实现了如下内容：</p>
<ul>
<li>结构类型<code>StructType</code>进行了自我实现；</li>
<li>针对结构类型<code>StructType</code>，定义了两个特质<code>TraitCanal</code>和<code>TraitKanal</code>；</li>
<li>对于结构类型<code>StructType</code>，实现了两个特质<code>TraitCanal</code>和<code>TraitKanal</code>；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug, PartialEq, Default)]
pub struct StructType {
    data: u32,
}

pub trait TraitCanal {
    fn get_data(&amp;self) -&gt; u32;
}

pub trait TraitKanal {
    fn set_data(&amp;mut self, data: &amp;u32);
}

impl TraitCanal for StructType {
    fn get_data(&amp;self) -&gt; u32 {
        self.data
    }
}

impl TraitKanal for StructType {
    fn set_data(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

// impl AllTrait for StructType {
impl StructType {
    pub fn new(data: u32) -&gt; StructType {
        dbg!(&quot;impl StructType: new&quot;);
        StructType { data: data }
    }

    pub fn get_data_for_all(&amp;self) -&gt; u32 {
        self.data
    }

    pub fn set_data_for_all(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

</code></pre></pre>
<p>　　结构类型<code>StructType</code>自我实现，包含了一个函数<code>new()</code>和两个方法<code>get_data_for_all()</code>和<code>set_data_for_all()</code>。</p>
<p>　　针对一个结构类型<code>StructType</code>，定义且实现了两个不同的特质<code>TraitCanal</code>和<code>TraitKanal</code>。特质<code>TraitCanal</code>包含一个方法<code>get_data()</code>，而特质<code>TraitKanal</code>包含一个方法<code>set_data()</code>。</p>
<h2><a class="header" href="#理解关键词trait和impl关系" id="理解关键词trait和impl关系">理解关键词<code>trait</code>和<code>impl</code>关系</a></h2>
<p>　　针对一个结构类型<code>StructType</code>实例，可以存在不同的特质，只要把这些特质在一起使用，这些不同特质实现的函数和方法是可以相通的。</p>
<p>　　任何结构类型<code>StructType</code>的特质实现，都可以使用结构类型<code>StructType</code>自我实现的函数和方法。</p>
<h2><a class="header" href="#题外话-7" id="题外话-7">题外话</a></h2>
<h3><a class="header" href="#标准库平等比较特质partialeq" id="标准库平等比较特质partialeq">标准库平等比较特质<code>PartialEq</code></a></h3>
<p>　　标准库平等比较特质<code>PartialEq</code>，可以比较类型的实例以检查它们是否相等。</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Default, Debug, PartialEq)]
pub struct Person {
    name: String,
    age: u32,
}

fn main() {
    assert_eq!(
        Person::default(),
        Person {
            name: String::new(),
            age: 0
        }
    );
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-14" id="参考资料-14">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">std::cmp::PartialEq</a></li>
<li><a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html?highlight=PartialEq#partialeq-and-eq-for-equality-comparisons">PartialEq#partialeq-and-eq-for-equality-comparisons</a></li>
</ul>
<h1><a class="header" href="#共享篋目录测试代码解释" id="共享篋目录测试代码解释">共享篋：目录测试代码解释</a></h1>
<h2><a class="header" href="#篇目-21" id="篇目-21">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-tests.html#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8BStructType%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">结构类型<code>StructType</code>自我实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E7%89%B9%E8%B4%A8TraitCanal%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">特质<code>TraitCanal</code>实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E7%89%B9%E8%B4%A8TraitKanal%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">特质<code>TraitKanal</code>实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">所有实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">基于模块的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/lib-tests.html#%E6%B5%85%E8%AF%B4%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8BBox">浅说指针类型<code>Box</code></a></li>
<li><a href="hello-trait/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#结构类型structtype自我实现的单元测试代码" id="结构类型structtype自我实现的单元测试代码">结构类型<code>StructType</code>自我实现的单元测试代码</a></h2>
<p>　　下面单元测试仅仅使用了结构类型<code>StructType</code>的自我实现。四个方法分别测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数new();</li>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数default();</li>
<li>使用结构类型<code>StructType</code>自我实现的方法get_data_for_all();</li>
<li>使用结构类型<code>StructType</code>自我实现的方法set_data_for_all();</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;

#[test]
fn it_works_with_new() {
    let instance = StructType::new(10);
    assert_eq!(StructType::new(10), instance);
}

#[test]
fn it_works_with_default() {
    let instance :StructType = Default::default();
    assert_eq!(StructType::new(0), instance);
}

#[test]
fn it_works_with_get() {
    let instance = StructType::new(11);
    assert_eq!(11, instance.get_data_for_all());
    assert_eq!(StructType::new(11), instance);
}

#[test]
fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data_for_all(&amp;12);
    assert_eq!(StructType::new(12), instance);
}

</code></pre></pre>
<h2><a class="header" href="#特质traitcanal实现的单元测试代码" id="特质traitcanal实现的单元测试代码">特质<code>TraitCanal</code>实现的单元测试代码</a></h2>
<p>　　下面单元测试使用了结构类型<code>StructType</code>的自我实现和特质<code>TraitCanal</code>实现。特别需要注意的是，从代码表面上看，第二行语句与后面代码没有任何关系。之所以代码里可以使用方法<code>get_data()</code>，就是因为第二行语句的作用。当我们写下第二行语句时，就应该知道接下来我们将要使用什么函数或／和方法。</p>
<p>　　方法<code>it_works_with_get()</code>测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数<code>new()</code>;</li>
<li>使用特质<code>TraitCanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<p>　　方法<code>it_works_with_default()</code>测试了：</p>
<ul>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数<code>default()</code>;</li>
<li>使用特质<code>TraitCanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitCanal;

#[test]
fn it_works_with_get() {
    let instance = StructType::new(20);
    assert_eq!(20, instance.get_data());
    assert_eq!(StructType::new(20), instance);
}

#[test]
fn it_works_with_default() {
    let instance :StructType = Default::default();
    assert_eq!(0, instance.get_data());
    assert_eq!(StructType::new(0), instance);
}

</code></pre></pre>
<h2><a class="header" href="#特质traitkanal实现的单元测试代码" id="特质traitkanal实现的单元测试代码">特质<code>TraitKanal</code>实现的单元测试代码</a></h2>
<p>　　下面单元测试使用了结构类型<code>StructType</code>的自我实现和特质<code>TraitKanal</code>实现。所以这里没有使用到特质<code>TraitCanal</code>实现。尽管下面代码没有使用特质<code>TraitCanal</code>实现，但是我们使用了标准库平等比较特质<code>PartialEq</code>，实现了代码测试。</p>
<p>　　方法<code>it_works_with_get()</code>测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数<code>new()</code>;</li>
<li>使用特质<code>TraitKanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<p>　　方法<code>it_works_with_default()</code>测试了：</p>
<ul>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数<code>default()</code>;</li>
<li>使用特质<code>TraitKanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitKanal;

#[test]
fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data(&amp;30);
    assert_eq!(StructType::new(30), instance);
}

#[test]
fn it_works_with_default() {
    let mut instance :StructType = Default::default();
    instance.set_data(&amp;30);
    assert_eq!(StructType::new(30), instance);
}

</code></pre></pre>
<h2><a class="header" href="#所有实现的单元测试代码" id="所有实现的单元测试代码">所有实现的单元测试代码</a></h2>
<p>　　下面单元测试程序的所有三个实现。所以最前面三行语句表示使用这三个实现。</p>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitCanal;
use trait_exerci::TraitKanal;

#[test]
fn it_works_with_both_traits_and_new() {
    let mut instance = StructType::new(40);
    instance.set_data(&amp;41);
    assert_eq!(41, instance.get_data());
    assert_eq!(StructType::new(41), instance);
}

#[test]
fn it_works_with_both_traits_and_default() {
    let mut instance :StructType = Default::default();
    instance.set_data(&amp;41);
    assert_eq!(41, instance.get_data());
    assert_eq!(StructType::new(41), instance);
}

</code></pre></pre>
<h2><a class="header" href="#基于模块的单元测试代码" id="基于模块的单元测试代码">基于模块的单元测试代码</a></h2>
<p>　　下面单元测试主要说明在模块下如何进行单元测试。除了定义模块之外，最重要的是，使用三个实现语句必须在模块内。</p>
<pre><pre class="playpen"><code class="language-rust editable">#[cfg(test)]
mod tests {
    use trait_exerci::StructType;
    use trait_exerci::TraitCanal;

    #[test]
    fn it_works_with_new() {
        let instance = StructType::new(50);
        assert_eq!(StructType::new(50), instance);
    }

    #[test]
    fn it_works_with_get() {
        let instance = StructType::new(51);
        assert_eq!(51, instance.get_data());
    }

    #[test]
    fn it_works_with_new_and_box() {
        let instance = Box::new(StructType::new(52));
        assert_eq!(Box::new(StructType::new(52)), instance);
    }

    #[test]
    fn it_works_with_get_and_box() {
        let instance = Box::new(StructType::new(53));
        assert_eq!(53, instance.get_data());
    }

    use trait_exerci::TraitKanal;
    #[test]
    fn it_works_with_set() {
        let mut instance = StructType::new(54);
        instance.set_data(&amp;55);
        assert_eq!(StructType::new(55), instance);
    }

    #[test]
    fn it_works_with_set_and_box() {
        let mut instance = Box::new(StructType::new(56));
        instance.set_data(&amp;57);
        assert_eq!(Box::new(StructType::new(57)), instance);
    }
}

</code></pre></pre>
<h2><a class="header" href="#题外话-8" id="题外话-8">题外话</a></h2>
<h3><a class="header" href="#浅说指针类型box" id="浅说指针类型box">浅说指针类型<code>Box</code></a></h3>
<p>　　Rust标准库提供了类型<code>Box&lt;T&gt;</code>。可以使用该类型<code>Box&lt;T&gt;</code>在堆上分配内容。此类型用于安全地抽象指向堆内存的指针。同时它具有更大的灵活性，允许将实现特质如<code>TraitCanal</code>的任何事物进行<code>Box</code>类型化。</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug, Default)]
pub struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person :Box&lt;Person&gt; = Box::new(Default::default());
    println!(&quot;{:?}&quot;, person);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-15" id="参考资料-15">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/30352802/what-does-the-box-keyword-do">what-does-the-box-keyword-do</a></li>
<li><a href="https://medium.com/@KevinHoffman/to-box-or-not-to-box-my-first-real-rust-refactor-db467119c4c7">To Box or not to Box — My First Real Rust Refactor</a></li>
</ul>
<h1><a class="header" href="#题外话-9" id="题外话-9">题外话</a></h1>
<h2><a class="header" href="#cargo工具第三方插件" id="cargo工具第三方插件">Cargo工具第三方插件</a></h2>
<pre><code class="language-bash"># --------------------------
# install
cargo install cargo-update
# --------------------------
# install
cargo install cargo-audit
# or upgrade with the crate `cargo`
cargo install --force cargo-audit
# or upgrade with the crate `cargo-update`
cargo install-update cargo-audit
# using
cargo audit
# --------------------------
# install
cargo install cargo-bloat
# using
# only 'bin' and 'cdylib' crate types are supported.
cargo bloat --release -n 10
cargo bloat --release --crates
# --------------------------
# install
cargo install cargo-edit
# using
cargo add &lt;CRATE&gt;
cargo rm &lt;CRATE&gt;
cargo upgrade
# --------------------------
# install
cargo install cargo-asm
cargo asm &lt;CRATE_NAME&gt;::&lt;MOD_NAME&gt;::&lt;FUNCTION_NAME&gt;
cargo llvm-ir &lt;CRATE_NAME&gt;::&lt;MOD_NAME&gt;::&lt;FUNCTION_NAME&gt;
</code></pre>
<h2><a class="header" href="#参考资料-16" id="参考资料-16">参考资料</a></h2>
<ul>
<li><a href="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html">Keeping-secure-with-cargo-audit-0.9</a></li>
<li><a href="https://crates.io/crates/cargo-audit">cargo-audit</a></li>
<li><a href="https://crates.io/crates/cargo-update">cargo-update</a></li>
<li><a href="https://crates.io/crates/cargo-edit">cargo-watch</a></li>
<li><a href="https://crates.io/crates/cargo-asm">cargo-asm</a></li>
<li><a href="https://stackoverflow.com/questions/39219961/how-to-get-assembly-output-from-building-with-cargo">how-to-get-assembly-output-from-building-with-cargo</a></li>
</ul>
<p><a href="https://crates.io/crates/mod_trait_exerci"><img src="https://img.shields.io/crates/v/mod_trait_exerci?label=mod_trait_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-mod-trait"><img src="https://img.shields.io/badge/hello--mod--trait-code-yellowgreen" alt="The Crate mod_trait_exerci Code" /></a></p>
<h1><a class="header" href="#软件篋mod_trait_exerci" id="软件篋mod_trait_exerci">软件篋mod_trait_exerci</a></h1>
<h2><a class="header" href="#学习内容-17" id="学习内容-17">学习内容</a></h2>
<ul>
<li>学习软件篋文件、模块与程序结构</li>
<li>了解和学习动态调度关键词<code>dyn</code></li>
<li>学习和理解动态与静态调度（Static vs Dynamic Dispatch）</li>
<li>衔接类型关键词<code>trait</code>作用</li>
</ul>
<h2><a class="header" href="#参考资料-17" id="参考资料-17">参考资料</a></h2>
<ul>
<li><a href="https://archive.fosdem.org/2018/schedule/event/rust_testing_mocking/attachments/slides/2113/export/events/attachments/rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf">rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.dyn.html">std keyword dyn</a></li>
<li><a href="https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/dyn-trait-for-trait-objects.html">dyn-trait-for-trait-objects</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html">a_quick_look_at_trait_objects_in_rust</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5d573e667aac08f960557b79d6385f6e">Code</a></li>
<li><a href="https://stackoverflow.com/questions/27567849/what-makes-something-a-trait-object">what-makes-something-a-trait-object</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic_dispatch</a></li>
<li><a href="https://doc.rust-lang.org/reference/identifiers.html">reference identifiers</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://blog.theenginerd.com/blog/2015/06/27/traits-on-generics/">traits-on-generics</a></li>
<li><a href="https://tutorialedge.net/rust/learning-generics-in-rust/">learning-generics-in-rust</a></li>
<li><a href="https://blog.jcoglan.com/2019/04/22/generic-returns-in-rust/">generic-returns-in-rust</a></li>
<li><a href="https://cprimozic.net/blog/writing-a-hashmap-to-struct-procedural-macro-in-rust/">writing-a-hashmap-to-struct-procedural-macro-in-rust</a></li>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">impls_and_traits</a></li>
</ul>
<h1><a class="header" href="#关于软件篋mod_trait_exerci" id="关于软件篋mod_trait_exerci">关于软件篋mod_trait_exerci</a></h1>
<h2><a class="header" href="#学习内容-18" id="学习内容-18">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
</ul>
<h2><a class="header" href="#篇目-22" id="篇目-22">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-mod-trait/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
<li><a href="hello-mod-trait/about.html#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">项目目录文件结构</a></li>
</ul>
<h2><a class="header" href="#项目名称清单-2" id="项目名称清单-2">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-mod-trait</strong></td><td>./hello-mod-trait</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-mod-trait/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-mod-trait/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-mod-trait/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单-2" id="软件篋类型清单-2">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>mod_trait_exerci</strong></td><td>./hello-mod-trait/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-mod-trait/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-mod-trait/bin-hello</td></tr>
</tbody></table>
<h2><a class="header" href="#项目目录文件结构" id="项目目录文件结构">项目目录文件结构</a></h2>
<pre><code class="language-bash">$ tree -L 3
.
├── Cargo.lock
├── Cargo.toml
├── README.md
├── bin-hello
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   ├── bin
│   │   └── main.rs
│   └── target
│       └── debug
├── bin-local-hello
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── main.rs
│   ├── target
│   │   └── debug
│   └── tests
│       └── type_both_hello.rs
└── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   ├── bare_hello.rs
    │   ├── box_dynamic_hello.rs
    │   ├── box_static_hello.rs
    │   ├── generics_fn_hello.rs
    │   ├── generics_impl_hello.rs
    │   ├── generics_trait_hello.rs
    │   ├── generics_type_hello.rs
    │   ├── simple_dynamic_dispatch.rs
    │   ├── simple_static_dispatch.rs
    │   ├── trait_dispatch_abstract.rs
    │   ├── trait_dispatch_concrete.rs
    │   ├── trait_fn_hello.rs
    │   ├── trait_instance_hello.rs
    │   └── trait_where_hello.rs
    ├── src
    │   ├── lib.rs
    │   ├── mod_bare
    │   ├── mod_dynamic_fn.rs
    │   ├── mod_static_fn.rs
    │   └── mod_where_fn.rs
    └── tests
        ├── box_dynamic_hello.rs
        ├── box_static_hello.rs
        ├── mod_bare.rs
        └── mod_trait.rs
</code></pre>
<h1><a class="header" href="#文件与模块" id="文件与模块">文件与模块</a></h1>
<p>　　在这一节里，学习Cargo项目文件、目录与模块相互关系。Rust语言表达模块的三种方式。</p>
<h2><a class="header" href="#学习内容-19" id="学习内容-19">学习内容</a></h2>
<ul>
<li>了解和学习本软件篋模块文件结构</li>
<li>理解和掌握Cargo项目目录与文件关系</li>
<li>理解和掌握Cargo项目模块与文件关系</li>
<li>理解和掌握Cargo项目文件与文件关系</li>
</ul>
<h2><a class="header" href="#篇目-23" id="篇目-23">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/crate-structure.html#%E6%96%87%E4%BB%B6%E6%9C%AC%E8%BA%AB%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">文件本身表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">文件名称表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">目录名称表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_00_structure.png" alt="image" /></p>
<h2><a class="header" href="#文件本身表达模块方式" id="文件本身表达模块方式">文件本身表达模块方式</a></h2>
<p>　　Ⓓ 使用模块关键词<code>mod</code>和代码块<code>{}</code>的表达式，在Rust语言程序文件里，可以定义任何一个或者多个不同名称的模块。</p>
<p>　　在文件lib.rs里，创建了称之为<code>mod_trait</code>模块，该模块实现代码也在该文件里。</p>
<h2><a class="header" href="#文件名称表达模块方式" id="文件名称表达模块方式">文件名称表达模块方式</a></h2>
<p>　　Ⓓ 使用模块关键词<code>mod</code>语句，在Rust语言程序文件里，可以定义任何一个或者多个不同的模块。</p>
<p>　　使用关键词<code>mod</code>语句，实现模块代码存在两种形式：以文件名称作为模块名称方式和以目录名称为模块名称方式。这里先解释前面一种情况，如程序文件<code>mod_generics.rs</code>。</p>
<p>　　实现以文件名称作为模块名称具体方法是，在文件<code>lib.rs</code>里，使用语句<code>pub mod mod_generics;</code>，且在与文件<code>lib.rs</code>相同的目录下，创建名称为<code>mod_generics.rs</code>模块程序文件，为了其自身模块，该文件不需要使用模块关键词了。</p>
<h2><a class="header" href="#目录名称表达模块方式" id="目录名称表达模块方式">目录名称表达模块方式</a></h2>
<p>　　程序文件<code>mod.rs</code>是第三种表达模块方式，即以目录名称为模块名称方式。</p>
<p>　　在程序文件<code>lib.rs</code>里，使用语句<code>pub mod mod_bare;</code>，说明了该模块是外部文件实现模块代码，但是从中微分确认其实现方式。我们看到在与文件<code>lib.rs</code>相同目录下存在目录<code>mod_bare</code>，说明了该实现在该目录下的文件，默认情况下就是程序文件<code>mod.rs</code>，所有模块目录的入口文件默认情况下都是该文件名称。</p>
<h2><a class="header" href="#参考资料-18" id="参考资料-18">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/48071513/how-to-use-one-module-from-another-module-in-a-rust-cargo-project">how-to-use-one-module-from-another-module-in-a-rust-cargo-project</a></li>
<li><a href="https://dev.to/saiumesh/modules-in-rust-programming-language-495m">modules-in-rust-programming-language</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/4-modules.html">rust-gentle-intro/modules</a></li>
<li><a href="https://doc.rust-lang.org/1.29.2/book/2018-edition/ch07-01-mod-and-the-filesystem.html">ch07-01-mod-and-the-filesystem</a></li>
<li><a href="https://stackoverflow.com/questions/48071513/how-to-use-one-module-from-another-module-in-a-rust-cargo-project">how-to-use-one-module-from-another-module-in-a-rust-cargo-project</a></li>
</ul>
<h1><a class="header" href="#共享篋程序结构和代码解释" id="共享篋程序结构和代码解释">共享篋：程序结构和代码解释</a></h1>
<p>　　在本节里，了解两个模块<code>mod_bare</code>和<code>mod_trait</code>结构和代码实现。</p>
<h2><a class="header" href="#学习内容-20" id="学习内容-20">学习内容</a></h2>
<ul>
<li>了解和学习不同结构类型关键词<code>struct</code>实现方法</li>
</ul>
<h2><a class="header" href="#篇目-24" id="篇目-24">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-codes.html#%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">基于结构类型的实现</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">基于衔接特质的实现</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF">学习理解编译错误</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#基于结构类型的实现" id="基于结构类型的实现">基于结构类型的实现</a></h2>
<h3><a class="header" href="#模块mod_bare结构" id="模块mod_bare结构">模块<code>mod_bare</code>结构</a></h3>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_02_mod_bar.png" alt="image" /></p>
<h3><a class="header" href="#模块mod_bare代码" id="模块mod_bare代码">模块<code>mod_bare</code>代码</a></h3>
<p>https://doc.rust-lang.org/stable/error-index.html#E0038</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug, Default, PartialEq)]
pub struct StructType {
    pub data: (u32),
}

impl StructType {
    pub fn get_tuple(&amp;self) -&gt; (u32) {
        (self.data)
    }
}

#[derive(Debug, Default, PartialEq)]
pub struct TupleType (pub u32);

impl TupleType {
    pub fn get_tuple(&amp;self) -&gt; (u32) {
        (self.0)
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现" id="基于衔接特质的实现">基于衔接特质的实现</a></h2>
<h3><a class="header" href="#模块mod_trait结构" id="模块mod_trait结构">模块<code>mod_trait</code>结构</a></h3>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_01_mod_trait.png" alt="image" /></p>
<h3><a class="header" href="#模块mod_trait代码" id="模块mod_trait代码">模块<code>mod_trait</code>代码</a></h3>
<p>　　两个类型的函数new()是通过属性值，实现创建其类型的实例，而特质方法get_object()是通过其类型本身实例，实现创建一个新的类型实例。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub mod mod_bare;
pub mod mod_where_fn;
pub mod mod_static_fn;
pub mod mod_box_static_fn;
pub mod mod_dynamic_fn;
pub mod mod_box_dynamic_fn;

pub mod mod_trait {
    #[derive(Debug, Default, PartialEq, Copy, Clone)]
    pub struct StructType {
        data: (u32),
    }

    #[derive(Debug, Default, PartialEq, Copy, Clone)]
    pub struct TupleType(pub u32);

    pub trait TraitCanal {
        fn get_object(&amp;self) -&gt; Self where Self: Sized;  // For keyword `dyn`
        //fn get_object(&amp;self) -&gt; Self;                  // E0038 For keyword `dyn`; OK for static functions
        fn get_tuple(&amp;self) -&gt; (u32);
    }

    impl TraitCanal for StructType {
        fn get_object(&amp;self) -&gt; Self {
            StructType{data: self.data}
        }

        fn get_tuple(&amp;self) -&gt; (u32) {
            println!(&quot;impl TraitCanal for StructType&quot;);
            (self.data)
        }
    }

    impl TraitCanal for TupleType {
        fn get_object(&amp;self) -&gt; Self {
            TupleType(self.0)
        }

        fn get_tuple(&amp;self) -&gt; (u32) {
            println!(&quot;impl TraitCanal for TupleType&quot;);
            (self.0)
        }
    }

    impl StructType {
        pub fn new(_data: u32) -&gt; Self {
            StructType{data: _data}
        }
    }

    impl TupleType {
        pub fn new(_data: u32) -&gt; Self {
            TupleType(_data)
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#题外话-10" id="题外话-10">题外话</a></h2>
<h3><a class="header" href="#学习理解编译错误" id="学习理解编译错误">学习理解编译错误</a></h3>
<p>　　在程序文件<code>src/lib.rs</code>里，使用关键词<code>trait</code>定义衔接特质<code>TraitCanal</code>代码块的第一行代码注释掉，而第二行代码去掉注释，一旦执行编译，就会出现下面错误信息：<code>error[E0038]</code>。</p>
<pre><code>error[E0038]: the trait `mod_trait::TraitCanal` cannot be made into
an object
--&gt; lib-hello/src/mod_dynamic_fn.rs:4:1
|
4 | pub fn get_dynamic_trait_ref(canal: &amp;dyn TraitCanal) -&gt; (u32) {
| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ t
he trait `mod_trait::TraitCanal` cannot be made into an object
|
= note: method `init` references the `Self` type in its arguments
or return type
</code></pre>
<p>　　下面链接里的<code>E0038</code>就是该错误编号，点击下面链接就可以了解到错误的原因信息。</p>
<p><a href="https://doc.rust-lang.org/stable/error-index.html#E0038">https://doc.rust-lang.org/stable/error-index.html#E0038</a></p>
<h2><a class="header" href="#参考资料-19" id="参考资料-19">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/error-index.html">Rust Compiler Error Index</a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">std Sized</a></li>
<li><a href="https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait">why-is-the-sized-bound-necessary-in-this-trait</a></li>
</ul>
<h1><a class="header" href="#三种调用方式解释" id="三种调用方式解释">三种调用方式解释</a></h1>
<p>　　在本节里，通过两个模块<code>mod_bare</code>和<code>mod_trait</code>实现及其三种调用方式比较，详细说明衔接关键词<code>trait</code>作用。</p>
<h2><a class="header" href="#学习内容-21" id="学习内容-21">学习内容</a></h2>
<ul>
<li>理解衔接关键词<code>trait</code>的重要性</li>
<li>掌握衔接关键词<code>trait</code>实现的应用方法</li>
</ul>
<h2><a class="header" href="#篇目-25" id="篇目-25">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8">基于结构类型的实现：使用实例调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8">基于衔接特质的实现：使用实例调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E6%A8%A1%E5%9D%97">基于衔接特质的模块</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8">基于衔接特质的实现：作为参数调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%B5%85%E8%AF%B4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B">浅说面向对象编程、命令式编程和声明式编程</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84">数据类型数组</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95">泛型函数与方法</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E7%B1%BB%E5%9E%8B%E8%8C%83%E5%9B%B4%E5%85%B3%E9%94%AE%E8%AF%8Dwhere">类型范围关键词<code>where</code></a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_04_apply_ways.png" alt="image" /></p>
<h2><a class="header" href="#基于结构类型的实现使用实例调用" id="基于结构类型的实现使用实例调用">基于结构类型的实现：使用实例调用</a></h2>
<p>　　从上面图示，可以了解到下面程序文件直接访问模块<code>mod_bare</code>，该模块是基于结构类型的实现，不存在衔接特质。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/bare_hello.rs
use mod_trait_exerci::mod_bare::StructType;
use mod_trait_exerci::mod_bare::TupleType;

fn get_data_from_struct(instances: [StructType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

fn get_data_from_tuple(instances: [TupleType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

// clear &amp;&amp; cargo run --example bare_hello
fn main() {
    let instances: [StructType; 2] = [Default::default(), StructType{data:0}];
    get_data_from_struct(instances);

    let instances: [TupleType; 2] = [Default::default(), TupleType(0)];
    get_data_from_tuple(instances);    
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现使用实例调用" id="基于衔接特质的实现使用实例调用">基于衔接特质的实现：使用实例调用</a></h2>
<p>　　从上面图示，下面程序文件也是直接访问模块<code>mod_trait</code>本身，与上面应用实例不同，这里通过衔接特质方式实现代码，从代码的关键词<code>use</code>语句也可以了解到这一点。</p>
<p>　　比较上面程序文件<code>bare_hello.rs</code>和下面文件<code>trait_instance_hello.rs</code>的关键词<code>use</code>语句，可以看到，上面程序文件里的关键词<code>use</code>语句访问模块，采用了绝对路径方式，而下面文件既有绝对路径方式，也有相对路径方式。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_instance_hello.rs
use mod_trait_exerci::mod_trait;
use mod_trait::TraitCanal;
use mod_trait::StructType;
use mod_trait::TupleType;

fn get_data_from_struct(instances: [StructType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

fn get_data_from_tuple(instances: [TupleType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

// clear &amp;&amp; cargo run --example trait_instance_hello
fn main() {
    let instances: [StructType; 2] = [Default::default(), StructType::new(0)];
    get_data_from_struct(instances);

    let instances: [TupleType; 2] = [Default::default(), TupleType::new(0)];
    get_data_from_tuple(instances);    
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的模块" id="基于衔接特质的模块">基于衔接特质的模块</a></h2>
<p>　　从上面图示，可以了解到，下面程序文件也是一个模块<code>mod_where_fn</code>，该模块应用了模块<code>mod_trait</code>的功能，注意该文件关键词<code>use</code>语句只使用了衔接特质<code>TraitCanal</code>，这也是一种访问其父模块的相对路径方式。它的存在意义是什么？这是为用户提供更加灵活的实现而设计的。这里提供了怎么样使用模块，而不必用户完成实现。</p>
<p>　　下面代码的方法是一种泛型方法的表达方式，其概念参考下面说明。</p>
<p>　　下面将会说明关键词<code>where</code>。在文件<code>mod_where_fn.rs</code>里的两个函数是两个完全相同的实现，只是语法表达方式不同而已。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_where_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32) {
    typ.get_tuple()
}

pub fn get_static_type_ref_with_where&lt;Type&gt;(typ: &amp;Type) -&gt; (u32)
    where Type: TraitCanal {
    typ.get_tuple()
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现作为参数调用" id="基于衔接特质的实现作为参数调用">基于衔接特质的实现：作为参数调用</a></h2>
<p>　　从上面图示，可以了解到下面程序文件并不是直接访问模块<code>mod_trait</code>本身，而是访问中间模块<code>mod_where_fn</code>完成的，这是一种更加方便和灵活的三层程序设计结构。与模块<code>mod_trait</code>不同，它实现的功能更多的是数据操作功能，这里称之为“<code>数据模块</code>”，而这种中间模块<code>mod_where_fn</code>，它提供更多样化的有实际意义知识性功能，这里称之为“<code>知识模块</code>”。</p>
<p>　　无论是什么类型结构，为了获取不同的结构类型属性，都不需要访问其属性名称。</p>
<p>　　在使用模块<code>mod_where_fn</code>的函数时，结构类型的实例是作为参数传递给该模块的函数。我们仅仅告诉它我们是‘谁’，我们需要做什么。</p>
<p>　　模块<code>mod_trait</code>告诉我们是什么功能，这好比是产品生产原料。模块<code>mod_where_fn</code>解决了怎么做问题，这好比是为用户预先打造的特定产品，当然用户也可以自己制造自己需要的产品。这里程序文件说明了要做什么事情，这好比作为用户使用现成的产品。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_where_hello.rs
use mod_trait_exerci::mod_where_fn;
use mod_trait_exerci::mod_trait;
use mod_trait::StructType;
use mod_trait::TupleType;

fn static_struct_ref_with_where(instance: &amp;StructType) {
    let data = mod_where_fn::get_static_type_ref_with_where(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

fn static_tuple_ref_with_where(instance: &amp;TupleType) {
    let data = mod_where_fn::get_static_type_ref_with_where(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

// clear &amp;&amp; cargo run --example trait_where_hello
fn main() {
    let instance: StructType = Default::default();
    static_struct_ref_with_where(&amp;instance);

    let instance: TupleType = Default::default();
    static_tuple_ref_with_where(&amp;instance);
}
</code></pre></pre>
<h2><a class="header" href="#题外话-11" id="题外话-11">题外话</a></h2>
<h3><a class="header" href="#浅说面向对象编程命令式编程和声明式编程" id="浅说面向对象编程命令式编程和声明式编程">浅说面向对象编程、命令式编程和声明式编程</a></h3>
<p>　　面向对象编程回答了是什么，命令式编程回答了怎么做，而声明式编程回答了做什么。</p>
<h3><a class="header" href="#数据类型数组" id="数据类型数组">数据类型数组</a></h3>
<p>　　在Rust语言里，数组是一种基本数据类型。</p>
<h2><a class="header" href="#泛型函数与方法" id="泛型函数与方法">泛型函数与方法</a></h2>
<p>　　在类型理论中，泛型称之为参数多态（parametric polymorphism），对于给定参数（parametric）能够有多种形式（poly是多，morph是形态）的函数或类型。</p>
<p>　　在Rust语言里，泛型是一种非常广泛采用的技术，不仅应用函数与方法关键词<code>fn</code>，也应用衔接特质关键词<code>trait</code>等等。其目的是，减少代码重复。</p>
<h3><a class="header" href="#类型范围关键词where" id="类型范围关键词where">类型范围关键词<code>where</code></a></h3>
<p>　　关键词<code>where</code>用于向泛型类型添加约束，并为编译器提供解决问题所需的信息！</p>
<h2><a class="header" href="#参考资料-20" id="参考资料-20">参考资料</a></h2>
<ul>
<li><a href="https://mgattozzi.github.io/2016/09/13/understanding-where-clauses.html">understanding-where-clauses</a></li>
</ul>
<h1><a class="header" href="#理解动态与静态调度实现" id="理解动态与静态调度实现">理解动态与静态调度实现</a></h1>
<p>　　在这一节里，介绍Rust语言调度动态与静态函数的方式。动态与静态调度函数是计算机语言广泛应用的概念和技术。</p>
<h2><a class="header" href="#学习内容-22" id="学习内容-22">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言静态和动态函数概念</li>
<li>理解和掌握静态和动态函数基本实现</li>
</ul>
<h2><a class="header" href="#篇目-26" id="篇目-26">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/examples-dispatch.html#%E6%9C%80%E5%B8%B8%E8%A7%81%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B">最常见静态函数实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BE%8B">静态函数的动态调度实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B">调用动态函数的实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86%E7%AC%A6%E5%89%8D%E7%BC%80r">原始标识符前缀<code>r#</code></a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BVec">数据类型<code>Vec</code></a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#最常见静态函数实例" id="最常见静态函数实例">最常见静态函数实例</a></h2>
<p>　　Ⓓ 在默认情况下，Rust语言方法都是静态函数。如下面代码的函数<code>static_dispatch()</code>。</p>
<p>　　静态调度或者分派（static dispatch）在编译时就知道被调用方是谁，而动态调度只有在运行时，才知道被调用方是谁。显然，在常见的情况下，相比动态调度，在运行程序时，静态调度会更快速，而相比静态调度，在编译程序时，动态调度会更快速。</p>
<p>　　在使用静态分派会更有效，因为总是可以使用静态分派包装器函数来执行动态调度，但反之则不然。由于这个原因，比如标准库尝试在尽可能的情况下进行静态调度。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/simple_static_dispatch.rs
#[derive(Default)]
struct NormalStruct {
    data: (u8)
}

impl NormalStruct {
    fn static_dispatch(&amp;self) -&gt; (u8) { (self.data) }
}

// clear &amp;&amp; cargo run --example simple_static_dispatch
fn main() {
    let instance_struct :NormalStruct = Default::default();
    assert_eq!((0u8), instance_struct.static_dispatch());
}
</code></pre></pre>
<h2><a class="header" href="#静态函数的动态调度实例" id="静态函数的动态调度实例">静态函数的动态调度实例</a></h2>
<p>　　上面程序与下面程序的前面一部分是完全一致的。而下面程序的后面一部分代码动态方式调度静态函数。</p>
<p>　　下面程序的关键词<code>dyn</code>就是告诉编译器需要进行动态方式调度。但是，要是关键词<code>dyn</code>不在，也能够通过编译，只是有警告提示“不带显式<code>dyn</code>的衔接特质对象已弃用”，这告诉我们代码需要增加动态调度关键词<code>dyn</code>。</p>
<p>　　这个警告提示提供了一条信息：我们正在涉及到的是衔接特质的一个或者一组对象，之所以需要动态方式，是因为，在Rust语言里衔接特质关键词<code>trait</code>可以针对任何类型实现功能，这是一种未知类型行为的随时调度方式。衔接特质的对象如同一个衔接插口，可以随时插到任何一个类型上。</p>
<p>　　在动态调度时，Rust语言需要衔接特质对象的指针。从下面后面的三段代码里，可以理解到这个概念。比如。指针类型<code>Box</code>把实例<code>instance_struct</code>包装为指针类型；类型Vec的内部项都是实例<code>instance_struct</code>的指针类型。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/simple_dynamic_dispatch.rs
trait Trait {
    fn static_dispatch(&amp;self) -&gt; (u8);
}

#[derive(Default)]
struct Struct {data: (u8)}

impl Trait for Struct {
    fn static_dispatch(&amp;self) -&gt; (u8) {
        (self.data)
    }
}

// clear &amp;&amp; cargo run --example simple_dynamic_dispatch
fn main () {
    let instance_struct: Struct = Default::default();
    assert_eq!((0u8), instance_struct.static_dispatch());

    let instance_struct: Struct = Default::default();
    let box_struct: Box&lt;dyn Trait&gt; = Box::new(instance_struct);
    assert_eq!((0), box_struct.static_dispatch());

    let instance_struct: Struct = Default::default();
    let mut v: Vec&lt;&amp;dyn Trait&gt; = Vec::new();
    v.push(&amp;instance_struct);
    for instance_struct in v.iter() {
        assert_eq!((0), instance_struct.static_dispatch());
    }

    let instance_struct: Struct = Default::default();
    let mut v: Vec&lt;Box&lt;dyn Trait&gt;&gt; = Vec::new();
    v.push(Box::new(instance_struct));
    for instance_struct in v.iter() {
        assert_eq!((0), instance_struct.static_dispatch());
    }    
}
</code></pre></pre>
<h2><a class="header" href="#调用动态函数的实例" id="调用动态函数的实例">调用动态函数的实例</a></h2>
<p>　　这里将说明基于衔接特质关键性<code>trait</code>的静态和动态函数实现，但是这静态函数与之前的也是完全不一样的概念。另外将会看到调用这种动态函数，它们看起来是一些更复杂的静态和动态函数。</p>
<p>　　下面程序第二段代码的两个函数<code>static_dispatch()</code>和<code>dynamic_dispatch()</code>，它们的目的是解决代码重复的相同问题。但是其手段是不同的。</p>
<p>　　Rust语言没有继承概念，继承编程不再是软件开发的思想。通过关键词<code>trait</code>定义函数，借助于关键词impl实现函数及其泛型编程方法，以实现多态式编程方法。静态函数<code>static_dispatch()</code>使用了泛型编程方法，关于泛型编程将有另外专题说明。</p>
<p>　　Rust语言也通过衔接特质对象及动态调度编程方法，来实现多态式编程方法。动态函数<code>dynamic_dispatch()</code>使用了动态编程方法。特性对象是不限类型的，动态绑定类型是通过实时运行时具体地匹配类型。</p>
<p>　　从代码上看，静态函数<code>static_dispatch()</code>和动态函数<code>dynamic_dispatch()</code>都是实现相同的功能。</p>
<p>　　下面程序第三段代码里，无论是类型<code>NormalStruct</code>，还是类型<code>TupleStruct</code>，它们都是以同一方式分别调用函数<code>static_dispatch()</code>和函数<code>dynamic_dispatch()</code>。</p>
<p>　　不管是静态函数，还是动态函数，它们都是基于衔接特质对象的指针实现，这一点是非常重要的。</p>
<p>　　下面程序是Rust语言非常经典的代码结构。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_dispatch_concrete.rs
// 1. Define and Implement struct, trait and impl..for
struct NormalStruct {
    data: (u8)
}

trait Trait {
    fn _fn(&amp;self) -&gt; (u8);
}

impl Trait for NormalStruct {
    fn _fn(&amp;self) -&gt; (u8) { (self.data) }
}

struct TupleStruct(u8);

impl Trait for TupleStruct {
    fn _fn(&amp;self) -&gt; (u8) { (self.0) }
}

// 2. Implement static and dynamic dispatch
fn static_dispatch&lt;TraitObject: Trait&gt;(r#type: &amp;TraitObject) {
    r#type._fn(); 
}

fn dynamic_dispatch(r#trait: &amp;dyn Trait) {
    r#trait._fn();
}

// 3. Use these dispatch functions
// clear &amp;&amp; cargo run --example trait_dispatch_concrete
fn main() {
    let instance_struct = NormalStruct{data: 0};
    assert_eq!((), static_dispatch(&amp;instance_struct));
    assert_eq!((), dynamic_dispatch(&amp;instance_struct));

    let instance_tuple = TupleStruct(0);
    assert_eq!((), static_dispatch(&amp;instance_tuple));
    assert_eq!((), dynamic_dispatch(&amp;instance_tuple));
}
</code></pre></pre>
<h2><a class="header" href="#题外话-12" id="题外话-12">题外话</a></h2>
<h3><a class="header" href="#原始标识符前缀r" id="原始标识符前缀r">原始标识符前缀<code>r#</code></a></h3>
<p>　　原始标识符也是一种标识符，其前缀是<code>r#</code>，之后也可以加上任何严格或保留的关键字，但除关键字<code>crate, extern, self, super, Self</code>外。</p>
<h3><a class="header" href="#向量数据类型vec" id="向量数据类型vec">向量数据类型<code>Vec</code></a></h3>
<p>　　向量数据类型<code>Vec</code>也是一种数组，其内部是以0开始进行排序的，但是这种数组大小是可调整的，或者说是一种连续的且可增长的数组类型。</p>
<h2><a class="header" href="#参考资料-21" id="参考资料-21">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/identifiers.html">reference identifiers</a></li>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/doc-02-21-2015/book/static-and-dynamic-dispatch.html">static-and-dynamic-dispatch</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html">book static-and-dynamic-dispatch</a></li>
<li><a href="https://jmarcher.io/when-does-dynamic-vs-static-dispatch-matter/">when-does-dynamic-vs-static-dispatch-matter</a></li>
<li><a href="https://riptutorial.com/rust/example/4656/static-and-dynamic-dispatch">riptutorial.com static-and-dynamic-dispatch</a></li>
<li><a href="https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/">exploring-dynamic-dispatch-in-rust</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://gist.github.com/greister/37289c6eb3629d4fefa7dd0acf6de378">Static vs Dynamic dispatch</a></li>
<li><a href="https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html">a_quick_look_at_trait_objects_in_rust</a></li>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">b5.impls_and_traits</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.dyn.html">std keyword dyn</a></li>
<li><a href="https://stackoverflow.com/questions/25818082/vector-of-objects-belonging-to-a-trait/25819164">Vector of objects belonging to a trait</a></li>
</ul>
<h1><a class="header" href="#深度解析动态与静态调度实现" id="深度解析动态与静态调度实现">深度解析动态与静态调度实现</a></h1>
<p>　　在本节里。主要解释静态函数与动态函数的内部结构。</p>
<h2><a class="header" href="#学习内容-23" id="学习内容-23">学习内容</a></h2>
<ul>
<li>进一步学习静态函数与动态函数</li>
<li>通过Miri了解分析Rust语言代码</li>
</ul>
<h2><a class="header" href="#篇目-27" id="篇目-27">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/examples-miri.html#%E4%BB%80%E4%B9%88%E6%98%AFMiri">什么是Miri</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E4%B8%8EMiri%E7%9B%B8%E5%85%B3%E7%9A%84Cargo%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4">与Miri相关的Cargo工具命令</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E6%89%93%E5%BC%80Miri%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4">打开Miri代码文件命令</a></li>
<li><a href="hello-mod-trait/examples-miri.html#Miri%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E">Miri代码实例说明</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E4%B8%8E%E7%89%B9%E8%B4%A8%E5%AF%B9%E8%B1%A1">类型泛型参数与特质对象</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#什么是miri" id="什么是miri">什么是Miri</a></h2>
<p>　　<a href="https://github.com/rust-lang/miri">Miri</a>网站说明如下：</p>
<pre><code>An experimental interpreter for Rust's mid-level intermediate representation (MIR).
</code></pre>
<p>直接翻译为：Rust语言的中间中级水平表达层（mid-level intermediate representation，MIR）的实验解释器。这里有两个中间是什么意思？“intermediate”是说明Miri是介于Rust语言与汇编语言编译过程的中间位置；“mid-level”可以理解为表达层代码水平。</p>
<p>　　Miri作用是什么？在编译器中引入这一表达层（MIR），消除了Rust语言代码大部分表面的表示层（mid-level），留下了一种更简单的形式，目的是适合于类型检查和翻译成汇编语言（intermediate）。</p>
<h2><a class="header" href="#与miri相关的cargo工具命令" id="与miri相关的cargo工具命令">与Miri相关的Cargo工具命令</a></h2>
<p>　　在项目根目录下，执行代码命令，可以得到Miri代码文件。一般情况下，该文件是不会出现在项目目录里的。</p>
<p>　　这个命令是两部分，在`cargo之前部分，是告诉编译器想到得到额外的编译结果。后面部分是想编译什么内容。</p>
<p>　　与Miri编译相关内容是在<code>release</code>编译版本下才能得到。</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;--emit mir&quot; cargo build --release --example trait_dispatch_concrete
</code></pre>
<h2><a class="header" href="#打开miri代码文件命令" id="打开miri代码文件命令">打开Miri代码文件命令</a></h2>
<p>　　可以通过资源管理器来寻找如下命令里的目录文件，也可以使用下面命令打开，其中<code>-t</code>是告诉命令<code>open</code>使用默认编辑器打开该文件。该文件名称非常长，所以命令里使用了星号。</p>
<p>　　从网络上看，还没有能够显示Miri代码的工具。</p>
<pre><code class="language-bash">open -t ./target/release/examples/trait_dispatch_concrete-*.mir
</code></pre>
<h2><a class="header" href="#miri代码实例说明" id="miri代码实例说明">Miri代码实例说明</a></h2>
<p>　　为了说明问题，下面Miri代码仅仅是其一部分代码，包括静态函数和动态函数，并且还是省略过的。凡是&quot;...&quot;都是两个函数相同的代码。</p>
<p>　　从下面的Miri代码里，可以看到，函数<code>static_dispatch()</code>的参数只有一个，它是衔接特质的对象指针，函数<code>dynamic_dispatch</code>的参数也只有一个，它是衔接特质的指针。除了这一点区别之外，其余都是一样的。</p>
<p>　　从上面分析可以了解到，衔接特质的对象是确定的，使用它，可以理解为已知类型的特质准备的，而动态的衔接特质是不确定的，可以理解为未知类型的特质准备的。</p>
<pre><code>fn  static_dispatch(_1: &amp;TraitObject) -&gt; () {
    ...
    let mut _3: &amp;TraitObject;            // in scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:23:5: 23:11

    bb0: {
        ...
        _2 = const &lt;TraitObject as Trait&gt;::fn(move _3) -&gt; bb1; // bb0[3]: scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:23:5: 23:18 //...

    }

    bb1: {
        ...
    }
}
</code></pre>
<pre><code>fn  dynamic_dispatch(_1: &amp;dyn Trait) -&gt; () {
    ...
    let mut _3: &amp;dyn Trait;              // in scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:27:5: 27:12

    bb0: {
        ...
        _2 = const &lt;dyn Trait as Trait&gt;::fn(move _3) -&gt; bb1; // bb0[3]: scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:27:5: 27:19 //...
    }

    bb1: {
        ...
    }
}
</code></pre>
<h2><a class="header" href="#类型泛型参数与特质对象" id="类型泛型参数与特质对象">类型泛型参数与特质对象</a></h2>
<p>　　类型泛型参数（generics type parameters）与特质对象（trait objects）</p>
<h2><a class="header" href="#参考资料-22" id="参考资料-22">参考资料</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/miri">An interpreter for Rust's mid-level intermediate representation</a></li>
</ul>
<h1><a class="header" href="#共享篋简单三层结构实现" id="共享篋简单三层结构实现">共享篋：简单三层结构实现</a></h1>
<p>　　在前面学习概念基础之上，在这一节里，将会实现共享篋的简单三层结构。</p>
<h2><a class="header" href="#学习内容-24" id="学习内容-24">学习内容</a></h2>
<ul>
<li>理解和掌握知识模块的实现</li>
</ul>
<h2><a class="header" href="#篇目-28" id="篇目-28">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-fn.html#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">静态函数的知识模块实现</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">动态函数的知识模块实现</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">应用实例</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#静态函数的知识模块实现" id="静态函数的知识模块实现">静态函数的知识模块实现</a></h2>
<p>　　下面模块<code>mod_static_fn</code>代码，利用衔接特质<code>TraitCanal</code>，实现了两个不同功能的静态函数：<code>get_static_type_ref()</code>和<code>print_static_all_daten()</code>。</p>
<p>　　关于函数<code>get_static_type_ref()</code>，输入实例是类型<code>StructType</code>或者<code>TupleType</code>的指针，输出是类型<code>tuple</code>，其元素值是它们属性<code>data</code>值。</p>
<p>　　关于函数<code>print_static_all_daten()</code>，输入实例是<code>StructType</code>或者<code>TupleType</code>数组的指针，程序接受输入实例以后，打印输入实例及其属性内容。</p>
<p>　　为了使用函数<code>print_static_all_daten()</code>里的打印宏，程序里需要做到两点：</p>
<ul>
<li>使用语句：<code>use std::fmt::Debug;</code>;</li>
<li>函数参数里增加该特质<code>Debug</code>;</li>
</ul>
<p>但是第一条语句应该不需要，因为类型<code>StructType</code>和<code>TupleType</code>已经声明过了特质<code>Debug</code>。如特质<code>PartialEq</code>就没有使用<code>use</code>语句，这是因为类型<code>StructType</code>和<code>TupleType</code>也已经声明过了<code>PartialEq</code>。但是有一点是肯定的：先要声明特质，然后还要在静态函数里使用它们，才能真正实现使用这些特质。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_static_fn.rs
use super::mod_trait::TraitCanal;
use std::fmt::Debug;
use std::cmp::PartialEq;

//get_static_type_ref&lt;T&gt;
//get_static_trait_ref::&lt;StructType&gt;
//get_static_trait_ref::&lt;TupleType&gt;

// get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32)
//get_static_trait_ref(typ: &amp;StructType) -&gt; (u32)
//get_static_trait_ref(typ: &amp;TupleType) -&gt; (u32)

// static: Generics type parameters
// dynamic: trait objects

pub fn get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn print_static_all_daten&lt;Type: TraitCanal+Debug+PartialEq&gt;(typs: &amp;[Type]) {
    for typ in typs {
        let data = typ.get_tuple();
        println!(&quot;{:?}&quot;, typ);          // FOR Debug
        println!(&quot;{:?}&quot;, data);         // FOR Debug
        assert_eq!(*typ, typ.get_object());   // FOR PartialEq
    }
}
</code></pre></pre>
<h2><a class="header" href="#动态函数的知识模块实现" id="动态函数的知识模块实现">动态函数的知识模块实现</a></h2>
<p>　　下面模块<code>mod_dynamic_fn</code>代码的函数，与前面的说明完全类似。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_dynamic_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_dynamic_trait_ref(canal: &amp;dyn TraitCanal) -&gt; (u32) {
    (canal.get_tuple())
}

</code></pre></pre>
<h2><a class="header" href="#应用实例" id="应用实例">应用实例</a></h2>
<p>　　</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_fn_hello.rs
// clear &amp;&amp; cargo run --example trait_fn_hello
use mod_trait_exerci::mod_static_fn;
use mod_trait_exerci::mod_dynamic_fn;
use mod_trait_exerci::mod_trait;
use mod_trait::StructType;
use mod_trait::TupleType;

fn get_data_from_struct(instance: &amp;StructType) {
    let data = mod_static_fn::get_static_type_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
    let data = mod_dynamic_fn::get_dynamic_trait_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

fn get_data_from_tuple(instance: &amp;TupleType) {
    let data = mod_static_fn::get_static_type_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
    let data = mod_dynamic_fn::get_dynamic_trait_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

// clear &amp;&amp; cargo run --example trait_fn_hello
fn main() {
    let instance: StructType = Default::default();
    get_data_from_struct(&amp;instance);

    let instance: TupleType = Default::default();
    get_data_from_tuple(&amp;instance);

    let instance: TupleType = Default::default();
    let instances = vec![instance, TupleType::new(100)];
    mod_static_fn::print_static_all_daten(&amp;instances);    
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-23" id="参考资料-23">参考资料</a></h2>
<h1><a class="header" href="#共享篋基于封装的静态调度实现" id="共享篋基于封装的静态调度实现">共享篋：基于封装的静态调度实现</a></h1>
<p>　　在这一节里，列出基于指针类型<code>Box</code>封装的静态调度实现。</p>
<h2><a class="header" href="#学习内容-25" id="学习内容-25">学习内容</a></h2>
<ul>
<li>了解和学习基于指针类型<code>Box</code>封装的静态函数实现方法</li>
</ul>
<h2><a class="header" href="#篇目-29" id="篇目-29">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-static.html#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">静态模块实现</a></li>
<li><a href="hello-mod-trait/lib-static.html#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E5%BA%94%E7%94%A8">静态模块应用</a></li>
<li><a href="hello-mod-trait/lib-static.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#静态模块实现" id="静态模块实现">静态模块实现</a></h2>
<p>　　</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_static_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_static_box_ref&lt;Type: TraitCanal&gt;(typ: &amp;Box&lt;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box&lt;Type: TraitCanal&gt;(typ: Box&lt;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box_type_ref&lt;Type: TraitCanal + ?Sized&gt;(typ: Box&lt;&amp;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box_and_type_ref&lt;Type: TraitCanal + ?Sized&gt;(typ: &amp;Box&lt;&amp;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}


</code></pre></pre>
<h2><a class="header" href="#静态模块应用" id="静态模块应用">静态模块应用</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">use mod_trait_exerci::mod_box_static_fn;
use mod_trait_exerci::mod_trait::StructType;
use mod_trait_exerci::mod_trait::TraitCanal;
use mod_trait_exerci::mod_trait::TupleType;

// clear &amp;&amp; cargo run --example box_static_hello
fn main() {
    let instance: StructType = Default::default();
    let instance_box_type: Box&lt;StructType&gt; = Box::new(instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box(instance_box_type));

    let instance: StructType = Default::default();
    let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box_type_ref(instance_box_type));

    let instance: TupleType = Default::default();
    let instance_box_type: Box&lt;TupleType&gt; = Box::new(instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box(instance_box_type));

    let instance: TupleType = Default::default();
    let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box_type_ref(instance_box_type));
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-24" id="参考资料-24">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std Box</a></li>
</ul>
<h1><a class="header" href="#共享篋基于封装的动态调度实现" id="共享篋基于封装的动态调度实现">共享篋：基于封装的动态调度实现</a></h1>
<p>　　在这一节里，列出基于指针类型<code>Box</code>封装的动态调度实现。</p>
<h2><a class="header" href="#学习内容-26" id="学习内容-26">学习内容</a></h2>
<ul>
<li>了解和学习基于指针类型<code>Box</code>封装的动态函数实现方法</li>
</ul>
<h2><a class="header" href="#篇目-30" id="篇目-30">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">动态模块实现</a></li>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E5%BA%94%E7%94%A8">动态模块应用</a></li>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#动态模块实现" id="动态模块实现">动态模块实现</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_dynamic_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_dynamic_box(canal: Box&lt;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_trait_ref(canal: Box&lt;&amp;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_ref(canal: &amp;Box&lt;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_and_trait_ref(canal: &amp;Box&lt;&amp;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}
</code></pre></pre>
<h2><a class="header" href="#动态模块应用" id="动态模块应用">动态模块应用</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/box_dynamic_hello.rs
use mod_trait_exerci::mod_box_dynamic_fn;
use mod_trait_exerci::mod_trait::StructType;
use mod_trait_exerci::mod_trait::TraitCanal;
use mod_trait_exerci::mod_trait::TupleType;

// clear &amp;&amp; cargo run --example box_dynamic_hello
fn main() {
    let instance: StructType = Default::default();
    let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));

    let instance: StructType = Default::default();
    let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));

    let instance: TupleType = Default::default();
    let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));

    let instance: TupleType = Default::default();
    let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-25" id="参考资料-25">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#共享篋单元测试代码解释" id="共享篋单元测试代码解释">共享篋：单元测试代码解释</a></h1>
<p>　　在这一节里，实现共享篋每一个模块的单元测试代码。</p>
<h2><a class="header" href="#学习内容-27" id="学习内容-27">学习内容</a></h2>
<ul>
<li>了解和学习实现基于不同类型的单元测试方法</li>
</ul>
<h2><a class="header" href="#篇目-31" id="篇目-31">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-tests.html#%E6%A8%A1%E5%9D%97mod_bare%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">模块<code>mod_bare</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%A8%A1%E5%9D%97mod_trait%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于实例的模块<code>mod_trait</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块的实例单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8BBox%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块静态函数的类型<code>Box</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8BBox%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块动态函数的类型<code>Box</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#模块mod_bare单元测试" id="模块mod_bare单元测试">模块<code>mod_bare</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_bare.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_bare
#[cfg(test)]
mod tests {
    use mod_trait_exerci::mod_bare;
    use mod_bare::StructType;
    use mod_bare::TupleType;

    #[test]
    fn it_works_with_struct_default() {
        let instance: StructType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_struct_struct() {
        let instance = StructType{data:(0)};
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_struct() {
        let instance_default: StructType = Default::default();
        let instance_struct = StructType{data:(0)};
        assert_eq!(instance_default, instance_struct);
    }

    #[test]
    fn it_works_with_tuple_default() {
        let instance: TupleType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_tuple_struct() {
        let instance = TupleType(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_tuple() {
        let instance_default: TupleType = Default::default();
        let instance_tuple = TupleType(0);
        assert_eq!(instance_default, instance_tuple);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于实例的模块mod_trait单元测试" id="基于实例的模块mod_trait单元测试">基于实例的模块<code>mod_trait</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_trait_instance.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_trait_instance
#[cfg(test)]
mod tests {
    use mod_trait_exerci::mod_trait;
    use mod_trait::TraitCanal;
    use mod_trait::StructType;
    use mod_trait::TupleType;

    #[test]
    fn it_works_with_struct_default() {
        let instance: StructType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_struct_new() {
        let instance = StructType::new(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_struct() {
        let instance_default: StructType = Default::default();
        let instance_struct = StructType::new(0);
        assert_eq!(instance_default, instance_struct);
    }

    #[test]
    fn it_works_with_tuple_default() {
        let instance: TupleType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_tuple_struct() {
        let instance = TupleType::new(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

    #[test]
    fn it_works_with_tuple() {
        let instance_default: TupleType = Default::default();
        let instance_tuple = TupleType::new(0);
        assert_eq!(instance_default, instance_tuple);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于中间模块的实例单元测试" id="基于中间模块的实例单元测试">基于中间模块的实例单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_trait_fn.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_trait_fn
#[cfg(test)]
mod tests {
    use mod_trait_exerci::mod_static_fn;
    use mod_trait_exerci::mod_dynamic_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TupleType;

    #[test]
    fn it_works_with_fn_struct_default() {
        let instance: StructType = Default::default();
        let data = mod_static_fn::get_static_type_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
        let data = mod_dynamic_fn::get_dynamic_trait_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
    }

    #[test]
    fn it_works_with_fn_tuple_default() {
        let instance: TupleType = Default::default();
        let data = mod_static_fn::get_static_type_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
        let data = mod_dynamic_fn::get_dynamic_trait_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于中间模块静态函数的类型box单元测试" id="基于中间模块静态函数的类型box单元测试">基于中间模块静态函数的类型<code>Box</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_box_static_hello.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// clear &amp;&amp; cargo test --test u_for_box_static_hello
#[cfg(test)]
mod tests {
    use mod_trait_exerci::mod_box_static_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TraitCanal;
    use mod_trait::TupleType;

    #[test]
    fn struct_static_box() {
        let instance: StructType = Default::default();
        let instance_box_type: Box&lt;StructType&gt; = Box::new(instance);
        //assert_eq!(0, mod_box_static_fn::get_static_type_ref(&amp;instance_box_type));
        //assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance));
        assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box(instance_box_type));
    }

    #[test]
    fn struct_static_box_ref_and_type_ref() {
        let instance: StructType = Default::default();
        let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box_type_ref(instance_box_type));
    }

    #[test]
    fn tuple_static_box() {
        let instance: TupleType = Default::default();
        let instance_box_type: Box&lt;TupleType&gt; = Box::new(instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box(instance_box_type));
    }

    #[test]
    fn tuple_static_box_type() {
        let instance: TupleType = Default::default();
        let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box_type_ref(instance_box_type));
    }
}

</code></pre></pre>
<h2><a class="header" href="#基于中间模块动态函数的类型box单元测试" id="基于中间模块动态函数的类型box单元测试">基于中间模块动态函数的类型<code>Box</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_box_dynamic_hello.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// clear &amp;&amp; cargo test --test u_for_box_dynamic_hello
#[cfg(test)]
mod tests {
    use mod_trait_exerci::mod_box_dynamic_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TraitCanal;
    use mod_trait::TupleType;

    #[test]
    fn struct_dynamic_box() {
        let instance: StructType = Default::default();
        let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));
    }

    #[test]
    fn struct_dynamic_box_and_trait() {
        let instance: StructType = Default::default();
        let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
    }

    #[test]
    fn tulpe_dynamic_box() {
        let instance: TupleType = Default::default();
        let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));
    }

    #[test]
    fn tulpe_dynamic_box_trait() {
        let instance: TupleType = Default::default();
        let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
    }
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-26" id="参考资料-26">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#题外话-13" id="题外话-13">题外话</a></h1>
<h2><a class="header" href="#篇目-32" id="篇目-32">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B">泛型类型实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B">泛型方法实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B">泛型实现实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E8%B4%A8%E5%AE%9E%E4%BE%8B">泛型特质实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#泛型类型实例" id="泛型类型实例">泛型类型实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unused_variables)]
struct Struct&lt;T&gt; (T);

// clear &amp;&amp; cargo run --example generics_type_hello
fn main() {
    let instance = Struct(0u8);
    let instance = Struct(0u32);
    let instance = Struct('0');
    let instance = Struct(0.0);
    let instance = Struct(&quot;0.0&quot;);
    let instance = Struct(());
    let instance = Struct([0]);
    let instance = Struct(Struct(0.0f64));
}
</code></pre></pre>
<h2><a class="header" href="#泛型方法实例" id="泛型方法实例">泛型方法实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unused_variables)]
use std::fmt::Debug;

fn print&lt;T: Debug&gt;(x: T) {
    println!(&quot;{:?}&quot;, x);
}

// clear &amp;&amp; cargo run --example generics_fn_hello
fn main() {
    print(0u8);
    print(0u32);
    print('0');
    print(0.0);
    print(&quot;0.0&quot;);
    print(());
    print([0]);
}
</code></pre></pre>
<h2><a class="header" href="#泛型实现实例" id="泛型实现实例">泛型实现实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unused_variables)]
struct Struct&lt;T&gt; (T);

impl&lt;S&gt; Struct&lt;S&gt; {
    fn get(&amp;self) -&gt; &amp;S {
        &amp;self.0
    }
}
// clear &amp;&amp; cargo run --example generics_impl_hello
fn main() {
    let instance = Struct(0u8);
    instance.get();
    let instance = Struct(0u32);
    instance.get();

    let instance = Struct('0');
    instance.get();
    let instance = Struct(&quot;0&quot;);
    instance.get();
}
</code></pre></pre>
<h2><a class="header" href="#泛型特质实例" id="泛型特质实例">泛型特质实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unused_variables)]
struct Struct&lt;T&gt; (T);

trait Trait&lt;U&gt; {
    fn get(&amp;self) -&gt; &amp;U;
}

impl&lt;S&gt; Trait&lt;S&gt; for Struct&lt;S&gt; {
    fn get(&amp;self) -&gt; &amp;S {
        &amp;self.0
    }
}

// clear &amp;&amp; cargo run --example generics_trait_hello
fn main() {
    let instance = Struct(0u8);
    instance.get();
    let instance = Struct(0u32);
    instance.get();

    let instance = Struct('0');
    instance.get();
    let instance = Struct(&quot;0&quot;);
    instance.get();
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">// Dynamically Sized Types (DSTs)
// https://doc.rust-lang.org/nomicon/exotic-sizes.html
struct MySuperSliceable&lt;T: ?Sized&gt; {
    info: u32,
    data: T
}

fn main() {
    let sized: MySuperSliceable&lt;[u8; 8]&gt; = MySuperSliceable {
        info: 17,
        data: [0; 8],
    };

    let dynamic: &amp;MySuperSliceable&lt;[u8]&gt; = &amp;sized;

    // prints: &quot;17 [0, 0, 0, 0, 0, 0, 0, 0]&quot;
    println!(&quot;{} {:?}&quot;, dynamic.info, &amp;dynamic.data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-27" id="参考资料-27">参考资料</a></h2>
<ul>
<li><a href="https://tutorialedge.net/rust/learning-generics-in-rust/">learning-generics-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">book ch10-01-syntax</a></li>
<li></li>
</ul>
<p><a href="https://crates.io/crates/borrowing_exerci"><img src="https://img.shields.io/crates/v/borrowing_exerci?label=borrowing_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-borrowing"><img src="https://img.shields.io/badge/hello--borrowing-code-yellowgreen" alt="The Crate borrowing_exerci Code" /></a></p>
<blockquote>
<p>$$\text{只有心灵的淡定宁静，继而产生的身心愉悦，才是幸福的真正源泉}$$</p>
</blockquote>
<h1><a class="header" href="#软件篋borrowing_exerci一" id="软件篋borrowing_exerci一">软件篋borrowing_exerci（一）</a></h1>
<h2><a class="header" href="#软件篋borrowing_exerci" id="软件篋borrowing_exerci">软件篋borrowing_exerci</a></h2>
<p>　　Rust语言的借用机制是其最主要的特点。通过实现借用方法，使得代码更加安全和可靠。</p>
<p>　　Rust语言存在两大数据类型：固定大小类型和可变大小类型。本章重点说明固定大小类型的借用机制。</p>
<h2><a class="header" href="#固定大小类型" id="固定大小类型">固定大小类型</a></h2>
<p>　　固定大小类型也称之为静态类型、常规固定大小类型或者栈分配值的类型。在编译时知道这种类型的大小，在编译以后，它们大小不可增长或缩小。比如，固定数组是元素的固定大小的列表。</p>
<h2><a class="header" href="#可变大小类型" id="可变大小类型">可变大小类型</a></h2>
<p>　　可变大小类型也称之为动态类型、可变大小的容器或者堆分配值的类型。在编译时不知道其类型的大小，但是它们可以随时增长或缩小其容量大小。比如，向量是可调整大小的数组，一种连续的可增长数组类型。</p>
<h2><a class="header" href="#参考资料-28" id="参考资料-28">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/22596920/split-a-module-across-several-files">split-a-module-across-several-files</a></li>
<li><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">ch07-05-separating-modules-into-different-files</a></li>
<li><a href="https://chronicbuildfailure.co/splitting-up-modules-in-rust-5ad7713201d5">splitting-up-modules-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html">references-and-borrowing</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow.html">rust-by-example/scope/borrow</a></li>
<li><a href="http://squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html">rust-borrowing-and-ownership</a></li>
<li><a href="https://medium.com/@bugaevc/understanding-rust-ownership-borrowing-lifetimes-ff9ee9f79a9c">understanding-rust-ownership-borrowing-lifetimes</a></li>
<li><a href="https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust">you-can-t-turn-off-the-borrow-checker-in-rust</a></li>
<li><a href="https://users.rust-lang.org/t/cant-derive-copy-because-of-string/18665/6">cant-derive-copy-because-of-string</a></li>
<li><a href="https://users.rust-lang.org/t/whats-the-difference-between-trait-copy-and-clone/2609">whats-the-difference-between-trait-copy-and-clone</a></li>
<li><a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone">what-is-the-difference-between-copy-and-clone</a></li>
<li><a href="https://www.codevamping.com/2018/12/rust-move-copy/">rust-move-copy</a></li>
<li><a href="https://www.snoyman.com/blog/2018/10/rust-crash-course-02-basics-of-ownership">rust-crash-course-02-basics-of-ownership</a></li>
<li><a href="https://jeenalee.com/2016/08/29/move-clone-copy.html">move-clone-copy</a></li>
<li><a href="https://facility9.com/2016/04/the-basics-of-rust-structs/">the-basics-of-rust-structs</a></li>
<li><a href="http://blog.joncairns.com/2015/10/a-single-command-to-compile-and-run-rust-programs/">a-single-command-to-compile-and-run-rust-programs</a></li>
<li><a href="https://stackoverflow.com/questions/41322300/how-to-execute-rust-code-directly-on-unix-systems-using-the-shebang">how-to-execute-rust-code-directly-on-unix-systems-using-the-shebang</a></li>
<li></li>
</ul>
<h2><a class="header" href="#关于软件篋borrowing_exerci" id="关于软件篋borrowing_exerci">关于软件篋borrowing_exerci</a></h2>
<h2><a class="header" href="#安装运行rust语言脚本工具cargo-script" id="安装运行rust语言脚本工具cargo-script">安装运行Rust语言脚本工具<code>cargo-script</code></a></h2>
<pre><code class="language-bash">cargo install cargo-script
</code></pre>
<h2><a class="header" href="#安装本软件箧borrowing_exerci" id="安装本软件箧borrowing_exerci">安装本软件箧<code>borrowing_exerci</code></a></h2>
<pre><code class="language-bash">cargo install borrowing_exerci
</code></pre>
<h2><a class="header" href="#使用方法" id="使用方法">使用方法</a></h2>
<h3><a class="header" href="#帮助命令" id="帮助命令">帮助命令</a></h3>
<pre><code class="language-bash">bw -h
</code></pre>
<h3><a class="header" href="#运行错误借用代码实例命令" id="运行错误借用代码实例命令">运行错误借用代码实例命令</a></h3>
<p>　　比如运行Rust程序<code>kw_fn.rs</code>命令如下：</p>
<pre><code class="language-bash">bw -f kw_fn -m err | bat -l rs
# tip: `f`, Forward  one window
# tip: `b`, Backward  one window
# tip: `q`, Exit.
</code></pre>
<h3><a class="header" href="#运行借用代码实例命令" id="运行借用代码实例命令">运行借用代码实例命令</a></h3>
<p>　　比如运行Rust程序<code>kw_fn.rs</code>命令如下：</p>
<pre><code class="language-bash">bw -f kw_fn -m ok | bat -l rs
</code></pre>
<h2><a class="header" href="#参考资料-29" id="参考资料-29">参考资料</a></h2>
<ul>
<li><a href="https://users.rust-lang.org/t/cargo-test-internal-packages/5187/2">cargo-test-internal-packages</a></li>
</ul>
<h1><a class="header" href="#克隆clone和复制copy" id="克隆clone和复制copy">克隆（Clone）和复制（Copy）</a></h1>
<h2><a class="header" href="#学习内容-28" id="学习内容-28">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言引用<code>Reference</code>、类型与原始指针<code>Pointer</code>关系</li>
</ul>
<h2><a class="header" href="#篇目-33" id="篇目-33">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/clone-copy.html#%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E8%A7%A3%E9%87%8A">复制特质<code>Copy</code>解释</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%85%8B%E9%9A%86%E7%89%B9%E8%B4%A8clone%E8%A7%A3%E9%87%8A">克隆特质<code>Clone</code>解释</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E8%A7%A3%E9%87%8A%E8%AF%AD%E5%8F%A5let-y--x">解释语句<code>let y = x;</code></a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E5%92%8C%E5%85%8B%E9%9A%86%E7%89%B9%E8%B4%A8clone%E5%8C%BA%E5%88%AB">复制特质<code>Copy</code>和克隆特质<code>Clone</code>区别</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">表达方式不同</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C">内部实现不同</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB%E4%B8%8D%E5%90%8C">类型区别不同</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E5%92%8C%E5%85%8B%E9%9A%86%E7%89%B9%E8%B4%A8clone%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB">复制特质<code>Copy</code>和克隆特质<code>Clone</code>的相互关系</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B">复制特质<code>Copy</code>元素的数组实例</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%89%B9%E8%B4%A8%E5%AE%9E%E7%8E%B0">两种不同特质实现</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E9%97%AE%E9%A2%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%88%91%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy">问题：什么时候我的类型应该使用复制特质<code>Copy</code>？</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E5%85%8B%E9%9A%86">问题：为什么存在克隆？</a></li>
<li><a href="hello-borrowing/clone-copy.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#复制特质copy解释" id="复制特质copy解释">复制特质<code>Copy</code>解释</a></h2>
<p>　　<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">官方说明</a>:</p>
<blockquote>
<p>Types whose values can be duplicated simply by copying bits.</p>
</blockquote>
<p>直接翻译：只需拷贝二进制数字位即可复制其值的类型。</p>
<p>解读：</p>
<ul>
<li>通过简单的内存拷贝，实现该类型的复制。</li>
<li>含简单值的类型（POD，Pain Old Data），如数字类型、bool类型和引用类型，都是具有复制特质<code>Copy</code>的类型。</li>
<li>只有当结构性类型内部的每个项都是Copy类型时，允许实现此类型复制特质<code>Copy</code>。如数组类型、tuple类型、struct类型和enum类型，它们内部的每个项都是Copy类型。</li>
<li>当结构性类型内部的项存在不是Copy类型时，它们就不能实现该类型的复制特质。如Box类型、字符串String和向量Vec，它们内部的项不都是Copy类型。</li>
</ul>
<p>解读延伸：</p>
<ul>
<li>复制特质<code>Copy</code>没有任何可实现的方法或函数。</li>
<li>复制特质<code>Copy</code>的行为是不可重载的。</li>
</ul>
<h2><a class="header" href="#克隆特质clone解释" id="克隆特质clone解释">克隆特质<code>Clone</code>解释</a></h2>
<p>　　<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">官方说明</a>:</p>
<blockquote>
<p>A common trait for the ability to explicitly duplicate an object.</p>
</blockquote>
<p>直接翻译：能够显式地复制一个对象的通用特质。</p>
<p>解读：</p>
<ul>
<li>克隆特质<code>Clone</code>是通用的，除了不确定大小或者动态大小类型之外，适合所有类型，可实现所有类型的克隆特质<code>Clone</code>。</li>
<li>只有手动调用克隆特质<code>Clone</code>方法，才能发挥其作用。作者称之为显式行为（an explicit action）。</li>
<li>克隆特质<code>Clone</code>的实现与具体类型密切相关。</li>
<li>克隆特质<code>Clone</code>有可以实现的方法。</li>
</ul>
<p>解读延伸：</p>
<ul>
<li>对于实现了复制特质<code>Copy</code>的类型，其克隆特质<code>Clone</code>与其复制特质<code>Copy</code>语义是一样的，等同于按位拷贝。</li>
<li>一般情况下，Rust语言使用克隆特质<code>Clone</code>方法来执行对象的复制。</li>
</ul>
<h2><a class="header" href="#解释语句let-y--x" id="解释语句let-y--x">解释语句<code>let y = x;</code></a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-13-moved-copied.png" alt="image" /></p>
<pre><code class="language-rust no_run noplaypen">// {T} is a data type value;
let x = {T};
let y = x;
</code></pre>
<p>　　上面两行代码仅仅是为了说明问题，不是Rust语言可运行代码。</p>
<p>　　在上面代码里，当尚未确定<code>{T}</code>的具体类型对象值时，第二行代码的作用可能出现两种可能性。</p>
<p>　　在Rust语里，一种称之为<strong>复制</strong>（copy）的可能性：对象<code>x</code>和<code>y</code>是两个可同时独立存在的对象；另一种称之为<strong>转移</strong>或者<strong>移动</strong>（move）的可能性：对象<code>x</code>和<code>y</code>是两个不能同时独立存在的对象，一旦执行了第二行代码以后，对象<code>x</code>不再存在了。</p>
<p>　　下面给出具体实例说明这两种情况。第一个是所谓的<strong>复制</strong>（copy）实例，这是可运行程序。而第二个是所谓的<strong>转移</strong>（move）实例，这是不可运行程序。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 33u8;
let y = x;
println!(&quot;x = {:p}&quot;, &amp;x);
println!(&quot;y = {:p}&quot;, &amp;y);
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = String::from(&quot;Hello&quot;);
let y = x;
println!(&quot;x = {:p}&quot;, &amp;x);
println!(&quot;y = {:p}&quot;, &amp;y);
#}</code></pre></pre>
<h2><a class="header" href="#复制特质copy和克隆特质clone区别" id="复制特质copy和克隆特质clone区别">复制特质<code>Copy</code>和克隆特质<code>Clone</code>区别</a></h2>
<h3><a class="header" href="#表达方式不同" id="表达方式不同">表达方式不同</a></h3>
<p>　　复制特质<code>Copy</code>是以隐含方式表达，Rust语言也称之为为拷贝（copy），而克隆是一个显式行为方式表达，Rust语言也称之为克隆（clone）。</p>
<p>　　注意：使用第一个字母大写<code>Copy</code>是指复制特质，而使用第一个字母小写（copy）是指复制特质<code>Copy</code>的行为，中文这里称之为“拷贝”或者“复制“。同理，使用第一个字母大写<code>Clone</code>是指克隆特质，而使用第一个字母小写（clone）是指克隆特质<code>Clone</code>的行为，中文这里称之为“克隆”或者”复制“。</p>
<p>　　下面两个程序分别说明两种行为：第一个是拷贝（copy）行为，第二个是克隆（clone）行为。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Copy：copy behavior
// The variables x and y are different instances, and both can be used
let x = 33u8;
let y = x;
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Clone: clone behavior
// The variables x and y are different instances, and both can be used
let x = String::from(&quot;Hello&quot;);
let y = x.clone();
#}</code></pre></pre>
<p>　　对于一些类型，克隆和复制行为是等价的，如静态类型<code>u8</code>。而对于另外一些类型，只有克隆没有复制，如类型<code>String</code>。当然也有类型，克隆和复制行为都存在，但是它们并是不等价的。</p>
<p>　　对于一些类型，克隆和复制行为都实现了，如静态类型<code>u8</code>。而对于另外一些类型，仅克隆行为实现了，如类型<code>String</code>。当然自定义类型，克隆和复制行为都没有实现，需要完全自己实现或者借助于Rust语言派生属性实现。这里仅仅提供一些概念，没有完全展开说明。</p>
<h3><a class="header" href="#内部实现不同" id="内部实现不同">内部实现不同</a></h3>
<p>　　复制特质<code>Copy</code>可以安全地复制类型对象的值。对于具有复制特质<code>Copy</code>的类型，编译器负责管理复制特质<code>Copy</code>类型的对象。</p>
<p>　　克隆特质<code>Clone</code>专为程序开发任意类型复制而设计。任何类型克隆特质<code>Clone</code>的实现可以执行创建类型所需的任意复杂方法。像正常特质一样使用及其方法调用。</p>
<h3><a class="header" href="#类型区别不同" id="类型区别不同">类型区别不同</a></h3>
<p>　　复制特质<code>Copy</code>适合于含值类型，如正整数u8类型。在类型u8的情况下，通过克隆无法来提高效率，这时候就不用再考虑克隆。</p>
<p>　　克隆特质<code>Clone</code>适合于重量级的类型，对于一种类型，两种特质都可以实现时，要是克隆（clone）比拷贝（copy）更有效，就尽可能使用克隆（clone）。</p>
<h2><a class="header" href="#复制特质copy和克隆特质clone的相互关系" id="复制特质copy和克隆特质clone的相互关系">复制特质<code>Copy</code>和克隆特质<code>Clone</code>的相互关系</a></h2>
<p>　　克隆特质<code>Clone</code>是复制特质<code>Copy</code>的父特质，因此特质<code>Copy</code>的所有内容也必须实现特质<code>Clone</code>。如果类型为特质<code>Copy</code>，则其特质<code>Clone</code>实现仅需要返回<code>*self</code>。每个特质<code>Copy</code>的类型也必须具有特质<code>Clone</code>的类型。</p>
<h2><a class="header" href="#复制特质copy元素的数组实例" id="复制特质copy元素的数组实例">复制特质<code>Copy</code>元素的数组实例</a></h2>
<p>　　从下面的实例可以看到，具有复制特质<code>Copy</code>元素的数组也是可以简单进行移动和拷贝。具有复制特质<code>Copy</code>元素的数组本质上就是复制自身，因此克隆特质<code>Clone</code>的实现可以不需要再引用直接返回自身的传递值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/other/clone.rs
    // Function use_clone_array()

    let a: [u8; 0] = [];
    dbg!(a);
    let b = a.clone();
    let c = a;
    dbg!(a, b, c);

    let a: [u8; 0] = [];
    dbg!(a);
    let b = a;
    let c = a.clone();
    dbg!(a, b, c);
    
#}</code></pre></pre>
<h2><a class="header" href="#两种不同特质实现" id="两种不同特质实现">两种不同特质实现</a></h2>
<p>　　复制特质<code>Copy</code>是特定的编译器特征，它指示编译器，开发人员希望为该类型激活隐式复制。仅当浅表拷贝与深度拷贝等效时，此特质才可用，这样可确保不会发生内存分配作为这些隐式拷贝的一部分。复制特质<code>Copy</code>是一种复制的方法，仅可拷贝若干个内存地址字节的类型。</p>
<p>　　克隆特质<code>Clone</code>指示编译器，开发人员创建新的对象，且必须显式调用才对象。大多数类型（但不是全部）都可以使用它进行拷贝。克隆特质<code>Clone</code>是也一种复制方法，可以拷贝运行任意代码的类型。</p>
<h2><a class="header" href="#题外话-14" id="题外话-14">题外话</a></h2>
<h3><a class="header" href="#问题什么时候我的类型应该使用复制特质copy" id="问题什么时候我的类型应该使用复制特质copy">问题：什么时候我的类型应该使用复制特质<code>Copy</code>？</a></h3>
<p>　　一般来说，如果一种类型可以实现复制特质<code>Copy</code>，则应该去实现该类型的复制特质<code>Copy</code>。但是如果该类型将来可能变为非复制特质<code>Copy</code>类型，则最好从一开始就不要实现复制特质，以避免以后发生重大更改。</p>
<p>　　如果在编译代码时，警告显示，请添加复制特质<code>Copy</code>，除非有充分的理由不这样做。</p>
<h3><a class="header" href="#问题为什么存在克隆" id="问题为什么存在克隆">问题：为什么存在克隆？</a></h3>
<p>　　从内部分析，克隆特质<code>Clone</code>的克隆（clone），与复制特质<code>Copy</code>的拷贝（copy）是一样的，也有拷贝（copy），只是这种拷贝（copy）资源不能让开发人员访问。为了区分两种情况，需要克隆特质<code>Clone</code>。</p>
<p>　　我们知道，复制特质<code>Copy</code>的拷贝（copy）要求可以使用堆栈中字节的简单内存来复制该值。但是克隆特质<code>Clone</code>的克隆（clone），不仅需要拷贝（copy）在栈（Stack）上的值（即容量、长度和指向内容的指针内存地址等），而且还需要创建（create）一个新的内存储存位置来复制其具体的内容。所以，克隆（clone）不仅仅是拷贝（copy）还有创建（create）行为，它也称之为深度拷贝（deep copy），而仅仅只有拷贝（copy）行为称之为浅表拷贝（shallow copy）。</p>
<p>　　需要指出的是，Rust语言的克隆特质<code>Clone</code>的实现既可以是深度拷贝，也可以是浅表拷贝。</p>
<p>　　比如，字符串<code>String</code>类型对象是可复制的，即克隆（clone）行为，请使用克隆方法<code>clone()</code>；字符串<code>String</code>类型对象不可完成隐式复制的目的，即拷贝（copy）行为，因为这将导致发生非显而易见的内存分配。</p>
<h2><a class="header" href="#参考资料-30" id="参考资料-30">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">std/marker/trait.Copy</a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone">whats-the-difference-between-copy-and-clone</a></li>
<li><a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone">what-is-the-difference-between-copy-and-clone</a></li>
<li><a href="https://users.rust-lang.org/t/whats-the-difference-between-trait-copy-and-clone/2609">whats-the-difference-between-trait-copy-and-clone</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/2xxjda/when_should_my_type_be_copy/">when_should_my_type_be_copy</a></li>
<li><a href="https://users.rust-lang.org/t/cant-derive-copy-because-of-string/18665/11">cant-derive-copy-because-of-string</a></li>
<li><a href="https://stackoverflow.com/questions/38215753/how-do-i-implement-copy-and-clone-for-a-type-that-contains-a-string">how-do-i-implement-copy-and-clone-for-a-type-that-contains-a-string</a></li>
<li><a href="https://stackoverflow.com/questions/38304666/how-to-define-a-copyable-struct-containing-a-string">how-to-define-a-copyable-struct-containing-a-string</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21730929">Clone VS Copy</a></li>
<li><a href="https://jeenalee.com/2016/08/29/move-clone-copy.html">move-clone-copy</a></li>
</ul>
<h1><a class="header" href="#可变类型派生分析" id="可变类型派生分析">可变类型派生分析</a></h1>
<p>　　首先，通过自定义结构类型<code>Struct(u8)</code>，展示派生属性<code>Clone</code>和<code>Copy</code>的代码，且说明两种派生属性区别。其次，对于派生属性<code>Clone</code>和<code>Copy</code>，应用于结构类型<code>Struct(u8)</code>与<code>Struct(String)</code>的区别。最后说明自定义类型<code>Struct&lt;'cn&gt;(&amp;'cn &amp;str)</code>的派生属性。</p>
<h2><a class="header" href="#学习内容-29" id="学习内容-29">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言可变类型的派生</li>
</ul>
<h2><a class="header" href="#篇目-34" id="篇目-34">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/cargo-expand.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7clone%E5%92%8Ccopy">可变类型的派生属性<code>Clone</code>和<code>Copy</code></a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7clone">可变类型的派生属性<code>Clone</code></a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7copy">可变类型的派生属性<code>Copy</code></a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E5%88%86%E6%9E%90%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7">分析不同类型的派生属性</a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8Bstructcncn-str%E7%9A%84%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7">自定义类型Struct&lt;'cn&gt;(&amp;'cn str)的派生属性</a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/cargo-expand.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#可变类型的派生属性clone和copy" id="可变类型的派生属性clone和copy">可变类型的派生属性<code>Clone</code>和<code>Copy</code></a></h2>
<p>　　在介绍可变类型的派生属性<code>Clone</code>和<code>Copy</code>之前，先考察下面不可变类型的实例。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// File: ./examples/expand/use_u8.rs
// clear &amp;&amp; cargo expand --example expand -- use_u8
// clear &amp;&amp; cargo run --example expand -- use_u8

#![allow(unused_variables)]

pub fn adjoin() {
    let instance = 42u8;
    let clone_instance = instance.clone();
    let copy_instance = instance;

    let use_instance = instance;
}

#}</code></pre></pre>
<p>　　上面程序是可运行的。使用派生工具<code>cargo-expand</code>，展开其代码的结果如下：</p>
<pre><code class="language-rust no_run noplaypen">mod use_u8 {
    #![allow(unused_variables)]
    pub fn adjoin() {
        let instance = 42u8;
        let clone_instance = instance.clone();
        let copy_instance = instance;
        let use_instance = instance;
    }
}
</code></pre>
<p>　　对于自定义的可变类型，要能够保证其对象克隆和复制，必须实现<code>Clone</code>和<code>Copy</code>两个特质，该类型才能使用克隆和复制其对象。途径有两条：要么自己实现该类型的这两个特质；要么使用语言提供的默认实现。这里使用后面方法。</p>
<p>　　下面程序是包含了自定义的可变类型。之所以该程序能够正常运行，是因为，下面与上面程序比较可以知道，除了类型不同之外，还多增加了包括两个派生属性<code>Clone</code>和<code>Copy</code>的一行代码，其作用是使得该类型可以克隆和复制其对象。对于不可变类型，Rust语言已经实现了克隆和复制功能，在这种情况下，克隆和复制功能是等价的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_u8.rs
    // #[cfg(feature = &quot;ok&quot;)]

    #[derive(Clone, Copy)]
    struct Struct(u8);

    let instance: Struct = Struct(42u8);
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // can move, because derive *Copy*,
    // and instance and copy_instance live
    let use_instance = instance;

#}</code></pre></pre>
<p>　　下面看看上面程序其两个派生属性<code>Clone</code>和<code>Copy</code>代码是怎么样实现的。使用派生工具运行结果如下。可以看到对于自定义类型<code>Struct(u8)</code>，存在两个特质<code>Clone</code>和<code>Copy</code>实现：</p>
<pre><code class="language-rust no_run noplaypen">mod struct_u8 {
    #![allow(unused_variables)]
    #[cfg(feature = &quot;ok&quot;)]
    pub fn adjoin() {
        struct Struct(u8);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Struct {
            #[inline]
            fn clone(&amp;self) -&gt; Struct {
                {
                    let _: ::core::clone::AssertParamIsClone&lt;u8&gt;;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Struct {}
        let instance: Struct = Struct(42u8);
        let clone_instance = instance.clone();
        let copy_instance = instance;
        let use_instance = instance;
    }
}
</code></pre>
<p>　　对于上面这种可变类型，要是其每一元素都是不可变类型，Rust语言可以实现了克隆和复制功能，同样，在这种情况下，克隆和复制功能也是等价的。</p>
<p>　　在上面程序里，之所以该类型对象<code>instance</code>能够被克隆和复制，是因为该类型实现了克隆特质<code>Clone</code>；之所以该类型对象<code>instance</code>能够被转移（move），是因为该类型实现了复制特质<code>Copy</code>。下面看看这是为什么。</p>
<h2><a class="header" href="#可变类型的派生属性clone" id="可变类型的派生属性clone">可变类型的派生属性<code>Clone</code></a></h2>
<p>　　注意比较上下两个程序的代码，下面代码缺少了复制特质<code>Copy</code>，且最后一行代码不是使用对象<code>instance</code>，而是使用<code>copy_instance</code>作为变量的绑定值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_u8.rs
    // #[cfg(feature = &quot;cp&quot;)]

    #[derive(Clone)]
    struct Struct(u8);

    let instance = Struct(42u8);
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // but can NOT move, because without derive *Copy*,
    // and instance live not, but copy_instance live
    let use_copy_instance = copy_instance;

#}</code></pre></pre>
<p>　　还是先让我们使用派生工具，展开其代码，其运行结果：</p>
<pre><code class="language-rust no_run noplaypen">mod struct_u8 {
    #![allow(unused_variables)]
    #[cfg(feature = &quot;cp&quot;)]
    pub fn adjoin() {
        struct Struct(u8);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Struct {
            #[inline]
            fn clone(&amp;self) -&gt; Struct {
                match *self {
                    Struct(ref __self_0_0) =&gt; Struct(::core::clone::Clone::clone(&amp;(*__self_0_0))),
                }
            }
        }
        let instance = Struct(42u8);
        let clone_instance = instance.clone();
        let copy_instance = instance;
        let use_copy_instance = copy_instance;
    }
}
</code></pre>
<p>　　从上面展开的代码来看，代码里不仅没有了复制特质<code>Copy</code>的实现，而且复制特质<code>Copy</code>存在与否直接影响到克隆特质<code>Clone</code>代码的实现。</p>
<p>　　在上面程序里，之所以该类型对象<code>instance</code>能够被克隆和复制，是因为该类型实现了克隆特质<code>Clone</code>；之所以该类型对象<code>instance</code>不能被转移（move），是因为该类型没有实现复制特质<code>Copy</code>。下面看看这是为什么。</p>
<p>　　上下程序唯一不同是最后一行代码，但是其结果完全不同了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_u8.rs
    // ANCHOR = &quot;struct_u8_error_01&quot;
    // error[E0382]: use of moved value: `instance`

    #[derive(Clone)]
    struct Struct(u8);

    let instance = Struct(42u8);
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // but can NOT move, because without derive *Copy*,
    // and instance live not
    let use_instance = instance;

#}</code></pre></pre>
<p>　　上面程序以错误运行结果结束：</p>
<pre><code>error[E0382]: use of moved value: `instance`
  --&gt; bin-hello/examples/expand/struct_u8.rs:76:24
   |
69 |     let instance = Struct(42u8);
   |         -------- move occurs because `instance` has type `struct_u8::adjoin::Struct`, which does not implement the `Copy` trait
70 |     let clone_instance = instance.clone();
71 |     let copy_instance = instance;
   |                         -------- value moved here
...
76 |     let use_instance = instance;
   |                        ^^^^^^^^ value used here after move
</code></pre>
<h2><a class="header" href="#可变类型的派生属性copy" id="可变类型的派生属性copy">可变类型的派生属性<code>Copy</code></a></h2>
<p>　　对于自定义类型，要是只有复制特质<code>Copy</code>，程序编译会是什么结果？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_u8.rs
    // ANCHOR = &quot;struct_u8_error_03&quot;
    // error[E0277]: the trait bound `struct_u8::adjoin::Struct: std::clone::Clone` is not satisfied

    #[derive(Copy)]
    struct Struct(u8);

    let instance = Struct(42u8);
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // derive *Copy* error, because without derive *Clone*
    let use_instance = instance;

#}</code></pre></pre>
<p>　　该程序运行结果是以错误结束。而这种错误说明需要先实现克隆特质<code>Clone</code>。</p>
<pre><code>error[E0277]: the trait bound `main::Struct: std::clone::Clone` is not satisfied
  --&gt; bin-hello/examples/struct_u8.rs:56:14
   |
56 |     #[derive(Copy)]
   |              ^^^^ the trait `std::clone::Clone` is not implemented for `main::Struct`
</code></pre>
<p>　　尽管该程序不能编译，但是还是可以运行派生工具，其结果如下：</p>
<pre><code>#![feature(prelude_import)]
#![allow(unused_variables)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
#[cfg(feature = &quot;err_02&quot;)]
fn main() {
    struct Struct(u8);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Struct {}
    let instance = Struct(42u8);
    let clone_instance = instance.clone();
    let copy_instance = instance;
    let get_instance = instance;
}
</code></pre>
<h2><a class="header" href="#分析不同类型的派生属性" id="分析不同类型的派生属性">分析不同类型的派生属性</a></h2>
<p>　　将前面包含派生属性<code>Clone</code>和<code>Copy</code>程序进行这样的调整：把结构类型的元素类型<code>u8</code>修改为<code>String</code>，得到如下程序：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_string.rs
    // ANCHOR = &quot;struct_string-error_01&quot;
    // error[E0204]: the trait `Copy` may not be implemented for this type

    #[derive(Clone, Copy)]
    struct Struct(String);

    let instance = Struct(String::from(&quot;Hello&quot;));
    let clone_instance = instance.clone();
    let copy_instance = instance;

    let use_instance = instance;

#}</code></pre></pre>
<p>　　上面程序运行结果如下。我们知道前面类似程序运行是正常的，为什么到这里就不能运行了呢？这是因为类型<code>String</code>是可变类型，对于所有这种形式的类型，Rust语言都没有实现其复制特质<code>Copy</code>.</p>
<pre><code>error[E0204]: the trait `Copy` may not be implemented for this type
  --&gt; bin-hello/examples/expand/struct_string.rs:38:21
   |
38 |     #[derive(Clone, Copy)]
   |                     ^^^^
39 |     struct Struct(String);
   |                   ------ this field does not implement `Copy`
</code></pre>
<p>　　那么什么是这种类型一般性使用方法呢？对于这种类型，仅使用Rust语言提供的克隆特质<code>Clone</code>，其代码如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_string.rs
    // #[cfg(feature = &quot;ok&quot;)]

    #[derive(Clone)]
    struct Struct(String);

    let instance = Struct(String::from(&quot;Hello&quot;));
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // can not move, because without derive *Copy*,
    // and instance live not, copy_instance live
    let use_copy_instance = copy_instance;

#}</code></pre></pre>
<p>　　通过派生工具命令，展开该程序代码。注意这里克隆特质<code>Clone</code>实现，比较前面类型<code>Struct(u8)</code>程序实现，可以了解到两者实现是完全一样的。对于仅仅使用克隆特质<code>Clone</code>，两种类型<code>Struct(u8)</code>和<code>Struct(String)</code>是完全相似的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod struct_string {
    #![allow(unused_variables)]
    #[cfg(feature = &quot;ok&quot;)]
    pub fn adjoin() {
        struct Struct(String);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Struct {
            #[inline]
            fn clone(&amp;self) -&gt; Struct {
                match *self {
                    Struct(ref __self_0_0) =&gt; Struct(::core::clone::Clone::clone(&amp;(*__self_0_0))),
                }
            }
        }
        let instance = Struct(String::from(&quot;Hello&quot;));
        let clone_instance = instance.clone();
        let copy_instance = instance;
        let use_copy_instance = copy_instance;
    }
}
#}</code></pre></pre>
<p>　　下面程序说明了，对于这种类型<code>Struct(String)</code>也是不能转移（move）的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_string.rs
    // ANCHOR = &quot;struct_string-error_02&quot;
    // error[E0382]: use of moved value: `instance`

    #[derive(Clone)]
    struct Struct(String);

    let instance = Struct(String::from(&quot;Hello&quot;));
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // but can NOT move, because without derive *Copy*,
    // and instance live not
    let use_instance = instance;

#}</code></pre></pre>
<h2><a class="header" href="#自定义类型structcncn-str的派生属性" id="自定义类型structcncn-str的派生属性">自定义类型<code>Struct&lt;'cn&gt;(&amp;'cn str)</code>的派生属性</a></h2>
<p>　　对于结构类型<code>Struct&lt;'cn&gt;(&amp;'cn str)</code>的元素是字符串文字类型，只是其类型定义的表达方式上差距比较大，下面给出实现代码。在实际中经常会使用这种类型。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/expand/struct_str.rs
    // #[cfg(feature = &quot;ok&quot;)]

    #[derive(Clone, Copy)]
    struct Struct&lt;'cn&gt;(&amp;'cn str);

    let instance: Struct = Struct(&quot;Hello&quot;);
    let clone_instance = instance.clone();
    let copy_instance = instance;

    // can copy and clone, because derive *Clone*
    // can move, because derive *Copy*,
    // and instance and copy_instance live
    let use_instance = instance;

#}</code></pre></pre>
<p>　　但是，其处理方法上与类型<code>Struct(u8)</code>是完全相同的，通过派生工具展开其代码，可以解释这个问题，把前面展开代码与下面展开代码相比较。</p>
<p>　　该程序派生工具运行结果如下：</p>
<pre><code class="language-rust no_run noplaypen">mod struct_str {
    #![allow(unused_variables)]
    #[cfg(feature = &quot;ok&quot;)]
    pub fn adjoin() {
        struct Struct&lt;'cn&gt;(&amp;'cn str);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl&lt;'cn&gt; ::core::clone::Clone for Struct&lt;'cn&gt; {
            #[inline]
            fn clone(&amp;self) -&gt; Struct&lt;'cn&gt; {
                {
                    let _: ::core::clone::AssertParamIsClone&lt;&amp;'cn str&gt;;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl&lt;'cn&gt; ::core::marker::Copy for Struct&lt;'cn&gt; {}
        let instance: Struct = Struct(&quot;Hello&quot;);
        let clone_instance = instance.clone();
        let use_copy_instance = instance;
        let use_instance = instance;
    }
}
</code></pre>
<h2><a class="header" href="#题外话-15" id="题外话-15">题外话</a></h2>
<h2><a class="header" href="#参考资料-31" id="参考资料-31">参考资料</a></h2>
<ul>
<li><a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2012/07/17/borrowed-pointer-tutorial/">borrowed-pointer-tutorial</a></li>
<li><a href="https://aminb.gitbooks.io/rust-for-c/content/borrowed/index.html">book rust-for-c</a></li>
<li><a href="https://stackoverflow.com/questions/18943513/rust-borrowed-pointers-syntax">rust-borrowed-pointers-syntax</a></li>
<li><a href="https://users.rust-lang.org/t/fighting-the-borrow-checker-in-a-loop/22975">fighting-the-borrow-checker-in-a-loop</a></li>
</ul>
<h1><a class="header" href="#引用reference与指针pointer基本概念" id="引用reference与指针pointer基本概念">引用<code>Reference</code>与指针<code>Pointer</code>基本概念</a></h1>
<h2><a class="header" href="#学习内容-30" id="学习内容-30">学习内容</a></h2>
<ul>
<li>了解和学习引用<code>Reference</code>与指针<code>Pointer</code>概念</li>
</ul>
<h2><a class="header" href="#篇目-35" id="篇目-35">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88Pointer">什么是指针<code>Pointer</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8Reference">什么是引用<code>Reference</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%95%E7%94%A8Reference%E4%B8%8E%E6%8C%87%E9%92%88Pointer">Rust语言的引用<code>Reference</code>与指针<code>Pointer</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A">引用实例解释</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%8B%E7%BB%8DRust%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">介绍Rust的指针类型</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%AF%8Bprettytable-rs%E5%92%8Cripgrep">开发工具：软件篋prettytable-rs和ripgrep</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#什么是指针pointer" id="什么是指针pointer">什么是指针<code>Pointer</code></a></h2>
<p>　　Rust语言技术术语，既有其本身专门的技术术语，如软件篋<code>crate</code>、借用<code>Borrowing</code>和生命周期<code>Lifttime</code>等，也有一般计算机科学技术术语，如变量、类型和指针<code>Pointer</code>等。但是，对于一般技术术语，在Rust语言里也是有不同的内涵意义和实现形式。</p>
<p>　　<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">引用英文</a></p>
<blockquote>
<p>In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. </p>
</blockquote>
<p>直接翻译：在计算机科学中，指针是编程语言的对象，用于存储位于计算机内存中的另一个值的内存地址。</p>
<p>解读：</p>
<ul>
<li>指针是一个对象<code>object</code>或者说实例<code>instance</code>，它是指针类型的对象；</li>
<li>指针也是变量，与其它变量完全一样；</li>
<li>指针变量也绑定一个值，与其它变量绑定不一样的值，它绑定一种特殊值，就是内存地址；</li>
<li>在绑定的内存地址值下，也是一个变量；</li>
</ul>
<h2><a class="header" href="#什么是引用reference" id="什么是引用reference">什么是引用<code>Reference</code></a></h2>
<p>　　<a href="https://de.wikipedia.org/wiki/Referenz_(Programmierung)">引用德文</a></p>
<blockquote>
<p>Eine Referenz ist ein Verweis auf ein Objekt. Eine Referenz ist damit ein Aliasname für ein bereits bestehendes Objekt.</p>
</blockquote>
<p>直接翻译：引用是关于对象的参照物。因此引用是现有对象的别名。</p>
<p>解读：</p>
<ul>
<li>引用是总是与一个对象关联起来的；</li>
<li>从本质上，引用就是相关联的对象，只是表现形式不同而已；</li>
</ul>
<h2><a class="header" href="#rust语言的引用reference与指针pointer" id="rust语言的引用reference与指针pointer">Rust语言的引用<code>Reference</code>与指针<code>Pointer</code></a></h2>
<p>　　在Rust语言里，所有指针都是其自己的类型。且存在很多的指针<code>pointer</code>类型。比如，从Rust语言结构上分析，引用<code>reference</code>类型是一种指针类型，且最简单的指针类型，从内容上分析，每一个指针类型都包含引用的内存地址。引用<code>reference</code>类型的对象是最常见的。下面通过最简单的示意图了解什么是指针概念：</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-05_reference_integer.png" alt="image" /></p>
<p>　　从说明示意图结构上看到，引用<code>reference</code>类型的对象<code>ref_u8</code>与整数u8类型的对象<code>instance</code>是完全一样的，只是其值不同而已。</p>
<p>　　但是Rust语言在处理其值的方法有所不同。这是因为，Rust通常专注于非指针对象的值或者指针对象的引用对象值（即内容中有趣的部分），而不是指针对象的标识（内存地址）。比如下面代码，使用宏println!简单格式打印它们的值都是一样的，只有使用特殊格式，才能打印出引用对象的值，即内存地址。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let instance = 42_u8;
let ref_u8 = &amp;instance;
println!(&quot;{}&quot;, instance);
println!(&quot;{}&quot;, ref_u8);
println!(&quot;{:p}&quot;, ref_u8);
#}</code></pre></pre>
<p>　　Rust语言指针类型可以分为三大类：引用（包括<a href="https://doc.rust-lang.org/reference/types/pointer.html">共享引用和可变引用</a>）、<a href="https://doc.rust-lang.org/guide-pointers.html">原始引用</a>和智能引用<code>smart pointer</code>。其中前面两类类是Rust语言本身的，而第三类是属于标准库的。这里重点说明共享引用和原始引用。</p>
<p>　　Ⓘ　共享引用指向其他值所拥有的内存。当创建共享引用值时，引用将防止该值的直接改变。除了下面说明的原始指针之外，Rust语言其他指针都是安全的，并且都具有其生命周期。</p>
<p>　　Ⓘ　原始指针是没有安全性保证的指针。</p>
<p>　　在Rust代码中通常不提倡和不鼓励使用原始指针。Rust语言的原始指针与C语言的指针是等效的。原始指针可以为null，也可以指向垃圾，它们也没有生命周期。</p>
<p>　　为了以后说明问题简单化，我们把上面示意图统一成如下形式：</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-04_reference_integer.png" alt="image" /></p>
<h2><a class="header" href="#引用实例解释" id="引用实例解释">引用实例解释</a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-08_reference_str.png" alt="image" /></p>
<p>　　借助于上面两个引用和一个原始引用的示意图，理解下面相关代码的意义。</p>
<p>　　在函数<code>main()</code>里，一共有四段代码，前面两段代码形成了上面示意图内容，后面两段代码是获取它们的地址，以便说明问题。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/type_ref/mod.rs
    // Function use_references_simple()

    let instance: &amp;str = &quot;Hello&quot;;
    let instance = &quot;Hello&quot;;

    let copy_instance: &amp;str = instance;
    let copy_instance = instance;

    println!(&quot;instance reference address = {:p}&quot;, instance);
    println!(&quot;copy_instance reference address = {:p}&quot;, copy_instance);

    println!(&quot;instance address = {:p}&quot;, &amp;instance);
    println!(&quot;copy_instance address = {:p}&quot;, &amp;copy_instance);

#}</code></pre></pre>
<p>　　第一段的两行代码是等效的，实际只需要一行代码就可以了。这代码把字符串文字绑定了变量<code>instance</code>同时，也形成了原始指针，变量<code>instance</code>的地址值指向了原始指针的地址。</p>
<p>　　第二段的两行代码也是等效的，实际只需要一行代码就可以了。这代码把变量<code>instance</code>绑定到新变量<code>copy_instance</code>，这种绑定方式Rust语言称之为复制（Copy），这里它不会产生新原始指针，而是指向与变量<code>instance</code>相同的原始指针地址。</p>
<p>　　从下面程序输出结果，也可以得到验证上面的阐述。第一行和第二行的地址就是原始指针的内存地址，而第三行和第四行的地址是两个引用变量自身的内存地址，注意，它们不是变量的内容值（内存地址）。</p>
<pre><code>───────┬──────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼──────────────────────────────────────────────────────────────────────────
   1   │ instance reference address = 0x101c39b20
   2   │ copy_instance reference address = 0x101c39b20
   3   │ instance address = 0x7fff5dfe81a0
   4   │ copy_instance address = 0x7fff5dfe81c0
───────┴──────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#题外话-16" id="题外话-16">题外话</a></h2>
<h3><a class="header" href="#介绍rust的指针类型列表" id="介绍rust的指针类型列表">介绍Rust的指针类型列表</a></h3>
<table><thead><tr><th>种类</th><th>类型</th><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td>共享引用</td><td>&amp;T</td><td>引用<code>Reference</code></td><td>允许一个或者多个引用来类型T</td></tr>
<tr><td>可变引用</td><td>&amp;mut T</td><td>可变引用<code>Mutable Reference</code></td><td>仅允许单个引用来读和写类型T</td></tr>
<tr><td>智能引用</td><td>Box<T></td><td>Box指针</td><td>处于堆上类型T的指针类型，该类型只能有单个所有者，它可以读取和写入类型T。</td></tr>
<tr><td>智能引用</td><td>Rc<T></td><td>参考计数指针</td><td>处于堆上类型T的指针类型，该类型可以有多个所有者，它们可以读取类型T。</td></tr>
<tr><td>智能引用</td><td>Arc<T></td><td>核参考计数指针</td><td>与类型Rc<T>一样，但适用于在线程之间安全共享</td></tr>
<tr><td>原始引用</td><td>*const T</td><td>原始指针<code>Raw pointer</code></td><td>不安全地读取访问类型T</td></tr>
<tr><td>原始引用</td><td>*mut T</td><td>可变原始指针<code>Mutable raw pointer</code></td><td>不安全地读取和写入访问类型T</td></tr>
</tbody></table>
<p><img src="hello-borrowing/../../hello-borrowing/images/rust_container_pointer.png" alt="image" /></p>
<h3><a class="header" href="#开发工具软件篋prettytable-rs" id="开发工具软件篋prettytable-rs">开发工具：软件篋prettytable-rs</a></h3>
<p>　　使用工具软件篋prettytable-rs可以使得程序输出更加美观。</p>
<p>　　为了使用该工具，需要将下面代码放入文件Cargo.toml的<code>[dependencies]</code>段里：</p>
<pre><code>prettytable-rs = &quot;0.8.0&quot;
</code></pre>
<p>　　具体使用实例代码如下：</p>
<pre><code class="language-rust no_run noplaypen">    // File: lib-hello/src/other/crate_tools/mod.rs
    // Function use_prettytable()

    let instance = &quot;Hello&quot;;

    let copy_instance = instance;

    let table = table!(
        [&quot;Name&quot;, &quot;Value&quot;, &quot;Remark&quot;],
        [
            &quot;instance reference address&quot;,
            format!(&quot;{:p}&quot;, instance),
            &quot;is equal to the following line&quot;
        ],
        [
            &quot;copy_instance reference address&quot;,
            format!(&quot;{:p}&quot;, copy_instance),
            &quot;&quot;
        ],
        [
            &quot;instance address&quot;,
            format!(&quot;{:p}&quot;, &amp;instance),
            &quot;is not equal to the following line&quot;
        ],
        [&quot;copy_instance address&quot;, format!(&quot;{:p}&quot;, &amp;copy_instance), &quot;&quot;]
    );

    table.printstd();

</code></pre>
<p>　　程序输出结果：</p>
<pre><code>───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ +---------------------------------+----------------+------------------------------------+
   2   │ | Name                            | Value          | Remark                             |
   3   │ +---------------------------------+----------------+------------------------------------+
   4   │ | instance reference address      | 0x104f58ba0    | is equal to the following line     |
   5   │ +---------------------------------+----------------+------------------------------------+
   6   │ | copy_instance reference address | 0x104f58ba0    |                                    |
   7   │ +---------------------------------+----------------+------------------------------------+
   8   │ | instance address                | 0x7fff5ad3fa50 | is not equal to the following line |
   9   │ +---------------------------------+----------------+------------------------------------+
  10   │ | copy_instance address           | 0x7fff5ad3fa60 |                                    |
  11   │ +---------------------------------+----------------+------------------------------------+
───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#参考资料-32" id="参考资料-32">参考资料</a></h2>
<ul>
<li><a href="https://crates.io/crates/chars">crate chars</a></li>
<li><a href="https://stackoverflow.com/questions/27150652/how-can-i-get-an-array-or-a-slice-from-a-raw-pointer">how-can-i-get-an-array-or-a-slice-from-a-raw-pointer</a></li>
<li><a href="https://users.rust-lang.org/t/mutation-slice-from-raw-pointer/19912">mutation-slice-from-raw-pointer</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html">std slice fn.from_raw_parts</a></li>
<li><a href="https://stackoverflow.com/questions/27852613/why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po">why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po</a></li>
<li><a href="https://shahuwang.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust%20Pointers.html">Rust的指针类型</a> </li>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/doc-02-21-2015/book/pointers.html#cheat-sheet">pointers cheat-sheet</a></li>
<li><a href="http://chenju2k6.github.io/blog/2019/05/rustlearn">Rust learning notes</a></li>
<li><a href="https://medium.com/@orbitalK/why-the-machine-b9803a77fa29">why-the-machine</a></li>
</ul>
<h1><a class="header" href="#引用类型与原始指针解释" id="引用类型与原始指针解释">引用、类型与原始指针解释</a></h1>
<h2><a class="header" href="#学习内容-31" id="学习内容-31">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言引用<code>Reference</code>、类型与原始指针<code>Pointer</code>关系</li>
</ul>
<h2><a class="header" href="#篇目-36" id="篇目-36">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Bstr%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E5%9B%BE">引用类型<code>&amp;str</code>与原始指针关系图</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Bstring%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E5%9B%BE">引用类型<code>&amp;String</code>与原始指针关系图</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E3%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A">引用、类型与原始指针解释</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7chars">开发工具<code>Cha(rs)</code></a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%AF%8Bripgrep">开发工具：软件篋<code>ripgrep</code></a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#引用类型str与原始指针关系图" id="引用类型str与原始指针关系图">引用类型<code>&amp;str</code>与原始指针关系图</a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-07-pointers.png" alt="image" /></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/raw_pointer/mod.rs
    // Function: use_raw_pointer_str()

    use std::slice;
    println!();
    let instance: String = String::from(&quot;Hello&quot;);
    let ref_raw: *const u8 = instance.as_ptr();
    println!(&quot;instance value = {}&quot;, instance);
    println!(&quot;instance reference raw address = {:?}&quot;, ref_raw);

    println!();
    let ref_str: &amp;str = &amp;instance;
    let ref_str = instance.as_str();
    let ref_str: &amp;str = instance.as_str();
    let ref_str: &amp;str = &amp;instance[0..=4];
    println!(&quot;ref_str value = {}&quot;, ref_str);
    println!(&quot;ref_str owned address = {:p}&quot;, ref_str);
    let ref_raw_str: *const u8 = ref_str.as_ptr();

    assert_eq!(ref_raw, ref_raw_str);

    println!();
    let ref_slice: &amp;[*const u8] = unsafe { slice::from_raw_parts(&amp;ref_raw, 5) };
    dbg!(ref_slice);

    assert_eq!(&amp;ref_raw, &amp;ref_slice[0]);

    println!();
    let u8_slice: &amp;[u8] = unsafe { slice::from_raw_parts(ref_raw, 5) };
    dbg!(u8_slice);

#}</code></pre></pre>
<h3><a class="header" href="#第一段代码绑定字符串string类型的变量instance" id="第一段代码绑定字符串string类型的变量instance">第一段代码：绑定字符串<code>String</code>类型的变量<code>instance</code></a></h3>
<pre><code class="language-rust no_run noplaypen">    println!();
    let instance: String = String::from(&quot;Hello&quot;);
    let ref_raw: *const u8 = instance.as_ptr();
    println!(&quot;instance value = {}&quot;, instance);
    println!(&quot;instance reference raw address = {:?}&quot;, ref_raw);
</code></pre>
<p>　　在这一段代码里，第一个<code>let</code>绑定了字符串<code>String</code>类型变量<code>instance</code>。这样就产生了上面图的变量<code>instance</code>及其原始指针。</p>
<p>　　字符串<code>String</code>类型由三个部分组成：指向原始指针的指针地址、其长度和容量。该指针地址指向内部缓冲字符串（buffer string），用于存储其数据。</p>
<p>　　在这一段代码里，第二个<code>let</code>绑定了<code>*const u8</code>类型变量<code>ref_raw</code>。其中方法<code>as_ptr()</code>功能是将字符串切片转换为原始指针。</p>
<h3><a class="header" href="#第二段代码绑定字符串文字str类型的变量instance" id="第二段代码绑定字符串文字str类型的变量instance">第二段代码：绑定字符串文字<code>&amp;str</code>类型的变量<code>instance</code></a></h3>
<pre><code class="language-rust no_run noplaypen">    println!();
    let ref_str: &amp;str = &amp;instance;
    let ref_str = instance.as_str();
    let ref_str: &amp;str = instance.as_str();
    let ref_str: &amp;str = &amp;instance[0..=4];
    println!(&quot;ref_str value = {}&quot;, ref_str);
    println!(&quot;ref_str owned address = {:p}&quot;, ref_str);
    let ref_raw_str: *const u8 = ref_str.as_ptr();
</code></pre>
<p>　　在这一段代码里，前面四个<code>let</code>绑定了字符串文字<code>＆str</code>类型变量<code>ref_str</code>，它们是完全等效的。其中方法<code>as_str()</code>功能是提取包含整个<code>String</code>的字符串切片。</p>
<p>　　在这一段代码里，最后的<code>let</code>绑定了<code>*const u8</code>类型变量<code>ref_raw_str</code>。特别需要注意的是，变量<code>ref_raw_str</code>也是原始指针的地址。</p>
<h3><a class="header" href="#第三段代码第一次验证原始指针地址" id="第三段代码第一次验证原始指针地址">第三段代码：第一次验证原始指针地址</a></h3>
<p>　　这里将验证，第一段代码和第二段代码的原始指针变量<code>ref_raw</code>和<code>ref_raw_str</code>的地址是相等的。</p>
<pre><code class="language-rust no_run noplaypen">    assert_eq!(ref_raw, ref_raw_str);
</code></pre>
<h3><a class="header" href="#第四段代码原始指针内存地址的数组切片" id="第四段代码原始指针内存地址的数组切片">第四段代码：原始指针内存地址的数组切片</a></h3>
<p>　　在这一段代码里，使用了关键词<code>unsafe</code>，然后启动一个包含不安全代码的新代码块。该代码块存在方法from_raw_parts()，它是根据原始指针的引用及其长度返回一个内存地址数组切片。这数组切片的每一项是字符串其中一个字符的内存地址。</p>
<pre><code class="language-rust no_run noplaypen">    println!();
    let ref_slice: &amp;[*const u8] = unsafe { slice::from_raw_parts(&amp;ref_raw, 5) };
    dbg!(ref_slice);
</code></pre>
<h3><a class="header" href="#第五段代码第二次验证原始指针地址" id="第五段代码第二次验证原始指针地址">第五段代码：：第二次验证原始指针地址</a></h3>
<p>　　这里将验证，两个原始指针，第一段代码的变量<code>ref_raw</code>和第四段代码数组切片<code>ref_slice</code>的第一项的地址是相等的。</p>
<pre><code class="language-rust no_run noplaypen">    assert_eq!(&amp;ref_raw, &amp;ref_slice[0]);
</code></pre>
<h3><a class="header" href="#第六段代码原始指针字符值的数组切片" id="第六段代码原始指针字符值的数组切片">第六段代码：原始指针字符值的数组切片</a></h3>
<p>　　在这一段代码里，使用了关键词<code>unsafe</code>，然后启动一个包含不安全代码的新代码块。该代码块存在方法from_raw_parts()，它是根据原始指针及其长度返回一个类型u8数组切片。这类型u8数组切片的每一项是字符串其中的一个字符值。</p>
<pre><code class="language-rust no_run noplaypen">    println!();
    let u8_slice: &amp;[u8] = unsafe { slice::from_raw_parts(ref_raw, 5) };
    dbg!(u8_slice);
</code></pre>
<h3><a class="header" href="#程序输出结果" id="程序输出结果">程序输出结果</a></h3>
<p>　　该程序输出结果如下，可以比较上面的阐述：</p>
<pre><code class="language-bash">[bin-hello/examples/use_raw_pointer_str.rs:35] ref_slice = [
    0x00007fa772403730,
    0x00000001034db528,
    0x0000000000000002,
    0x0000000000000000,
    0x00007fff5c750d80,
]
[bin-hello/examples/use_raw_pointer_str.rs:45] u8_slice = [
    72,
    101,
    108,
    108,
    111,
]
───────┬─────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼─────────────────────────────────────────────────────────────────────────
   1   │ 
   2   │ instance value = Hello
   3   │ instance reference raw address = 0x7fa772403730
   4   │ 
   5   │ ref_str value = Hello
   6   │ ref_str owned address = 0x7fa772403730
   7   │ 
   8   │ 
───────┴─────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#引用类型string与原始指针关系图" id="引用类型string与原始指针关系图">引用类型<code>&amp;String</code>与原始指针关系图</a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-01-pointers.png" alt="image" /></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/raw_pointer/mod.rs
    // Function: use_raw_pointer_string()
    
    use std::slice;
    println!();
    let instance: String = String::from(&quot;Hello&quot;);
    let ref_raw = instance.as_ptr();
    println!(&quot;instance value = {}&quot;, instance);
    println!(&quot;instance reference raw address = {:?}&quot;, ref_raw);

    println!();
    let ref_string: &amp;String = &amp;instance;
    let ref_string = &amp;instance;
    println!(&quot;ref_string value = {}&quot;, ref_string);
    println!(&quot;ref_string owned address = {:p}&quot;, ref_string);
    let ref_raw_string: *const u8 = ref_string.as_ptr();

    assert_eq!(ref_raw, ref_raw_string);

    println!();
    let ref_slice = unsafe { slice::from_raw_parts(&amp;ref_raw, 5) };
    dbg!(ref_slice);

    assert_eq!(&amp;ref_raw, &amp;ref_slice[0]);

    println!();
    let u8_slice = unsafe { slice::from_raw_parts(ref_raw, 5) };
    dbg!(u8_slice);

#}</code></pre></pre>
<h3><a class="header" href="#第二段代码绑定字符串引用string类型的变量instance" id="第二段代码绑定字符串引用string类型的变量instance">第二段代码：绑定字符串引用<code>&amp;String</code>类型的变量<code>instance</code></a></h3>
<pre><code class="language-rust no_run noplaypen">    println!();
    let ref_string: &amp;String = &amp;instance;
    let ref_string = &amp;instance;
    println!(&quot;ref_string value = {}&quot;, ref_string);
    println!(&quot;ref_string owned address = {:p}&quot;, ref_string);
    let ref_raw_string: *const u8 = ref_string.as_ptr();
</code></pre>
<p>　　这是唯一一段代码与前面实例代码不同的。在这一段代码里，前面两个<code>let</code>绑定了字符串引用<code>&amp;String</code>类型的变量<code>ref_string</code>，它们是完全等效的。特别需要指出的是，在关键词<code>let</code>等式右边类型定义有时候是必要的，尽管这个实例可以省略，但是在上面实例里，就是必须的。</p>
<p>　　在这一段代码里，最后的<code>let</code>绑定了<code>*const u8</code>类型变量<code>ref_raw_string</code>。</p>
<h3><a class="header" href="#程序输出结果-1" id="程序输出结果-1">程序输出结果</a></h3>
<p>　　该程序输出结果如下。比较上面实例结果，可以看到：在这个实例结果只有两个内存地址是一样的，而上面实例有三个内存地址是完全相同的。上面两个结构图就是示意这个结果。</p>
<pre><code>[bin-hello/examples/use_raw_pointer_string.rs:32] slice = [
    0x00007fac6ac03770,
    0x0000000101bc4520,
    0x0000000000000002,
    0x0000000000000000,
    0x00007fff5e066ca0,
]
[bin-hello/examples/use_raw_pointer_string.rs:41] slice = [
    72,
    101,
    108,
    108,
    111,
]
───────┬─────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼─────────────────────────────────────────────────────────────────────────
   1   │ 
   2   │ instance value = Hello
   3   │ instance reference raw address = 0x7fac6ac03770
   4   │ 
   5   │ ref_string value = Hello
   6   │ ref_string owned address = 0x7fff5e066ca0
   7   │ 
   8   │ 
───────┴─────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#引用类型与原始指针解释-1" id="引用类型与原始指针解释-1">引用、类型与原始指针解释</a></h2>
<p>　　上面两个实例有什么不同？或者说，引用类型<code>&amp;String</code>与引用类型<code>&amp;str</code>的区别在哪里？</p>
<p>　　引用类型<code>&amp;String</code>是通过类型<code>String</code>访问原始指针，而引用类型<code>&amp;str</code>是直接访问原始指针。引用类型<code>&amp;str</code>的方法是Rust语言借用系统的组成部分。这种方法更安全和更快速。我们把上面两个示意图合并到一起，如下所示：</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-06-pointers.png" alt="image" /></p>
<p>　　从下面示意图可以看到，Rust语言的数据类型可以理解为是一种复杂的“引用”类型。引用类型主要是储存内存地址，而数据类型尽管也储存内存地址，但其重点是储存数据。</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-02_references.png" alt="image" /></p>
<h3><a class="header" href="#软件篋chars" id="软件篋chars">软件篋<code>Cha(rs)</code></a></h3>
<p>　　工具<code>Cha(rs)</code>可以显示各种<code>ASCII</code>和<code>Unicode</code>字符/代码指针的名称和编码号。</p>
<pre><code class="language-bash"># install
cargo install chars
# use
chars 'H'
</code></pre>
<h3><a class="header" href="#软件篋ripgrep" id="软件篋ripgrep">软件篋<code>ripgrep</code></a></h3>
<p>　　软件篋<code>ripgrep</code>是一款系统终端的搜索工具，类似于<code>ack</code>和<code>grep</code>。</p>
<pre><code class="language-bash"># install
cargo install ripgrep
# use
ifconfig | rg netmask
</code></pre>
<h2><a class="header" href="#参考资料-33" id="参考资料-33">参考资料</a></h2>
<ul>
<li><a href="https://words.steveklabnik.com/pointers-in-rust-a-guide">pointers-in-rust-a-guide</a></li>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/doc-02-21-2015/book/pointers.html">www.cs.brandeis.edu pointers</a></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html">std string struct.String</a></li>
<li><a href="https://apprize.info/programming/rust/5.html">Programming Rust (2016)</a></li>
<li><a href="http://chenju2k6.github.io/blog/2019/05/rustlearn">rust learn</a></li>
<li><a href="https://users.rust-lang.org/t/which-problems-does-owning-ref-solve/29245/4">which-problems-does-owning-ref-solve</a></li>
<li><a href="https://crates.io/crates/chars">crates chars</a></li>
<li><a href="https://crates.io/crates/ripgrep">crates ripgrep</a></li>
</ul>
<h1><a class="header" href="#应用篋字符串类型借用方法" id="应用篋字符串类型借用方法">应用篋：字符串类型借用方法</a></h1>
<h2><a class="header" href="#学习内容-32" id="学习内容-32">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言类型<code>String</code>借用实例</li>
</ul>
<h2><a class="header" href="#篇目-37" id="篇目-37">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/borrowing-string.html#%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">变量生命周期</a></li>
<li><a href="hello-borrowing/borrowing-string.html#%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B">错误使用变量实例</a></li>
<li><a href="hello-borrowing/borrowing-string.html#%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">借用机制代码实例</a></li>
<li><a href="hello-borrowing/borrowing-string.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/borrowing-string.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7cargo-hack">开发工具<code>cargo-hack</code></a></li>
<li><a href="hello-borrowing/borrowing-string.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#变量生命周期" id="变量生命周期">变量生命周期</a></h2>
<p>　　在官方文档英文解释中，无论是复制特质<code>Copy</code>，还是克隆特质<code>Clone</code>，都使用了动词<code>duplicate</code>，这明确说明了实际运作时，将再产生一份新对象，即：原对象和复制对象。要是没有达到这个目的，就不能称之为复制或者克隆。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let instance = String::from(&quot;Hello&quot;);
let copy_instance = instance;
#}</code></pre></pre>
<p>　　在上面的代码实例里，尽管变量<code>instance</code>和<code>copy_instance</code>是不同的对象，且变量<code>copy_instance</code>是通过所谓”复制“方式产生的，但是它们不能同时使用。这种”复制“没有产生第二个对象，只是改变了对象名称及其内存地址不同而已，所以不是真正的复制功能。</p>
<p>　　下面示意图说明了，从第一行<code>let</code>语句开始到第二行<code>let</code>语句结束，内存数据储存的状态变化过程。</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-10_string.png" alt="image" /></p>
<p>　　在第二个<code>let</code>语句结束以后，变量<code>instance</code>生命周期也就结束了，之后就不能再使用它了。这是因为类型<code>String</code>没有复制特质<code>Copy</code>的实现。要是一种类型实现了复制特质<code>Copy</code>，那么其生命周期还是存在的。</p>
<p>　　例如，类型正整数u8实现了复制特质<code>Copy</code>，使用这种隐式复制方法，该类型就生命周期还是存在的。哪些类型实现了复制特质<code>Copy</code>，请参考<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Rust语言标准库文档</a>。</p>
<p>　　类型正整数<code>u8</code>或者逻辑类型<code>bool</code>等都是实现了复制特质<code>Copy</code>的典型实例，而字符串<code>String</code>和向量Vec<code>等都是没有实现复制特质</code>Copy`的典型实例。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/type_ref/mod.rs
    // Function use_u8_type()

    let instance = 42u8;
    println!(&quot;{}&quot;, instance);
    println!(&quot;{:p}&quot;, &amp;instance);

    let copy_instance = instance;
    println!(&quot;{:p}&quot;, &amp;copy_instance);

    println!(&quot;{}&quot;, instance);
    
#}</code></pre></pre>
<h2><a class="header" href="#错误使用变量实例" id="错误使用变量实例">错误使用变量实例</a></h2>
<p>　　下面程序在方法<code>main()</code>有三段代码。第一段代码创建一个类型<code>String</code>对象<code>instance</code>；第二段代码是一种复制或者拷贝对象的行为，从上面变量生命周期可以知道，第三段代码的变量<code>instance</code>已经成为没有定义的变量。所以，编译器指出其错误，其含意如上所述。Rust语言使用了“移动（move）”，说明变量生命周期的过程。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/string_type/string_str/mod.rs
    // #[cfg(feature = &quot;err_01&quot;)]

    // move occurs because `instance` has type `std::string::String`,
    // which does not implement the `Copy` trait
    let instance = String::from(&quot;hello&quot;);

    // The variable `instance` begin to move here
    let copy_instance = instance;
    // The variable `instance` moved here

    // ERROR: The variable `instance` borrowed here after move
    println!(&quot;{}&quot;, instance);
    println!(&quot;{}&quot;, copy_instance);

#}</code></pre></pre>
<p>　　该程序输出结果如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
error[E0382]: borrow of moved value: `instance`
  --&gt; bin-hello/examples/string_type_str.rs:27:20
   |
19 |     let instance = String::from(&quot;hello&quot;);
   |         -------- move occurs because `instance` has type `std::string::String`, which does not implement the `Copy` trait
...
23 |     let copy_instance = instance;
   |                         -------- value moved here
...
27 |     println!(&quot;{}&quot;, instance);
   |                    ^^^^^^^^ value borrowed here after move
#}</code></pre></pre>
<h2><a class="header" href="#借用机制代码实例" id="借用机制代码实例">借用机制代码实例</a></h2>
<p>　　下面看看Rust如何实现借用方法。这是典型Rust语言的代码。下面程序在方法<code>main()</code>有三段代码。在该方法里，类型<code>String</code>对象<code>instance</code>和<code>borrow_instance</code>始终是有效的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/string_type/string_str/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = String::from(&quot;Hello&quot;);
    let raw_instance = instance.as_str();
    println!(&quot;raw_instance = {:p}&quot;, raw_instance);

    let borrow_instance: &amp;str = &amp;instance;
    println!(&quot;borrow_instance = {:p}&quot;, borrow_instance);

    println!(&quot;{}&quot;, instance);
    println!(&quot;{}&quot;, borrow_instance);

#}</code></pre></pre>
<p>　　与前面代码实例一样，第一段代码创建一个类型<code>String</code>对象<code>instance</code>；第二段代码也是一种复制或者拷贝对象的行为，但是该对象的类型是引用，这是Rust语言的一种借用机制，所谓”借用“，就是把对象<code>instance</code>的值借过来使用。第三段代码的变量<code>instance</code>和变量<code>borrow_instance</code>还都是可以使用的。</p>
<p>　　下面示意图告诉我们，程序代码对象的内存储存结构。</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-11_string.png" alt="image" /></p>
<p>　　该程序输出结果如下，从这个结果可以看到两个内存是完全一样的，这个内存地址就是原始指针的地址。</p>
<pre><code class="language-bash">───────┬────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼────────────────────────────────────────────────────────────────────
   1   │ raw_instance = 0x7fca1bc03680
   2   │ borrow_instance = 0x7fca1bc03680
   3   │ Hello
   4   │ Hello
───────┴────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#题外话-17" id="题外话-17">题外话</a></h2>
<h3><a class="header" href="#开发工具cargo-hack" id="开发工具cargo-hack">开发工具<code>cargo-hack</code></a></h3>
<p>　　开发工具<code>cargo-hack</code>解决工具<code>cargo</code>某些限制。工具<code>cargo-hack</code>，目前仅在Linux和macOS上进行过测试。在其他平台上可能无法正常工作。</p>
<pre><code class="language-bash">cargo install cargo-hack
</code></pre>
<p>　　对于程序有属性<code>features</code>时，目前工具<code>cargo</code>需要对每一个属性<code>features</code>生成一个命令，而工具<code>cargo-hack</code>只要一个命令就可以运行所有属性<code>features</code>的程序。比如，上面程序<code>examples/string_type_str.rs</code>有两个属性<code>features</code>，这样就要两行不同的命令来执行程序：</p>
<pre><code class="language-bash">clear &amp;&amp; cargo run --example string_type_str --features ok | bat -l rs
clear &amp;&amp; cargo run --example string_type_str --features err
</code></pre>
<p>而使用工具<code>cargo-hack</code>，只需要一行命令：</p>
<pre><code class="language-bash">cargo hack check --example string_type_str --each-feature --no-dev-deps
</code></pre>
<h2><a class="header" href="#参考资料-34" id="参考资料-34">参考资料</a></h2>
<ul>
<li><a href="https://crates.io/crates/cargo-hack">crate cargo-hack</a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">trait std::marker::Copy</a></li>
</ul>
<h1><a class="header" href="#应用篋方法借用实例" id="应用篋方法借用实例">应用篋：方法借用实例</a></h1>
<h2><a class="header" href="#学习内容-33" id="学习内容-33">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言方法借用实例</li>
</ul>
<h2><a class="header" href="#篇目-38" id="篇目-38">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/borrowing-fn.html#%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%9F%E7%94%A8%E5%AE%9E%E4%BE%8B">实现复制特质<code>Copy</code>类型的借用实例</a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%9F%E7%94%A8%E5%AE%9E%E4%BE%8B">未实现复制特质<code>Copy</code>类型的借用实例</a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">借用机制代码实例</a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/borrowing-fn.html#rust%E8%AF%AD%E8%A8%80%E4%B8%8B%E6%A8%AA%E6%9D%86_">Rust语言下横杆<code>_</code></a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E5%90%91%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95">向量类型完整定义方法</a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E5%90%91%E9%87%8F%E5%AE%8Fvec">向量宏<code>vec!</code></a></li>
<li><a href="hello-borrowing/borrowing-fn.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#实现复制特质copy类型的借用实例" id="实现复制特质copy类型的借用实例">实现复制特质<code>Copy</code>类型的借用实例</a></h2>
<p>　　在下面程序方法<code>main()</code>的三段代码里，表面上并没看到复制变量<code>num</code>，但是实际上存在变量<code>num</code>的复制。一旦调用方法<code>fn_borrow()</code>，方法内部就进行了复制特质<code>Copy</code>的复制。这是怎么知道的呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/kw_fn/mod.rs
    // Function use_kw_fn_u8()

    fn fn_borrow(_: u8) {}

    let num = 42;
    fn_borrow(num);

    dbg!(num);
    
#}</code></pre></pre>
<p>　　下面程序代码，说明了上面问题。该程序在上面程序基础上，把变量<code>num</code>在调用方法之前之后以及在方法内的内存地址都打印出来。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/kw_fn/mod.rs
    // Function use_kw_fn_u8_ref()

    fn fn_borrow(num: u8) {
        println!(&quot;inside fn = {:p}&quot;, &amp;num);
    }

    let num = 42;
    println!(&quot;Before fn = {:p}&quot;, &amp;num);
    fn_borrow(num);
    println!(&quot;After fn = {:p}&quot;, &amp;num);

    dbg!(num);

#}</code></pre></pre>
<p>　　这是上面程序输出结果。从结果可以看到，在调用方法之前之后变量<code>num</code>内存地址是完全一样的，只是在方法内变量<code>num</code>内存地址是不一样的。这说明方法内部从一开始就复制了变量<code>num</code>，这是因为类型u8复制特质`Copy，所以可以存在这样借用机制。</p>
<pre><code class="language-bash">[bin-hello/examples/use_kw_fn_u8.rs:17] num = 42
───────┬─────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼─────────────────────────────────────────────────────────────────────────
   1   │ Before fn = 0x7fff531fd04f
   2   │ inside fn = 0x7fff531fcf57
   3   │ After fn = 0x7fff531fd04f
───────┴─────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#未实现复制特质copy类型的借用实例" id="未实现复制特质copy类型的借用实例">未实现复制特质<code>Copy</code>类型的借用实例</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/kw_fn/vec_u8/mod.rs
    // #[cfg(feature = &quot;err_01&quot;)]

    fn fn_borrow(vec_u8s: Vec&lt;u8&gt;) {
        println!(&quot;Inside fn = {:p}&quot;, &amp;vec_u8s);
    }

    let vec_instance: Vec&lt;_&gt; = vec![33, 42];
    println!(&quot;Before fn = {:p}&quot;, &amp;vec_instance);
    fn_borrow(vec_instance);
    println!(&quot;After fn = {:p}&quot;, &amp;vec_instance);

    dbg!(vec_instance);

#}</code></pre></pre>
<p>　　在下面的程序里，在执行该程序以后，可以看到错误提示信息，这是因为类型<code>Vec&lt;u8&gt;</code>没有实现复制特质<code>Copy</code>，而方法<code>fn_borrow</code>里面还是执行了变量的复制，相当于执行了下面一行代码：</p>
<pre><code class="language-rust no_run noplaypen">let vec_u8s = vec_instance;
</code></pre>
<p>　　这是上面程序输出错误结果：</p>
<pre><code class="language-bash">error[E0382]: borrow of moved value: `vec_instance`
  --&gt; bin-hello/examples/kw_fn_vec_u8.rs:32:22
   |
29 |     let vec_instance = Vec::new();
   |         ------------ move occurs because `vec_instance` has type `std::vec::Vec&lt;u8&gt;`, which does not implement the `Copy` trait
30 |     println!(&quot;{:p}&quot;, &amp;vec_instance);
31 |     fn_borrow(vec_instance);
   |               ------------ value moved here
32 |     println!(&quot;{:p}&quot;, &amp;vec_instance);
   |                      ^^^^^^^^^^^^^ value borrowed here after move
</code></pre>
<p>　　上面程序类型<code>Vec&lt;u8&gt;</code>是可以实现复制特质<code>Copy</code>，但是怎么样可以简单这种功能实现呢？</p>
<h2><a class="header" href="#借用机制代码实例-1" id="借用机制代码实例-1">借用机制代码实例</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/kw_fn/vec_u8/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    fn fn_borrow(vec_u8s: &amp;Vec&lt;u8&gt;) {
        println!(&quot;Inside fn = {:p}&quot;, &amp;vec_u8s);
    }

    let vec_instance: Vec&lt;_&gt; = vec![33, 42];
    println!(&quot;Before fn = {:p}&quot;, &amp;vec_instance);
    fn_borrow(&amp;vec_instance);
    println!(&quot;After fn = {:p}&quot;, &amp;vec_instance);

    dbg!(vec_instance);

#}</code></pre></pre>
<p>　　上面程序代码，使用了Rust语言的借用机制，实现了变量的借用，以达到传递变量值到函数或者方法。在Rust语言内部，存在一行下面代码，通过传递类型Vec<u8>的引用对象<code>＆vec_instance</code>到方法<code>fn_borrow()</code>，以实现这种借用机制：</p>
<pre><code class="language-rust no_run noplaypen">let vec_u8s = ＆vec_instance;
</code></pre>
<h2><a class="header" href="#题外话-18" id="题外话-18">题外话</a></h2>
<h3><a class="header" href="#rust语言下横杆_" id="rust语言下横杆_">Rust语言下横杆<code>_</code></a></h3>
<p>　　在上面程序中，有两个地方存在下横杆<code>_</code>，这是Rust语言待定符号。比如，下面代码，要是函数或者方法参数还没有确定如何使用，就可以使用这个待定符号下横杆<code>_</code>。</p>
<pre><code class="language-rust no_run noplaypen">fn fn_borrow(_: u8) {}
</code></pre>
<p>　　下面是另外一个代码实例，我们知道，接下来该变量会存在类型定义，如作为方法参数使用该变量，也可以使用这个待定符号下横杆<code>_</code>。但是要是没有作为方法参数和其他使用该变量，编译器就会报错。</p>
<pre><code class="language-rust no_run noplaypen">let vec_instance :Vec&lt;_&gt; = vec![33, 42];
</code></pre>
<h3><a class="header" href="#向量类型完整定义方法" id="向量类型完整定义方法">向量类型完整定义方法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/kw_fn/vec_u8/mod.rs
    // #[cfg(feature = &quot;cp&quot;)]

    fn fn_borrow(vec_u8s: &amp;Vec&lt;u8&gt;) {
        println!(&quot;Inside fn = {:p}&quot;, &amp;vec_u8s);
    }

    let mut vec_instance: Vec&lt;u8&gt; = Vec::&lt;u8&gt;::new();
    vec_instance.push(33);
    vec_instance.push(42);

    println!(&quot;Before fn = {:p}&quot;, &amp;vec_instance);
    fn_borrow(&amp;vec_instance);
    println!(&quot;After fn = {:p}&quot;, &amp;vec_instance);

    dbg!(vec_instance);

#}</code></pre></pre>
<p>　　上面程序方法｀main()｀第二段的第一行代码，是类型向量最完整的表达形式，它也可以简写为下面这种常见的一行代码。同时也要注意到，前面代码里方法参数也是简写形式，而上面程序代码也是完整形式。这样定义对象变量的类型<code>Vec::&lt;u8&gt;</code>形式，与方法参数定义的引用类型<code>&amp;Vec::&lt;u8&gt;</code>形式具有其一致性。</p>
<pre><code class="language-rust no_run noplaypen">let mut vec_instance = Vec::new();
</code></pre>
<h3><a class="header" href="#向量宏vec" id="向量宏vec">向量宏<code>vec!</code></a></h3>
<p>　　在前面程序代码里，可以看到类型向量宏vec!，这是创建其对象的宏，它类似于打印宏<code>println!</code>。上面一行宏vec!代码，相当于下面的三行代码。当然其中不同的是，下面类型向量对象是可变绑定方式，而前面的向量对象是不可变绑定方式。Rust语言为我们创建类型向量对象提供了两种不同的方式：不可变和可变的向量绑定对象。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut vec_instance: Vec&lt;u8&gt; = Vec::&lt;u8&gt;::new();
    vec_instance.push(33);
    vec_instance.push(42);
#}</code></pre></pre>
<p>　　下面我们把上面代码整理如下，目的便于与类型字符串进行比较：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/mutable/mut_new/mod.rs
    // Function use_vec_mut_new()

    let immut_vec: Vec&lt;_&gt; = vec![33, 42];
    dbg!(immut_vec);

    let mut mut_vec: Vec&lt;u8&gt; = Vec::&lt;u8&gt;::new();
    mut_vec.push(33);
    mut_vec.push(42);
    dbg!(mut_vec);

#}</code></pre></pre>
<p>　　其实，类型字符串也有同样的功能，只是表达方式不同而已：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/mutable/mut_new/mod.rs
    // Function use_string_mut_new()

    let immut_string = String::from(&quot;Hello&quot;);
    dbg!(immut_string);

    let mut mut_string = String::new();
    mut_string.push_str(&quot;Hello&quot;);
    dbg!(mut_string);

#}</code></pre></pre>
<h2><a class="header" href="#参考资料-35" id="参考资料-35">参考资料</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/25893">Rustdoc: No mention of copy trait for primitive types</a></li>
<li><a href="https://medium.com/@bugaevc/understanding-rust-ownership-borrowing-lifetimes-ff9ee9f79a9c">Understanding Rust: ownership, borrowing, lifetimes</a></li>
</ul>
<h1><a class="header" href="#应用篋闭包借用实例" id="应用篋闭包借用实例">应用篋：闭包借用实例</a></h1>
<h2><a class="header" href="#学习内容-34" id="学习内容-34">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言闭包借用实例</li>
</ul>
<h2><a class="header" href="#篇目-39" id="篇目-39">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/borrowing-closure.html#%E7%90%86%E8%A7%A3rust%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85">理解Rust语言闭包</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E9%97%AD%E5%8C%85%E5%AE%9E%E4%BE%8B">闭包实例</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%89%B9%E8%B4%A8copy%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%9F%E7%94%A8%E5%AE%9E%E4%BE%8B">未实现复制特质<code>Copy</code>类型的借用实例</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">借用机制代码实例</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/borrowing-closure.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#理解rust语言闭包" id="理解rust语言闭包">理解Rust语言闭包</a></h2>
<p>　　闭包（closure）是现代计算机语言发展起来的重要技术，它延伸了传统计算机语言函数的概念。Rust语言中的闭包（也称为lambda表达式或lambda，）是可以捕获封闭环境的函数。传统函数就是一个独立的和重复使用的功能性代码单位，它通过被调用而与其它代码进行交互。而闭包不仅可以被其它代码调用；而且其代码块本身也可以直接与其封闭环境内的代码进行交互，捕获外部环境变量的能力，而这一点传统函数没有这样的功能。</p>
<p>　　闭包与函数比较说明：</p>
<ul>
<li>闭包可以捕获外部环境变量的能力，而函数不能；</li>
<li>传递到闭包的输入参数。使用<code>||</code>，而不是像函数<code>()</code>一样；</li>
<li>闭包代码块也使用函数一样的<code>{}</code>，但是函数是强制性使用，而闭包在一些情况下是可选性使用；</li>
<li>输入参数的类型也是可选的，而非函数是强制的；</li>
<li>闭包不存在闭包名，而函数不能，甚至闭包连绑定变量也可以不要；</li>
<li>调用闭包不仅与函数有完全一样的方式，而且还存在闭包自身特殊方式；</li>
<li>闭包输出的表达方式与函数完全一样；</li>
<li>闭包返回方式与函数完全一样；</li>
</ul>
<p>　　将上面比较说明，对照下面实例代码。方法<code>main()</code>的第二行代码，第一，定义了闭包，且绑定到变量<code>i_am_closure</code>，可以理解为“闭包名”；第二，把第一行代码这种外部变量<code>outside_closure</code>应用到闭包代码块内部；第三，输入参数<code>input_var</code>省略了类型名称，之所以可以省略，是因为第一行代码定义了输入参数的类型。第三行代码里存在调用第二行定义的闭包代码。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let outside_closure = 21u8;
    let i_am_closure = |input_var| -&gt; u8 { input_var + outside_closure };
    println!(&quot;i_am_closure: {}&quot;, i_am_closure(outside_closure));
}
</code></pre></pre>
<h2><a class="header" href="#闭包实例" id="闭包实例">闭包实例</a></h2>
<p>　　通过下面实例来进一步理解闭包使用方法。这个实例看起来比较抽象，这一行代码连一个字母都没有。但这是理解闭包很好的代码。</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    (|__:()|-&gt;(){__})(())
}
</code></pre></pre>
<p>　　通过下面程序代码逐步展开来解析上面程序的含义。程序里每一段代码都是一样的功能，从上到下还原到可以比较理解的代码。</p>
<p>　　需要说明的是，在方法<code>main()</code>里，前面四段代码，既定义了闭包，同时也调用了闭包。只有第五段代码定义与调用分成了两个语句。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/closure/mod.rs
    // Function: use_closure()
    (|__: ()| -&gt; () { __ })(());

    (|input_var: (bool)| -&gt; (bool) { input_var })((true));

    |input_var: (bool)| -&gt; (bool) { input_var }((true));

    let tuple = (true);
    |input_var: (bool)| -&gt; (bool) { input_var }(tuple);

    let tuple = (true);
    let closure_instance = |input_var: (bool)| -&gt; (bool) { input_var };
    closure_instance(tuple);
#}</code></pre></pre>
<h2><a class="header" href="#未实现复制特质copy类型的借用实例-1" id="未实现复制特质copy类型的借用实例-1">未实现复制特质<code>Copy</code>类型的借用实例</a></h2>
<p>　　下面代码说明字符串类型<code>String</code>对象作为闭包参数使用以后，其生命周期结束的实例。变量作为闭包参数使用以后，在闭包里，进行了一次变量的复制，导致了Rust语言所示的移动<code>move</code>，实际上，在闭包完成调用以后，该变量从内存里被剔除掉了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/closure/immut_string/mod.rs
    // #[cfg(feature = &quot;err_01&quot;)]

    let string_instance: String = &quot;Hello&quot;.to_string();

    let closure_instance = |hello: String| println!(&quot;{} Friend!&quot;, hello);
    closure_instance(string_instance);

    println!(&quot;{} World!&quot;, string_instance);

#}</code></pre></pre>
<h2><a class="header" href="#借用机制代码实例-2" id="借用机制代码实例-2">借用机制代码实例</a></h2>
<p>　　解决上面实例的方法，与前面一节函数方法一样，使用引用类型对象。传递到闭包里，而不是类型字符串对象。引用变量对象仅仅是利用了类型字符串对象的内容而已，闭包本身实际上没有与类型字符串对象发生联系。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/closure/immut_string/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let string_instance: String = &quot;Hello&quot;.to_string();

    println!(&quot;Before fn = {:p}&quot;, &amp;string_instance);
    let closure_instance = |hello: &amp;str| {
        println!(&quot;{} Friend!&quot;, hello);
        println!(&quot;Inside fn = {:p}&quot;, &amp;hello);
    };
    closure_instance(&amp;string_instance);
    println!(&quot;After fn = {:p}&quot;, &amp;string_instance);

    println!(&quot;{} World!&quot;, string_instance);

#}</code></pre></pre>
<h2><a class="header" href="#题外话-19" id="题外话-19">题外话</a></h2>
<h2><a class="header" href="#参考资料-36" id="参考资料-36">参考资料</a></h2>
<ul>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/rustbyexample-02-21-2015/tuples.html">www.cs.brandeis.edu tuples</a></li>
<li><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759">Understanding the different types of closures in Rust</a></li>
<li><a href="https://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html">Why Rust Closures are (Somewhat) Hard</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">rust-by-example closures</a></li>
<li></li>
</ul>
<h1><a class="header" href="#应用篋移动关键词move借用实例" id="应用篋移动关键词move借用实例">应用篋：移动关键词<code>move</code>借用实例</a></h1>
<h2><a class="header" href="#学习内容-35" id="学习内容-35">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言移动关键词<code>move</code>借用实例</li>
</ul>
<h2><a class="header" href="#篇目-40" id="篇目-40">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/keyword-move.html#%E7%A7%BB%E5%8A%A8%E5%85%B3%E9%94%AE%E8%AF%8Dmove">移动关键词<code>move</code></a></li>
<li><a href="hello-borrowing/keyword-move.html#%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">借用机制代码实例</a></li>
<li><a href="hello-borrowing/keyword-move.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/keyword-move.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#移动关键词move" id="移动关键词move">移动关键词<code>move</code></a></h2>
<p>　　移动关键词<code>move</code>是转移对象的所有权，实际上是使得该对象失去所有权。类似于函数调用结束以后，会自动转移类型对象的所有权，但不包括引用类型对象。</p>
<p>　　通过比较下面两个程序，可以了解到移动关键词<code>move</code>的表达方法。</p>
<p>　　通过比较下面两个程序，它们唯一区别就是第二个程序多了关键词<code>move</code>。实际运行它们，可以看到，第一个程序正常，而第二个程序出现错误，借此可以理解到移动关键词<code>move</code>的作用。即使是使用对象的引用，也会使得其对象本身失去所有权，更不用说使用对象本身。</p>
<p>　　连使用对象的引用，也失去其对象本身的所有权，这是否与借用机制不一致了？网上有人提出这样的问题。我们下面使用了一个技巧，来解决这个问题。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/closure/kw_move/mod.rs
    // #[cfg(feature = &quot;cp&quot;)]

    let instance = vec![1, 2, 3];

    // borrow this variable `instance`
    (|| {
        (&amp;instance);
    })();
    //|| { (&amp;instance); };

    // ok: x was not moved
    println!(&quot;{:?}&quot;, instance);

#}</code></pre></pre>
<p>　　在下面程序里，也有定义闭包的语句。即使仅使用定义语句，也会出现错误。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/closure/kw_move/mod.rs
    // #[cfg(feature = &quot;err_02&quot;)]

    let instance = vec![1, 2, 3];

    // move this variable `instance`
    (move || {
        (&amp;instance);
    })();
    //( move || (instance.len()) )();
    //move || { (&amp;instance); };
    //move || ( instance.len() );

    // ERROR: x was moved
    println!(&quot;{:?}&quot;, instance);

#}</code></pre></pre>
<h2><a class="header" href="#借用机制代码实例-3" id="借用机制代码实例-3">借用机制代码实例</a></h2>
<p>　　在使用移动关键词<code>move</code>前提下，这是因为有时候需要使得一些变量失去其所有权，而另外一些变量不能失去其所有权。</p>
<p>　　为了使得一些变量不能失去其所有权，而又要借用该变量。解决办法是这样的：为了使得一个对象的借用有效，这时候需要在闭包以前先把该对象引用绑定一个变量，然后把绑定引用对象变量使用到闭包里。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/closure/move_vec/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = vec![1, 2, 3];

    println!(&quot;The variable instance before borrowing: {:?}&quot;, instance);

    let ref_instance = &amp;instance;
    let equal_to_val = move |input_var| input_var == ref_instance;

    println!(&quot;The variable instance after borrowing: {:?}&quot;, instance);

    // use this closure
    let input_instance = vec![1, 2, 3];
    assert!(equal_to_val(&amp;input_instance));

#}</code></pre></pre>
<h2><a class="header" href="#题外话-20" id="题外话-20">题外话</a></h2>
<h2><a class="header" href="#参考资料-37" id="参考资料-37">参考资料</a></h2>
<ul>
<li><a href="https://users.rust-lang.org/t/whats-the-purpose-of-the-move-keyword/16160">What’s the purpose of the move keyword?</a></li>
<li><a href="https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust">What are move semantics in Rust?</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.move.html">std keyword move</a></li>
</ul>
<h1><a class="header" href="#应用篋循环for语句不可变借用实例" id="应用篋循环for语句不可变借用实例">应用篋：循环<code>for</code>语句不可变借用实例</a></h1>
<p>　　在Rust语言里，固定大小类型对象与可变大小类型对象的处理方式常常是不一样的。下面通过固定数组和可变数组的实例说明这个问题。</p>
<h2><a class="header" href="#学习内容-36" id="学习内容-36">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言循环<code>for</code>语句借用实例</li>
</ul>
<h2><a class="header" href="#篇目-41" id="篇目-41">篇目</a></h2>
<p>　　</p>
<ul>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%9F%E7%94%A8%E9%94%99%E8%AF%AF%E5%AE%9E%E4%BE%8B">固定数组的借用错误实例</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B">固定数组的借用机制实例</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%80%9F%E7%94%A8%E9%94%99%E8%AF%AF%E5%AE%9E%E4%BE%8B">可变数组的简单借用错误实例</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B">可变数组的借用机制实例</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95iter%E5%92%8Cinto_iter%E5%8C%BA%E5%88%AB">迭代方法<code>iter()</code>和<code>into_iter()</code>区别</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B">可变数组的迭代借用机制实例</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/borrowing-for-loop.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#固定数组的借用错误实例" id="固定数组的借用错误实例">固定数组的借用错误实例</a></h2>
<p>　　这是一个说明固定数组类型<code>[T;N]</code>借用错误的实例。在循环语句里，不能将固定数组对象<code>instance</code>作为<code>for</code>语句的迭代部分，这是因为固定数组对象本身不是一个迭代器。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_arr/mod.rs
    // #[cfg(feature = &quot;err_01&quot;)]

    let instance = [1u8, 2, 3];

    for item in instance {
        print!(&quot;{:p} &quot;, item);
    }

    println!(&quot;instance array = {:?}&quot;, instance);

#}</code></pre></pre>
<p>　　在编译该程序以后，编译器给出有用的信息提示，如下所示：</p>
<pre><code class="language-bash">...
borrow the array with `&amp;` or call `.iter()` on it to iterate over it(`instance`)
...
= note: arrays are not iterators, but slices like the following are: `&amp;[1, 2, 3]`
...
</code></pre>
<p>　　这些信息告诉我们：</p>
<ul>
<li>借用方法可以使用<code>&amp;</code>或调用方法<code>.iter()</code>；</li>
<li>固定数组<code>array</code>不是迭代器；</li>
</ul>
<p>　　下面利用这些信息，来解决固定数组的借用问题。</p>
<h2><a class="header" href="#固定数组的借用机制实例" id="固定数组的借用机制实例">固定数组的借用机制实例</a></h2>
<p>　　在循环<code>for</code>语句里，对于数组类型，Rust语言提供里几种借用方法。但是对于固定数组和可变数组类型，其方法上略有不同。这里先说明固定数组类型的借用机制实例。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_arr/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = [1u8, 2, 3];
    println!(&quot;{:&gt;17} {} {:p}&quot;, &quot;instance ref&quot;, &quot;=&quot;, &amp;instance);

    print!(&quot;{:&gt;17} {} &quot;, &quot;for ref&quot;, &quot;=&quot;);
    for item in &amp;instance {
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item);
    }
    println!(&quot;&quot;);

    print!(&quot;{:&gt;17} {} &quot;, &quot;for .iter()&quot;, &quot;=&quot;);
    for item in instance.iter() {
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item);
    }
    println!(&quot;&quot;);

    print!(&quot;{:&gt;17} {} &quot;, &quot;for .into_iter()&quot;, &quot;=&quot;);
    for item in instance.into_iter() {
        //let u8_item :u8 = item;  // ERROR: item IS &amp;u8!!!
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item);
    }
    println!(&quot;&quot;);

    println!(&quot;{:&gt;17} {} {:?}&quot;, &quot;instance arr&quot;, &quot;=&quot;, instance);

#}</code></pre></pre>
<p>　　在方法<code>main()</code>里，一共有五段代码，说明如下：</p>
<ul>
<li>中间三段代码就是固定数组的借用方法，三种方法都可以使用；</li>
<li>对于固定数组，三种方法的思路也是一致的，在循环<code>for</code>语句的迭代过程中，通过引用对象遍历其每一个项进行迭代；</li>
<li>最后一行代码可以通过编译，说明了该对象<code>instance</code>还是可以使用的，其生命周期还没有结束，同时可以验证上面借用方法都是可行的。</li>
<li>从该程序下面的输出结果，可以看到，它们的内存地址都是指向相同的原始指针；</li>
<li>当中有些宏<code>print!</code>或者<code>println!</code>只是为了输出结果可以更加容易理解；</li>
</ul>
<p>　　该程序输出结果如下：</p>
<pre><code class="language-bash">───────┬───────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼───────────────────────────────────────────────────────────────────────
   1   │      instance ref = 0x7fff567a7c5d
   2   │           for ref = 0x7fff567a7c5d 0x7fff567a7c5e 0x7fff567a7c5f 
   3   │       for .iter() = 0x7fff567a7c5d 0x7fff567a7c5e 0x7fff567a7c5f 
   4   │  for .into_iter() = 0x7fff567a7c5d 0x7fff567a7c5e 0x7fff567a7c5f 
   5   │      instance arr = [1, 2, 3]
───────┴───────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#可变数组的简单借用错误实例" id="可变数组的简单借用错误实例">可变数组的简单借用错误实例</a></h2>
<p>　　下面是一个可变数组的循环<code>for</code>语句实例。注意，这个实例仅仅说明，与固定数组错误不同的是，可变数组对象是一个迭代器。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn adjoin() {
    // File: ./bin-hello/examples/for_loop/for_vec/mod.rs
    // #[cfg(feature = &quot;cp&quot;)]

    let instance = vec![1, 2, 3];
    println!(&quot;{:&gt;17} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;17} {} &quot;, &quot;for u8&quot;, &quot;=&quot;);
    for item in instance {
        let u8_item: u8 = item;
        print!(&quot;{:p} &quot;, &amp;u8_item);
    }
    println!(&quot;&quot;);

#}</code></pre></pre>
<p>　　可能有人发现，上面程序的下面输出结果内存地址不一样，这是为什么，是因为一旦可变数组对象作为迭代器，在循环<code>for</code>语句被使用以后，该对象就被转移了（moved），自然它们的内存地址就不一样了。</p>
<pre><code class="language-bash">───────┬────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼────────────────────────────────────────────────────────────────────────
   1   │      instance raw = 0x7f8779500b80
   2   │            for u8 = 0x7fff54a6b05f 0x7fff54a6b05f 0x7fff54a6b05f 
───────┴────────────────────────────────────────────────────────────────────────
</code></pre>
<p>　　接下来才是一个可变数组的借用错误实例，只是在上面实例中多增加了最后一行代码。只是一旦将其作为迭代器，其生命周期就解释了。这样就出现下面出现所谓的“借用错误”。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_vec/mod.rs
    // #[cfg(feature = &quot;err_02&quot;)]

    let instance = vec![1, 2, 3];
    println!(&quot;{:&gt;17} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;17} {} &quot;, &quot;for u8&quot;, &quot;=&quot;);
    for item in instance {
        let u8_item: u8 = item;
        print!(&quot;{:p} &quot;, &amp;u8_item);
    }
    println!(&quot;&quot;);

    println!(&quot;{:&gt;17} {} {:?}&quot;, &quot;instance vec&quot;, &quot;=&quot;, instance); // error here

#}</code></pre></pre>
<h2><a class="header" href="#可变数组的借用机制实例" id="可变数组的借用机制实例">可变数组的借用机制实例</a></h2>
<p>　　下面我们使用可变数组对象作为迭代器，解决可变数组的借用问题。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_vec/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = vec![1u8, 2, 3];
    println!(&quot;{:&gt;17} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;17} {} &quot;, &quot;for ref&quot;, &quot;=&quot;);
    for item in &amp;instance {
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item); // OK: item IS Pointer
    }
    println!(&quot;&quot;);

    println!(&quot;{:&gt;17} {} {:?}&quot;, &quot;instance vec&quot;, &quot;=&quot;, instance);

#}</code></pre></pre>
<p>　　上面实例在借用机制方法下，可以看到该程序输出的结果，它们内存地址是相同的，这是因为它们仅仅借用而已。</p>
<p>　　该程序输出结果如下：</p>
<pre><code class="language-bash">───────┬────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼────────────────────────────────────────────────────────────────────────
   1   │      instance raw = 0x7f8a504035e0
   2   │           for ref = 0x7f8a504035e0 0x7f8a504035e1 0x7f8a504035e2 
   3   │      instance vec = [1, 2, 3]
───────┴────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#迭代方法iter和into_iter区别" id="迭代方法iter和into_iter区别">迭代方法<code>iter()</code>和<code>into_iter()</code>区别</a></h2>
<p>　　在上面固定数组对象实例中，我们使用了迭代方法<code>into_iter()</code>，运行是正常的，为什么到了可变数组对象就不可编译了呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_vec_iter/mod.rs
    // #[cfg(feature = &quot;err_03&quot;)]

    let instance = vec![1, 2, 3];
    println!(&quot;{:&gt;13} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;13} {} &quot;, &quot;for into_iter&quot;, &quot;=&quot;);
    for item in instance.into_iter() {
        let u8_item: u8 = item;
        print!(&quot;{:p} &quot;, &amp;u8_item);
    }
    println!(&quot;&quot;);

    println!(&quot;{:&gt;13} {} {:?}&quot;, &quot;instance vec&quot;, &quot;=&quot;, instance);

#}</code></pre></pre>
<p>　　下面分析其原因。Rust语言提供了三个迭代方法。这里代码仅仅说明其中两个方法<code>iter()</code>和<code>into_iter()</code>，但是这里把三个方法功能说明如下：</p>
<ul>
<li>方法<code>iter()</code>通过迭代器的引用对象，遍历其每一个项；</li>
<li>方法<code>into_iter()</code>将迭代器移至新迭代器，然后通过迭代器的对象，遍历其每一个项；</li>
<li>方法<code>iter_mut()</code>通过迭代器的可变引用对象，遍历其每一个项；</li>
</ul>
<p>　　从上面三个方法的功能，可以知道，方法<code>into_iter()</code>的迭代手段不是借用，而是直接消费了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_vec_iter/mod.rs
    // #[cfg(feature = &quot;cp&quot;)]

    let instance = vec![1u8, 2, 3];
    println!(&quot;{:&gt;13} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;13} {} &quot;, &quot;for into_iter&quot;, &quot;=&quot;);
    for item in instance.into_iter() {
        let u8_item: u8 = item;
        //print!(&quot;{:p} &quot;, item); // ERROR: item IS {integer}, NOT Pointer
        print!(&quot;{:p} &quot;, &amp;u8_item);
    }
    println!(&quot;&quot;);

    //println!(&quot;{:&gt;13} {} {:?}&quot;, &quot;instance vec&quot;, &quot;=&quot;, instance);

#}</code></pre></pre>
<p>　　通过下面实例输出结果来分析方法<code>into_iter()</code>：</p>
<ul>
<li>循环语句变量<code>item</code>不是引用对象<code>&amp;u8</code>，而是类型<code>u8</code>对象；</li>
<li>要是把上面程序循环语句的注视去掉，就会出现错误，这再次说明，变量<code>item</code>是类型<code>u8</code>对象，同时也说明了方法<code>into_iter()</code>使用遍历其每一个项都是类型<code>u8</code>对象，而不是方法<code>iter()</code>一样的类型<code>&amp;u8</code>引用对象；</li>
<li>循环语句内外内存地址是不同的；</li>
</ul>
<p>　　第二个程序输出结果如下：</p>
<pre><code class="language-bash">───────┬───────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼───────────────────────────────────────────────────────────────────────
   1   │ instance raw = 0x7fb3604035e0
   2   │for into_iter = 0x7fff5ad6705f 0x7fff5ad6705f 0x7fff5ad6705f 
───────┴───────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#可变数组的迭代借用机制实例" id="可变数组的迭代借用机制实例">可变数组的迭代借用机制实例</a></h2>
<p>　　通过上面分析，下面实例代码就比较简单了。它是使用方法<code>iter()</code>，实现循环语句<code>for</code>的迭代借用机制。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/for_loop/for_vec_iter/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = vec![1u8, 2, 3];
    println!(&quot;{:&gt;13} {} {:p}&quot;, &quot;instance raw&quot;, &quot;=&quot;, instance.as_ptr());

    print!(&quot;{:&gt;13} {} &quot;, &quot;for vec ref&quot;, &quot;=&quot;);
    for item in &amp;instance {
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item); // OK: item IS Pointer
    }
    println!(&quot;&quot;);

    print!(&quot;{:&gt;13} {} &quot;, &quot;for vec iter&quot;, &quot;=&quot;);
    for item in instance.iter() {
        let ref_item: &amp;u8 = item;
        print!(&quot;{:p} &quot;, ref_item); // OK: item IS Pointer
    }
    println!(&quot;&quot;);

    println!(&quot;{:&gt;13} {} {:?}&quot;, &quot;instance vec&quot;, &quot;=&quot;, instance);

#}</code></pre></pre>
<p>　　该程序输出结果如下。从中可以看到这些原始指针的内存地址都是一样的，它们指向相同的可变数组的数据。</p>
<pre><code class="language-bash">───────┬───────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼───────────────────────────────────────────────────────────────────────
   1   │ instance raw = 0x7f90084035e0
   2   │  for vec ref = 0x7f90084035e0 0x7f90084035e1 0x7f90084035e2 
   3   │ for vec iter = 0x7f90084035e0 0x7f90084035e1 0x7f90084035e2 
   4   │ instance vec = [1, 2, 3]
───────┴───────────────────────────────────────────────────────────────────────
</code></pre>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-12_vec_for_loop.png" alt="image" /></p>
<h2><a class="header" href="#题外话-21" id="题外话-21">题外话</a></h2>
<h2><a class="header" href="#参考资料-38" id="参考资料-38">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter">What is the difference between iter and into_iter?</a></li>
<li><a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html">Effectively Using Iterators In Rust</a></li>
<li><a href="https://stackoverflow.com/questions/30467085/how-to-iterate-over-and-filter-an-array">How to iterate over and filter an array?</a></li>
<li><a href="https://stackoverflow.com/questions/28378407/how-to-iterate-over-an-array-of-integers">How to iterate over an array of integers?</a></li>
<li><a href="http://xion.io/post/code/rust-patterns-ref.html">rust-patterns-ref</a></li>
<li></li>
</ul>
<h1><a class="header" href="#题外话关键词ref与引用符" id="题外话关键词ref与引用符">题外话：关键词<code>ref</code>与引用符<code>&amp;</code></a></h1>
<p>　　在下面一段代码只有一个<code>let</code>语句里，目的是说明该<code>＆ref</code>操作等价于什么也没有做，它们是相反的操作，类似于操作<code>*</code>和<code>&amp;</code>也是相反的操作。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: lib-hello/src/immut/type_ref/mod.rs
    // Function use_ref_and()

    let x: u8 = 33;
    let w: &amp;u8 = &amp;x;
    let ref y: u8 = x;
    let z: &amp;u8 = y;
    
    println!(&quot;x = {:p}&quot;, &amp;x);
    println!(&quot;w = {:p}&quot;, w);
    println!(&quot;y = {:p}&quot;, y);
    println!(&quot;z = {:p}&quot;, z);

    println!(&quot;x = {}&quot;, x);
    println!(&quot;w = {}&quot;, w);
    println!(&quot;y = {}&quot;, y);
    println!(&quot;z = {}&quot;, z);

    let &amp;ref y  = &amp;x;
    println!(&quot;y = {:p}&quot;, y);
    println!(&quot;y = {}&quot;, y);
    println!();
    
    let x: Vec&lt;u8&gt; = vec![33, 42];
    let w: &amp;Vec&lt;u8&gt; = &amp;x;
    let ref y: Vec&lt;u8&gt; = x;
    let z: &amp;Vec&lt;u8&gt; = y;
    
    println!(&quot;x = {:p}&quot;, &amp;x);
    println!(&quot;w = {:p}&quot;, w);
    println!(&quot;y = {:p}&quot;, y);
    println!(&quot;z = {:p}&quot;, z);

    println!(&quot;x = {:?}&quot;, x);
    println!(&quot;w = {:?}&quot;, w);
    println!(&quot;y = {:?}&quot;, y);
    println!(&quot;z = {:?}&quot;, z);

    let &amp;ref y  = &amp;x;
    println!(&quot;y = {:p}&quot;, y);
    println!(&quot;y = {:?}&quot;, y);

#}</code></pre></pre>
<p>　　借助于工具cargo-clippy，使用下面命令：</p>
<pre><code class="language-bash"># 工具cargo-clippy命令
cargo　clippy
</code></pre>
<p>可以获取如下编译器的警告信息：</p>
<pre><code class="language-bash">warning: `ref` on an entire `let` pattern is discouraged, take a reference with `&amp;` instead
   --&gt; lib-hello/src/immut/type_ref/mod.rs:105:9
    |
105 |     let ref y: u8 = x;
    |     ----^^^^^--------- help: try: `let y: &amp;u8 = &amp;x;`
    |
    = note: `#[warn(clippy::toplevel_ref_arg)]` on by default
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#toplevel_ref_arg
</code></pre>
<p>　　从上面警告，可以解读这些内容：</p>
<ul>
<li>在上面程序一段代码包括四个<code>let</code>语句里，中间两个是等价的；</li>
<li>不鼓励在整个<code>let</code>语句上使用关键词引用符<code>ref</code>，而应使用借用符<code>＆</code>；</li>
<li>从中可以知道，关键词<code>ref</code>不应该在<code>let</code>语句上使用，而更适合在<code>macth</code>语句里使用它。借用符<code>＆</code>要引用一个对象，而<code>ref</code>通过引用而不是按值绑定到位置。换句话说，借用符<code>＆</code>实现简单的借用，而引用符<code>ref</code>则是“借用我，到与我相匹配的位置上去”；</li>
</ul>
<p>　　在宏<code>println!()</code>打印内存地址信息时，只有非引用对象变量，才在变量前面使用借用符<code>&amp;</code>。要是去掉该引用符<code>&amp;</code>，编译器将会出现下面错误信息，从中也可以知道，谁是引用谁不是引用对象：</p>
<pre><code class="language-bash">error[E0277]: the trait bound `u8: std::fmt::Pointer` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |     println!(&quot;x = {:p}&quot;, x);
  |                          ^ the trait `std::fmt::Pointer` is not implemented for `u8`
  |
  = note: required by `std::fmt::Pointer::fmt`
</code></pre>
<h2><a class="header" href="#参考资料-39" id="参考资料-39">参考资料</a></h2>
<ul>
<li><a href="https://users.rust-lang.org/t/ref-keyword-versus/18818/4">Ref keyword versus &amp;</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/scope/borrow/ref.html">The ref pattern</a></li>
<li><a href="http://xion.io/post/code/rust-patterns-ref.html">&amp; vs. ref in Rust patterns</a></li>
<li><a href="https://medium.com/@robertgrosse/ref-patterns-destructuring-and-invisible-borrows-2f8ae6902656">ref-patterns-destructuring-and-invisible-borrows</a></li>
</ul>
<h1><a class="header" href="#软件篋borrowing_exerci二" id="软件篋borrowing_exerci二">软件篋borrowing_exerci（二）</a></h1>
<h1><a class="header" href="#关于应用篋mut_borrowing_exerci" id="关于应用篋mut_borrowing_exerci">关于应用篋mut_borrowing_exerci</a></h1>
<h1><a class="header" href="#应用篋借用次数实例" id="应用篋借用次数实例">应用篋：借用次数实例</a></h1>
<p>　　在Rust语言里，从固定和可变绑定对象引用形式上是相同的，但是它们可以引用的次数是不同的。可变绑定对象引用只能是一次，而固定对象引用可以是多次。</p>
<h2><a class="header" href="#学习内容-37" id="学习内容-37">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言借用次数实例</li>
</ul>
<h2><a class="header" href="#篇目-42" id="篇目-42">篇目</a></h2>
<ul>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E5%8F%AF%E5%8F%98%E5%85%B3%E9%94%AE%E8%AF%8Dmut%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%9F%E7%94%A8%E6%96%B9%E6%B3%95">可变关键词<code>mut</code>绑定对象的借用方法</a></li>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E5%9B%BA%E5%AE%9A%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%9F%E7%94%A8%E6%AC%A1%E6%95%B0">固定绑定对象的借用次数</a></li>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E5%85%B3%E9%94%AE%E8%AF%8Dmut%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%9F%E7%94%A8%E6%AC%A1%E6%95%B0">关键词<code>mut</code>绑定对象的借用次数</a></li>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E5%8F%AF%E5%8F%98%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9B%BA%E5%AE%9A%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%81%94%E7%B3%BB">可变绑定对象与固定绑定对象联系</a>　　</li>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mut-borrowing/borrowing-count.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#可变关键词mut绑定对象的借用方法" id="可变关键词mut绑定对象的借用方法">可变关键词<code>mut</code>绑定对象的借用方法</a></h2>
<p>　　可变关键词<code>mut</code>用来绑定可变对象。下面程序代码的第一行就是实例。在<code>let</code>语句的基础上，增加可变关键词<code>mut</code>就可以实现绑定可变对象。所谓可变对象，就是其值在其范围内<strong>肯定</strong>会被修改的。修改可变对象值的实例是第二段代码的第一行。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/mut_base/mut_ref/mod.rs

    let mut mut_instance = 1u8;
    println!(&quot;1. mut_instance = {}&quot;, mut_instance);

    mut_instance = 33;
    println!(&quot;2. mut_instance = {}&quot;, mut_instance);

    let ref_mut_instance = &amp;mut mut_instance;
    *ref_mut_instance = 42;
    println!(&quot;3. mut_instance = {}&quot;, mut_instance);

    mut_instance = 100;
    println!(&quot;4. mut_instance = {}&quot;, mut_instance);

#}</code></pre></pre>
<p>　　上面程序第三段代码的第一行代码是，绑定可变引用对象的方法实例。在紧接着引用符<code>＆</code>之后，增加可变关键词<code>mut</code>就可实现绑定可变引用对象。修改可变引用对象值的实例是第三段代码的第二行。</p>
<p>　　需要注意的是，修改可变引用对象（如这里：<code>ref_mut_instance</code>）值就是修改其可变对象（如这里：<code>mut_instance</code>）值。</p>
<p>　　在第四段代码里，还可以使用可变对象<code>mut_instance</code>，这说明了上面可变引用对象是可行的。下面是该程序的输出结果：</p>
<pre><code class="language-bash">1. mut_instance = 1
2. mut_instance = 33
3. mut_instance = 42
4. mut_instance = 100
</code></pre>
<h2><a class="header" href="#固定绑定对象的借用次数" id="固定绑定对象的借用次数">固定绑定对象的借用次数</a></h2>
<p>　　下面程序将要说明，对于固定和可变绑定对象而已，使用固定绑定引用对象的次数是不受限制的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/mut_base/mut_count/mod.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let instance = vec![33u8, 42];
    let first_ref = &amp;instance; // immutable reference
    let second_ref = &amp;instance; // immutable reference
    println!(&quot;{:?} {:?}&quot;, first_ref, second_ref);

    let mut instance = vec![33, 42u8];
    let first_mut_ref = &amp;instance; // immutable reference
    let second_mut_ref = &amp;instance; // immutable reference
    println!(&quot;{:?} {:?}&quot;, first_mut_ref, second_mut_ref);

#}</code></pre></pre>
<h2><a class="header" href="#关键词mut绑定对象的借用次数" id="关键词mut绑定对象的借用次数">关键词<code>mut</code>绑定对象的借用次数</a></h2>
<p>　　对于可变绑定对象而已，当其引用对象也是可变的时，在其有效范围内，这种可变引用对象的绑定同时只能存在一个。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/mut_base/mut_count/mod.rs
    // #[cfg(feature = &quot;err_01&quot;)]

    let mut instance = vec![33u8, 42];
    let first_mut_ref = &amp;mut instance; // mutable reference
    let second_mut_ref = &amp;mut instance; // mutable reference
    println!(&quot;{:?} {:?}&quot;, first_mut_ref, second_mut_ref);

#}</code></pre></pre>
<p>　　下面程序里使用了两次可变引用对象的绑定，这样就会导致编译器提示错误信息：同时不能多次借用对象<code>instance</code>作为可变引用变量。</p>
<pre><code class="language-bash">error[E0499]: cannot borrow `instance` as mutable more than once at a time
  --&gt; bin-hello/examples/mut_base/mut_count.rs:38:26
   |
37 |     let first_mut_ref = &amp;mut instance; // mutable reference
   |                         ------------- first mutable borrow occurs here
38 |     let second_mut_ref = &amp;mut instance; // mutable reference
   |                          ^^^^^^^^^^^^^ second mutable borrow occurs here
39 |     println!(&quot;{:?} {:?}&quot;, first_mut_ref, second_mut_ref);
   |                           ------------- first borrow later used here
</code></pre>
<h2><a class="header" href="#可变绑定对象与固定绑定对象联系" id="可变绑定对象与固定绑定对象联系">可变绑定对象与固定绑定对象联系</a></h2>
<p>　　对于可变绑定对象，要是先绑定了其固定引用对象，然后再绑定其可变引用对象，注意此时，只是前面固定引用对象不能再借用了，而后面可变引用对象的借用还是有效的。这是下面的实例程序。要是把该程序最后一行代码注释掉，程序还是运行正常的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/mut_base/mut_count/mod.rs
    // #[cfg(feature = &quot;err_02&quot;)]

    let mut instance = vec![33, 42u8];
    let first_immut_ref = &amp;instance; // immutable reference
    let second_mut_ref = &amp;mut instance; // mutable reference
    println!(&quot;{:?}&quot;, first_immut_ref);

#}</code></pre></pre>
<p>　　同样道理，对于可变绑定对象，要是先绑定了其可变引用对象，然后再绑定其固定引用对象，则前面可变引用对象就不能在借用了，而后面固定引用对象的借用还是有效的。这是下面的实例程序。要是把该程序最后一行代码注释掉，程序还是运行正常的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./bin-hello/examples/mut_base/mut_count/mod.rs
    // #[cfg(feature = &quot;err_03&quot;)]

    let mut instance = vec![33u8, 42];
    let first_mut_ref = &amp;mut instance; // mutable reference
    let second_immut_ref = &amp;instance; // immutable reference
    println!(&quot;{:?}&quot;, first_mut_ref);

#}</code></pre></pre>
<h2><a class="header" href="#题外话-22" id="题外话-22">题外话</a></h2>
<h2><a class="header" href="#参考资料-40" id="参考资料-40">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#应用篋宏dbg与可变实例" id="应用篋宏dbg与可变实例">应用篋：宏<code>dbg!</code>与可变实例</a></h1>
<h2><a class="header" href="#学习内容-38" id="学习内容-38">学习内容</a></h2>
<ul>
<li>了解和学习使用宏方法<code>dbg!</code>的借用实例</li>
</ul>
<h2><a class="header" href="#篇目-43" id="篇目-43">篇目</a></h2>
<ul>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E5%AE%8Fdbg%E4%B8%8E%E5%80%9F%E7%94%A8%E6%9C%BA%E5%88%B6">宏<code>dbg!</code>与借用机制</a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%9B%BA%E5%AE%9A%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">可变对象及其固定引用对象</a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">可变对象及其可变引用对象</a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%60String%60%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">创建类型<code>String</code>对象方法</a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E7%B1%BB%E5%9E%8Bstring%E6%96%B9%E6%B3%95push%E5%92%8Cpush_str">类型<code>String</code>：方法<code>push</code>和<code>push_str</code></a></li>
<li><a href="hello-mut-borrowing/borrowing-dbg.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#宏dbg与借用机制" id="宏dbg与借用机制">宏<code>dbg!</code>与借用机制</a></h2>
<p>　　宏方法<code>dbg!</code>实现打印并返回给定表达式的值，目的进行快速而简陋的调试。该宏类似于程序输出宏<code>println!</code>，但是宏方法<code>dbg!</code>使用简单方便，并且它不是以与程序输出在一起，而是单独输出。所以，当使用在线图书执行它时，我们将看不到其输出结果。</p>
<p>　　先看一个宏方法<code>dbg!</code>的简单应用实例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/dbg/mut_macro.rs
    // #[cfg(feature = &quot;cp&quot;)]

    let string :String = format!(&quot;{}&quot;, &quot;Hello&quot;);
    dbg!(std::mem::size_of_val(&amp;string));
    dbg!(&amp;string);
    dbg!(string);

#}</code></pre></pre>
<p>其输出结果如下：</p>
<pre><code class="language-rust no_run noplaypen"></code></pre>
<p>　　<a href="hello-mut-borrowing/id_01">官方文档</a>解释宏方法<code>dbg!</code>如下：</p>
<blockquote>
<p>Invoking the macro on an expression moves and takes ownership of it before returning the evaluated expression unchanged. If the type of the expression does not implement Copy and you don't want to give up ownership, you can instead borrow with dbg!(&amp;expr) for some expression expr.</p>
</blockquote>
<p>中文翻译：</p>
<blockquote>
<p>调用基于表达式<code>expr</code>的宏，会转移对象并获取其所有权，然后再返回已求值的表达式不变。如果表达式的类型未实现特质<code>Copy</code>且不想放弃所有权，则对于一些表达式<code>expr</code>可以改用这种调用方法<code>dbg!(＆expr)</code>。</p>
</blockquote>
<p>　　下面程序的目的就是来验证上面阐述的第一句话。一旦使用了没有实现特质<code>Copy</code>的类型<code>String</code>对象，是否宏方法<code>dbg!</code>转移该对象，并且调用该宏结束以后，就拿走了该对象的所有权。只要运行一下该程序，就得到了验证。在实际中，都会使用这种<code>dbg!(＆expr)</code>调用方法。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/dbg/mut_macro.rs
    // ANCHOR = &quot;error_01&quot;
    // error[E0382]: borrow of moved value: `string`

    let string = format!(&quot;{}&quot;, &quot;Hello&quot;);
    dbg!(string);
    dbg!(&amp;string);

#}</code></pre></pre>
<h2><a class="header" href="#可变对象及其固定引用对象" id="可变对象及其固定引用对象">可变对象及其固定引用对象</a></h2>
<p>　　对于可变类型对象，在使用宏方法<code>dbg!</code>时，可以绑定其固定引用对象，具体实例如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/dbg/mut_macro.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let mut string :String = format!(&quot;{}&quot;, &quot;Hello&quot;);
    string.push('!');
    let ref_string = &amp;string;
    dbg!(ref_string);
    dbg!(ref_string);

#}</code></pre></pre>
<p>　　上面程序运行正常，说明固定引用对象<code>ref_string</code>的借用是正常的。那么我们可否绑定其可变引用对象呢？</p>
<h2><a class="header" href="#可变对象及其可变引用对象" id="可变对象及其可变引用对象">可变对象及其可变引用对象</a></h2>
<p>　　下面程序将回答上面的问题。对于可变类型对象，在使用宏方法<code>dbg!</code>时，可以绑定其可变引用对象，将会发生什么？具体实例如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/dbg/mut_macro.rs
    // ANCHOR = &quot;error_03&quot;
    // error[E0382]: use of moved value: `ref_mut_string`

    let mut string = format!(&quot;{}&quot;, &quot;Hello&quot;);
    string.push('!');
    let ref_mut_string = &amp;mut string;
    dbg!(ref_mut_string);
    dbg!(ref_mut_string);

#}</code></pre></pre>
<p>　　对于可变引用对象，宏方法<code>dbg!</code>也将其可变对象的所有权收回了。</p>
<h2><a class="header" href="#题外话-23" id="题外话-23">题外话</a></h2>
<h3><a class="header" href="#创建类型string对象方法" id="创建类型string对象方法">创建类型<code>String</code>对象方法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let new_string :String = String::new();
let from_string :String = String::from(&quot;Hello&quot;);
let format_string :String = format!(&quot;{}&quot;, &quot;Hello&quot;);
let to_string :String = &quot;Hello&quot;.to_string();
#}</code></pre></pre>
<h3><a class="header" href="#类型string方法push和push_str" id="类型string方法push和push_str">类型<code>String</code>：方法<code>push</code>和<code>push_str</code></a></h3>
<p>　　在创建类型<code>String</code>的可变对象时，经常会使用到方法<code>push()</code>和<code>push_str()</code>，前者方法参数类型是<code>char</code>，而后者方法参数类型<code>&amp;str</code>。</p>
<h2><a class="header" href="#参考资料-41" id="参考资料-41">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.dbg.html">std macro.dbg</a></li>
<li><a href="https://brown121407.github.io/programming/2019/01/18/rusts-dbg-macro.html">rusts-dbg-macro</a></li>
<li><a href="https://stackoverflow.com/questions/38141056/does-rust-have-a-debug-macro">does-rust-have-a-debug-macro</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/59087">Generator size: borrowed variables are...</a></li>
</ul>
<h1><a class="header" href="#应用篋可变大小类型借用实例" id="应用篋可变大小类型借用实例">应用篋：可变大小类型借用实例</a></h1>
<p>　　本节将解释可变大小类型的不同借用方式。尤其是当可变类型对象与固定和可变引用对象交互在一起时，程序代码将会比较复杂。但是通过这一节学习可以加深对借用对象的生命周期概念的理解。</p>
<h2><a class="header" href="#学习内容-39" id="学习内容-39">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言可变大小类型的借用实例</li>
</ul>
<h2><a class="header" href="#篇目-44" id="篇目-44">篇目</a></h2>
<p>　　</p>
<ul>
<li><a href="hello-mut-borrowing/borrowing-mut.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%BA%E5%AE%9A%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">可变类型对象的固定引用对象</a></li>
<li><a href="hello-mut-borrowing/borrowing-mut.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">可变类型对象的可变引用对象</a></li>
<li><a href="hello-mut-borrowing/borrowing-mut.html#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">可变类型对象的不同引用对象</a></li>
<li><a href="hello-mut-borrowing/borrowing-mut.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mut-borrowing/borrowing-mut.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#可变类型对象的固定引用对象" id="可变类型对象的固定引用对象">可变类型对象的固定引用对象</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_ref.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let mut mut_instance = String::from(&quot;Hello&quot;);
    mut_instance.push_str(&quot;, world&quot;);
    println!(&quot;1. use mut_instance = {}&quot;, mut_instance);

    // The variable `mut_instance` begin to move here
    let copy_mut_instance = &amp;mut_instance;
    // The variable `mut_instance` moved here
    println!(&quot;1. use copy_mut_instance = {}&quot;, copy_mut_instance);

    // The variable `mut_instance` borrowed here after move
    println!(&quot;2. use mut_instance = {}&quot;, mut_instance);
    println!(&quot;2. use copy_mut_instance = {}&quot;, copy_mut_instance);

#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_ref.rs
    // ANCHOR = &quot;string_ref-error_01&quot;
    // error[E0382]: borrow of moved value: `mut_instance`

    let mut mut_instance = String::from(&quot;hello&quot;);
    mut_instance.push_str(&quot;, world!&quot;);
    println!(&quot;1. use mut_instance = {}&quot;, mut_instance);

    // The variable `mut_instance` begin to move here
    let copy_mut_instance = mut_instance;
    // The variable `mut_instance` moved here

    // ERROR: The variable `mut_instance` borrowed here after move
    println!(&quot;2. use mut_instance = {}&quot;, mut_instance); //ERROR

#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_ref.rs
    // ANCHOR = &quot;string_ref-error_02&quot;
    // error[E0502]: cannot borrow `mut_instance` as mutable because it is also borrowed as immutable

    let mut mut_instance = String::from(&quot;Hello&quot;);
    mut_instance.push_str(&quot;, world&quot;);
    println!(&quot;1. use mut_instance = {}&quot;, mut_instance);

    let copy_mut_instance = &amp;mut_instance;
    println!(&quot;1. use copy_mut_instance = {}&quot;, copy_mut_instance);

    // The variable `copy_mut_instance` begin to move here
    mut_instance.push_str(&quot;!&quot;);
    // The variable `copy_mut_instance` moved here
    println!(&quot;2. use copy_mut_instance = {}&quot;, copy_mut_instance); //ERROR

    // The variable `mut_instance` borrowed here after move
    println!(&quot;2. use mut_instance = {}&quot;, mut_instance);

#}</code></pre></pre>
<h2><a class="header" href="#可变类型对象的可变引用对象" id="可变类型对象的可变引用对象">可变类型对象的可变引用对象</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_ref.rs
    // #[cfg(feature = &quot;cp&quot;)]

    let mut mut_instance = String::from(&quot;Hello&quot;);
    mut_instance.push_str(&quot;, world&quot;);
    println!(&quot;1. use mut_instance = {}&quot;, mut_instance);

    // The variable `mut_instance` begin to move here
    let ref_mut_instance = &amp;mut mut_instance;
    // The variable `mut_instance` moved here
    println!(&quot;1. use copy_mut_instance = {}&quot;, ref_mut_instance);
    ref_mut_instance.push_str(&quot;!&quot;);
    println!(&quot;2. use ref_mut_instance = {}&quot;, ref_mut_instance);

    mut_instance.make_ascii_uppercase();

    println!(&quot;2. use mut_instance = {}&quot;, mut_instance);

#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_ref.rs
    // ANCHOR = &quot;string_ref-error_03&quot;
    // error[E0499]: cannot borrow `mut_instance` as mutable more than once at a time

    let mut mut_instance = String::from(&quot;Hello&quot;);
    mut_instance.push_str(&quot;, world&quot;);
    println!(&quot;1. use mut_instance = {}&quot;, mut_instance);

    // The variable `mut_instance` begin to move here
    let ref_mut_instance = &amp;mut mut_instance;
    // The variable `mut_instance` moved here
    println!(&quot;1. use ref_mut_instance = {}&quot;, ref_mut_instance);
    ref_mut_instance.push_str(&quot;!&quot;);
    println!(&quot;2. use ref_mut_instance = {}&quot;, ref_mut_instance);

    // The variable `ref_mut_instance` begin to move here
    mut_instance.make_ascii_uppercase();
    // The variable `ref_mut_instance` moved here

    println!(&quot;3. use ref_mut_instance = {}&quot;, ref_mut_instance); // ERROR

    // The variable `mut_instance` borrowed here after move
    println!(&quot;2. use mut_instance = {}&quot;, mut_instance);

#}</code></pre></pre>
<h2><a class="header" href="#可变类型对象的不同引用对象" id="可变类型对象的不同引用对象">可变类型对象的不同引用对象</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_refs.rs
    // #[cfg(feature = &quot;ok&quot;)]

    let mut instance = String::new();
    instance.push_str(&quot;hello&quot;);

    let ref_mut_instance :&amp;mut String = &amp;mut instance;
    ref_mut_instance.push_str(&quot; world&quot;);

    let ref_instance :&amp;String = ref_mut_instance;
    println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    ref_mut_instance.make_ascii_uppercase(); // ref_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    instance.push('!'); // ref_mut_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_mut_instance);

    println!(&quot;instance = {}&quot;, instance);

#}</code></pre></pre>
<p>err_04:上面对象ref_instance生命周期</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_refs.rs
    // ANCHOR = &quot;string_refs-error_01&quot;
    // error[E0502]: cannot borrow `*ref_mut_instance` as mutable because it is also borrowed as immutable

    let mut instance = String::new();
    instance.push_str(&quot;hello&quot;);

    let ref_mut_instance :&amp;mut String = &amp;mut instance;
    ref_mut_instance.push_str(&quot; world&quot;);

    let ref_instance :&amp;String = ref_mut_instance;
    println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    ref_mut_instance.make_ascii_uppercase(); // ref_instance is moved after here
    println!(&quot;ref_instance = {}&quot;, ref_instance); // ERROR
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    instance.push('!'); // ref_mut_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_mut_instance);

    println!(&quot;instance = {}&quot;, instance);

#}</code></pre></pre>
<p>err_05:上面对象ref_mut_instance生命周期</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_refs.rs
    // ANCHOR = &quot;string_refs-error_02&quot;
    // error[E0499]: cannot borrow `instance` as mutable more than once at a time
    
    let mut instance = String::new();
    instance.push_str(&quot;hello&quot;);

    let ref_mut_instance :&amp;mut String = &amp;mut instance;
    ref_mut_instance.push_str(&quot; world&quot;);

    let ref_instance :&amp;String = ref_mut_instance;
    println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    ref_mut_instance.make_ascii_uppercase(); // ref_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    instance.push('!'); // ref_mut_instance is moved after here
    println!(&quot;ref_instance = {}&quot;, ref_mut_instance);

    println!(&quot;instance = {}&quot;, instance);

#}</code></pre></pre>
<p>err_06：比较string_refs.rs:feature-ok
//let ref_instance :&amp;String = ref_mut_instance;
let ref_instance :&amp;String = &amp;instance;</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // File: ./examples/mut_var_sized/string_refs.rs
    // ANCHOR = &quot;string_refs-error_03&quot;
    // error[E0502]: cannot borrow `instance` as immutable because it is also borrowed as mutable

    let mut instance = String::new();
    instance.push_str(&quot;hello&quot;);

    let ref_mut_instance :&amp;mut String = &amp;mut instance;
    ref_mut_instance.push_str(&quot; world&quot;);

    //let ref_instance :&amp;String = ref_mut_instance;
    let ref_instance :&amp;String = &amp;instance;
    println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);  // ERROR

    ref_mut_instance.make_ascii_uppercase(); // ref_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_instance);
    println!(&quot;ref_mut_instance = {}&quot;, ref_mut_instance);

    instance.push('!'); // ref_mut_instance is moved after here
    //println!(&quot;ref_instance = {}&quot;, ref_mut_instance);

    println!(&quot;instance = {}&quot;, instance);

#}</code></pre></pre>
<h2><a class="header" href="#题外话-24" id="题外话-24">题外话</a></h2>
<h2><a class="header" href="#参考资料-42" id="参考资料-42">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/40654940/mutable-borrow-automatically-changes-to-immutable/40655179#40655179">mutable-borrow-automatically-changes-to-immutable</a></li>
</ul>
<h1><a class="header" href="#应用篋循环for语句可变借用实例" id="应用篋循环for语句可变借用实例">应用篋：循环for语句可变借用实例</a></h1>
<p>https://www.google.com/search?q=rust+mutable+borrow+in+loop&amp;oq=rust+mut+bor&amp;aqs=chrome.3.69i57j0l5.23911j0j7&amp;sourceid=chrome&amp;ie=UTF-8</p>
<h1><a class="header" href="#应用篋可变类型与函数实例" id="应用篋可变类型与函数实例">应用篋：可变类型与函数实例</a></h1>
<h1><a class="header" href="#题外话使用工具cargo" id="题外话使用工具cargo">题外话：使用工具cargo</a></h1>
<h2><a class="header" href="#run-examples-in-subfolders-using-cargo" id="run-examples-in-subfolders-using-cargo">Run examples in subfolders using cargo</a></h2>
<h2><a class="header" href="#参考资料-43" id="参考资料-43">参考资料</a></h2>
<ul>
<li>https://users.rust-lang.org/t/run-examples-in-subfolders-using-cargo/18154/3</li>
</ul>
<h1><a class="header" href="#软件箧some_exerci" id="软件箧some_exerci">软件箧<code>some_exerci</code></a></h1>
<h2><a class="header" href="#重要参考资料" id="重要参考资料">重要参考资料</a></h2>
<ul>
<li>https://blog.codeship.com/understanding-rust-loops/</li>
</ul>
<h2><a class="header" href="#参考资料-44" id="参考资料-44">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/25383488/how-to-match-a-string-against-string-literals-in-rust">how-to-match-a-string-against-string-literals-in-rust</a></li>
<li><a href="https://www.jonathanturner.org/2016/02/rust-quickie-matching-strings.html">rust-quickie-matching-strings</a></li>
<li><a href="http://xion.io/post/code/rust-patterns-ref.html">rust-patterns-ref</a></li>
</ul>
<h1><a class="header" href="#关于软件篋some_exerci" id="关于软件篋some_exerci">关于软件篋some_exerci</a></h1>
<h1><a class="header" href="#栈和堆" id="栈和堆">栈和堆</a></h1>
<p>栈(stack)和堆(heap)</p>
<h1><a class="header" href="#开发软件篋some_exerci" id="开发软件篋some_exerci">开发软件篋some_exerci</a></h1>
<h1><a class="header" href="#使用软件篋some_exerci" id="使用软件篋some_exerci">使用软件篋some_exerci</a></h1>
<h1><a class="header" href="#题外话应用篋的软件包结构" id="题外话应用篋的软件包结构">题外话：应用篋的软件包结构</a></h1>
<h1><a class="header" href="#题外话cargo工具features功能" id="题外话cargo工具features功能">题外话：Cargo工具features功能</a></h1>
<h1><a class="header" href="#软件篋macro_exerci" id="软件篋macro_exerci">软件篋macro_exerci</a></h1>
<h1><a class="header" href="#关于软件篋macro_exerci" id="关于软件篋macro_exerci">关于软件篋macro_exerci</a></h1>
<h1><a class="header" href="#开发软件篋macro_exerci" id="开发软件篋macro_exerci">开发软件篋macro_exerci</a></h1>
<h1><a class="header" href="#使用软件篋macro_exerci" id="使用软件篋macro_exerci">使用软件篋macro_exerci</a></h1>
<h1><a class="header" href="#软件篋generics_exerci" id="软件篋generics_exerci">软件篋generics_exerci</a></h1>
<h1><a class="header" href="#关于软件篋generics_exerci" id="关于软件篋generics_exerci">关于软件篋generics_exerci</a></h1>
<h1><a class="header" href="#开发软件篋generics_exerci" id="开发软件篋generics_exerci">开发软件篋generics_exerci</a></h1>
<h1><a class="header" href="#使用软件篋generics_exerci" id="使用软件篋generics_exerci">使用软件篋generics_exerci</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
