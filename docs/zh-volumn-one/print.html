<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>以软件篋学习Rust语言</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Chinese">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="foreword/index.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li><ol class="section"><li class="expanded "><a href="foreword/about.html"><strong aria-hidden="true">1.1.</strong> 本书项目结构</a></li><li class="expanded "><a href="foreword/crate.html"><strong aria-hidden="true">1.2.</strong> 关于作业区和软件篋实例</a></li><li class="expanded "><a href="foreword/cargo.html"><strong aria-hidden="true">1.3.</strong> 关于Cargo工具基础命令</a></li><li class="expanded "><a href="foreword/rust.html"><strong aria-hidden="true">1.4.</strong> Rust语言新思维和新概念</a></li></ol></li><li class="expanded "><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> 软件篋hello_exercism</a></li><li><ol class="section"><li class="expanded "><a href="hello-world/about.html"><strong aria-hidden="true">2.1.</strong> 关于软件篋项目</a></li><li class="expanded "><a href="hello-world/commands-lib.html"><strong aria-hidden="true">2.2.</strong> 共享篋：开发命令</a></li><li class="expanded "><a href="hello-world/lib.html"><strong aria-hidden="true">2.3.</strong> 共享篋：程序代码解释</a></li><li class="expanded "><a href="hello-world/lib-tests.html"><strong aria-hidden="true">2.4.</strong> 共享篋：目录tests的测试代码解释</a></li><li class="expanded "><a href="hello-world/src-tests.html"><strong aria-hidden="true">2.5.</strong> 共享篋：目录src的测试代码解释</a></li><li class="expanded "><a href="hello-world/commands-local.html"><strong aria-hidden="true">2.6.</strong> 本地程序：开发命令</a></li><li class="expanded "><a href="hello-world/bin-local.html"><strong aria-hidden="true">2.7.</strong> 本地程序：程序代码解释</a></li><li class="expanded "><a href="hello-world/commands-bin.html"><strong aria-hidden="true">2.8.</strong> 仓库程序：开发命令</a></li><li class="expanded "><a href="hello-world/bin.html"><strong aria-hidden="true">2.9.</strong> 仓库程序：程序代码解释</a></li><li class="expanded "><a href="hello-world/off-topic.html"><strong aria-hidden="true">2.10.</strong> 题外话</a></li></ol></li><li class="expanded "><a href="hello-trait/index.html"><strong aria-hidden="true">3.</strong> 软件篋trait_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-trait/examples-struct.html"><strong aria-hidden="true">3.1.</strong> 类型关键词struct</a></li><li class="expanded "><a href="hello-trait/examples-impl.html"><strong aria-hidden="true">3.2.</strong> 关键词impl与方法代码实现</a></li><li class="expanded "><a href="hello-trait/examples-methods.html"><strong aria-hidden="true">3.3.</strong> 函数与方法代码实现</a></li><li class="expanded "><a href="hello-trait/examples-trait.html"><strong aria-hidden="true">3.4.</strong> 衔接关键词trait</a></li><li class="expanded "><a href="hello-trait/examples-trait-impl.html"><strong aria-hidden="true">3.5.</strong> 特质实现及其对象</a></li><li class="expanded "><a href="hello-trait/examples-trait-default.html"><strong aria-hidden="true">3.6.</strong> 题外话：默认衔接特质Default</a></li><li class="expanded "><a href="hello-trait/lib-structure.html"><strong aria-hidden="true">3.7.</strong> 程序代码结构</a></li><li class="expanded "><a href="hello-trait/about.html"><strong aria-hidden="true">3.8.</strong> 关于软件篋项目</a></li><li class="expanded "><a href="hello-trait/commands-lib.html"><strong aria-hidden="true">3.9.</strong> 共享篋：开发命令</a></li><li class="expanded "><a href="hello-trait/lib-codes.html"><strong aria-hidden="true">3.10.</strong> 共享篋：程序代码解释</a></li><li class="expanded "><a href="hello-trait/lib-tests.html"><strong aria-hidden="true">3.11.</strong> 共享篋：目录测试代码解释</a></li><li class="expanded "><a href="hello-trait/off-topic.html"><strong aria-hidden="true">3.12.</strong> 题外话</a></li></ol></li><li class="expanded "><a href="hello-mod-trait/index.html"><strong aria-hidden="true">4.</strong> 软件篋mod_trait_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-mod-trait/about.html"><strong aria-hidden="true">4.1.</strong> 关于软件篋mod_trait_exerci</a></li><li class="expanded "><a href="hello-mod-trait/crate-structure.html"><strong aria-hidden="true">4.2.</strong> 文件与模块</a></li><li class="expanded "><a href="hello-mod-trait/lib-codes.html"><strong aria-hidden="true">4.3.</strong> 共享篋：程序结构和代码解释</a></li><li class="expanded "><a href="hello-mod-trait/exampels-codes.html"><strong aria-hidden="true">4.4.</strong> 三种调用方式解释</a></li><li class="expanded "><a href="hello-mod-trait/examples-dispatch.html"><strong aria-hidden="true">4.5.</strong> 理解动态与静态调度实现</a></li><li class="expanded "><a href="hello-mod-trait/examples-miri.html"><strong aria-hidden="true">4.6.</strong> 深度解析动态与静态调度实现</a></li><li class="expanded "><a href="hello-mod-trait/lib-fn.html"><strong aria-hidden="true">4.7.</strong> 共享篋：简单三层结构实现</a></li><li class="expanded "><a href="hello-mod-trait/lib-static.html"><strong aria-hidden="true">4.8.</strong> 共享篋：基于封装的静态调度实现</a></li><li class="expanded "><a href="hello-mod-trait/lib-dynamic.html"><strong aria-hidden="true">4.9.</strong> 共享篋：基于封装的动态调度实现</a></li><li class="expanded "><a href="hello-mod-trait/lib-tests.html"><strong aria-hidden="true">4.10.</strong> 共享篋：单元测试代码解释</a></li><li class="expanded "><a href="hello-mod-trait/off-topic.html"><strong aria-hidden="true">4.11.</strong> 题外话：泛型实例</a></li></ol></li><li class="expanded "><a href="hello-borrowing/index.html"><strong aria-hidden="true">5.</strong> 软件篋borrowing_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-borrowing/about.html"><strong aria-hidden="true">5.1.</strong> 关于应用篋borrowing_exerci</a></li><li class="expanded "><a href="hello-borrowing/clone-copy.html"><strong aria-hidden="true">5.2.</strong> 特质：克隆（Clone）和复制（Copy）</a></li><li class="expanded "><a href="hello-borrowing/reference-pointer.html"><strong aria-hidden="true">5.3.</strong> 引用Reference与指针Pointer基本概念</a></li><li class="expanded "><a href="hello-borrowing/reference-type-pointer.html"><strong aria-hidden="true">5.4.</strong> 引用、类型与原始指针解释</a></li><li class="expanded "><a href="hello-borrowing/keyword-move.html"><strong aria-hidden="true">5.5.</strong> 应用篋：移动关键词move</a></li><li class="expanded "><a href="hello-borrowing/borrowing-simple.html"><strong aria-hidden="true">5.6.</strong> 应用篋：简单借用方法</a></li><li class="expanded "><a href="hello-borrowing/borrowing-reference.html"><strong aria-hidden="true">5.7.</strong> 应用篋：引用借用实例</a></li><li class="expanded "><a href="hello-borrowing/borrowing-pointer.html"><strong aria-hidden="true">5.8.</strong> 应用篋：指针借用实例</a></li><li class="expanded "><a href="hello-borrowing/borrowing-fixed-size.html"><strong aria-hidden="true">5.9.</strong> 应用篋：固定大小类型实例</a></li><li class="expanded "><a href="hello-borrowing/borrowing-re-sizable.html"><strong aria-hidden="true">5.10.</strong> 应用篋：可变大小类型实例</a></li><li class="expanded "><a href="hello-borrowing/stack_head.html"><strong aria-hidden="true">5.11.</strong> 应用篋：栈（Stack）和堆（Head）</a></li><li class="expanded "><a href="hello-borrowing/borrowing-fn.html"><strong aria-hidden="true">5.12.</strong> 应用篋：函数借用方法</a></li><li class="expanded "><a href="hello-borrowing/bin-lib.html"><strong aria-hidden="true">5.13.</strong> 题外话：应用篋的软件包结构</a></li><li class="expanded "><a href="hello-borrowing/cargo-features.html"><strong aria-hidden="true">5.14.</strong> 题外话：Cargo工具features功能</a></li><li class="expanded "><a href="hello-borrowing/crates.html"><strong aria-hidden="true">5.15.</strong> 题外话：介绍几个软件篋</a></li></ol></li><li class="expanded "><a href="hello-deref/index.html"><strong aria-hidden="true">6.</strong> 软件篋deref_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-deref/about.html"><strong aria-hidden="true">6.1.</strong> 关于软件篋deref_exerci</a></li><li class="expanded "><a href="hello-deref/develop.html"><strong aria-hidden="true">6.2.</strong> 开发软件篋deref_exerci</a></li><li class="expanded "><a href="hello-deref/apply.html"><strong aria-hidden="true">6.3.</strong> 使用软件篋deref_exerci</a></li></ol></li><li class="expanded "><a href="hello-macro/index.html"><strong aria-hidden="true">7.</strong> 软件篋macro_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-macro/about.html"><strong aria-hidden="true">7.1.</strong> 关于软件篋macro_exerci</a></li><li class="expanded "><a href="hello-macro/develop.html"><strong aria-hidden="true">7.2.</strong> 开发软件篋macro_exerci</a></li><li class="expanded "><a href="hello-macro/apply.html"><strong aria-hidden="true">7.3.</strong> 使用软件篋macro_exerci</a></li></ol></li><li class="expanded "><a href="hello-generics/index.html"><strong aria-hidden="true">8.</strong> 软件篋generics_exerci</a></li><li><ol class="section"><li class="expanded "><a href="hello-generics/about.html"><strong aria-hidden="true">8.1.</strong> 关于软件篋generics_exerci</a></li><li class="expanded "><a href="hello-generics/develop.html"><strong aria-hidden="true">8.2.</strong> 开发软件篋generics_exerci</a></li><li class="expanded "><a href="hello-generics/apply.html"><strong aria-hidden="true">8.3.</strong> 使用软件篋generics_exerci</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">以软件篋学习Rust语言</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><em>mdbook version 0.3.4</em> <a href="https://crates.io/crates/mdbook"><img src="https://img.shields.io/crates/v/mdbook.svg" alt="crates.io" /></a>
<a href="https://github.com/rust-lang/rust"><img src="https://img.shields.io/badge/rustc-1.38+-brightgreen" alt="Minimum rustc version" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-borrowing"><img src="https://img.shields.io/appveyor/ci/cnruby/learn-rust-by-crates?label=build%20on%20appveyor.com" alt="Build Status on appveyor.com" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/issues"><img src="https://img.shields.io/github/issues/cnruby/learn-rust-by-crates" alt="GitHub issues" /></a>
<a href="https://mobile.twitter.com/cnruby"><img src="https://img.shields.io/twitter/url?style=social&amp;url=https%3A%2F%2Fmobile.twitter.com%2Fcnruby" alt="Twitter URL" /></a></p>
<blockquote>
<p>$$\text{只有分享知识，才能延续生命}$$</p>
</blockquote>
<h1><a class="header" href="#前言" id="前言">前言</a></h1>
<h2><a class="header" href="#rust语言" id="rust语言">Rust语言</a></h2>
<p>　　Rust是一门可靠高效、保证内存安全、支持安全并发和似C语言同级速度的计算机编程语言。</p>
<h2><a class="header" href="#rustup版本管理工具" id="rustup版本管理工具">rustup版本管理工具</a></h2>
<p>　　rustup是Rust语言官方的版本管理工具，负责安装Rust语言及其版本管理。通过rustup工具实现了Rust语言安装工作。</p>
<h2><a class="header" href="#cargo包管理器" id="cargo包管理器">Cargo包管理器</a></h2>
<p>　　Cargo是一款Rust语言官方的包管理器和开发工具，负责Rust软件篋的依赖管理，并且能够下载、开发、编译、生成和分发的软件篋。一旦安装了Rust语言，该工具也自动完成了安装。</p>
<h2><a class="header" href="#crateio" id="crateio">Crate.io</a></h2>
<p>　　Crate.io是Rust语言软件篋的官方仓库，负责软件篋登记、托管和存储等功能服务。</p>
<h2><a class="header" href="#rust语言编程方法" id="rust语言编程方法">Rust语言编程方法</a></h2>
<p>　　Rust语言是一门多编程（multi-programming）方法的或者说多范式（multi-paradigm）系统编程语言，它包括了：</p>
<ul>
<li>面向对象式编程</li>
<li>命令式编程</li>
<li>函数式编程</li>
<li>声明式编程</li>
<li>响应式编程</li>
<li>...</li>
</ul>
<h2><a class="header" href="#关于本书内容" id="关于本书内容">关于本书内容</a></h2>
<p>　　以开发软件篋过程，学习和理解Rust语言的全新设计思路及其重要概念。</p>
<h2><a class="header" href="#关于本书读者" id="关于本书读者">关于本书读者</a></h2>
<p>　　本书面向的读者是，致在了解Rust语言概念和设计思想，同时也学习具体程序开发的方法。</p>
<h2><a class="header" href="#关于本书使用系统说明" id="关于本书使用系统说明">关于本书使用系统说明</a></h2>
<p>　　本书程序代码使用苹果电脑系统开发的。大部分终端命令也应用适用于其它操作系统。</p>
<h2><a class="header" href="#rust语言重要网站" id="rust语言重要网站">Rust语言重要网站</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/">Rust官方网站</a></li>
<li><a href="https://rustup.rs/">rustup官方网站</a></li>
<li><a href="https://github.com/rust-lang/cargo">Cargo项目源代码</a></li>
<li><a href="https://crates.io/">Crates s.io官方网站</a></li>
</ul>
<h2><a class="header" href="#rust语言入门在线图书" id="rust语言入门在线图书">Rust语言入门在线图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/">官方网站: The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">官方网站: Rust by Example</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/index.html">Learning Rust With Entirely Too Many Linked Lists</a></li>
</ul>
<h2><a class="header" href="#rust语言在线图书" id="rust语言在线图书">Rust语言在线图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/">官方网站: The Rustonomicon</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html#a-gentle-introduction-to-rust">A Gentle Introduction To Rust</a></li>
<li><a href="https://zsiciarz.github.io/24daysofrust/index.html">24 days of Rust</a></li>
<li><a href="https://www.ralfj.de/projects/rust-101/main.html">Rust-101</a></li>
</ul>
<h2><a class="header" href="#rust语言开发参考图书" id="rust语言开发参考图书">Rust语言开发参考图书</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/index.html">官方网站: The Rust Standard Library</a></li>
<li><a href="https://doc.rust-lang.org/reference/">官方网站: The Rust Reference</a></li>
</ul>
<h2><a class="header" href="#重要工具网站" id="重要工具网站">重要工具网站</a></h2>
<ul>
<li><a href="https://www.tablesgenerator.com/">Tables Generator</a></li>
<li><a href="https://markdown-it.github.io/">markdown-it demo</a></li>
<li><a href="https://www.compart.com/de/unicode/category/So">Liste der Unicode-Zeichen der Kategorie „Sonstiges Symbol“</a></li>
<li><a href="https://sketch.io/sketchpad/">Sketchpad - Draw, Create, Share!</a></li>
<li><a href="https://shields.io/">Quality metadata badges</a></li>
<li><a href="https://www.appveyor.com/">Continuous Integration and Deployment service for Windows and Linux | AppVeyor</a></li>
<li><a href="https://github.com/nushell/nushell">Nu Shell</a></li>
<li><a href="https://markdown.de/">Markdown: Syntax</a></li>
<li><a href="https://crates.io/category_slugs">category_slugs from crates.io</a></li>
<li><a href="https://is.gd">Compress That Address</a></li>
<li><a href="https://gist.github.com/rust-play">The Rust Playground Codes</a></li>
<li><a href="https://doc.rust-lang.org/stable/error-index.html">stable error-index</a></li>
<li><a href="https://daringfireball.net/projects/markdown/basics">markdown basics</a></li>
</ul>
<h1><a class="header" href="#本书项目结构" id="本书项目结构">本书项目结构</a></h1>
<h2><a class="header" href="#篇目" id="篇目">篇目</a></h2>
<ol>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%92%8C%E7%AF%8B">作业区和篋</a></li>
<li><a href="foreword/about.html#%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">共享篋和应用程序</a></li>
<li><a href="foreword/about.html#%E4%BD%9C%E4%B8%9A%E5%8C%BA%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">作业区命名法则</a></li>
<li><a href="foreword/about.html#%E7%AF%8B%E5%91%BD%E5%90%8D%E6%B3%95%E5%88%99">篋命名法则</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：项目类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">实例：篋类型清单</a></li>
<li><a href="foreword/about.html#%E5%AE%9E%E4%BE%8B%E4%BD%9C%E4%B8%9A%E5%8C%BA%E6%89%80%E6%9C%89%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">实例：作业区所有目录文件清单</a></li>
<li><a href="foreword/about.html#%E6%9C%AC%E4%B9%A6%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">本书使用符号说明</a></li>
<li><a href="foreword/about.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#作业区和篋" id="作业区和篋">作业区和篋</a></h2>
<p>　　Cargo项目是Cargo工具所生成的目录和文件内容，称之为软件篋，或者简称为篋。</p>
<p>　　软件篋项目是由若干个Cargo项目或者说软件篋组成，在本书里，软件篋项目也简称为作业区（workspace）、整体项目或者项目。所有Cargo项目都是在作业区目录之下，且这些项目在相同目录层上。所有项目名称也是目录名称。每一章最顶层目录是作业区目录。</p>
<h2><a class="header" href="#共享篋和应用程序" id="共享篋和应用程序">共享篋和应用程序</a></h2>
<p>　　每一个软件篋源代码存在于一个Cargo项目里。</p>
<p>　　把Cargo项目软件篋（library package）发布到网站crates.io的共享软件篋，简称共享篋。</p>
<p>　　除了这个共享软件篋的Cargo项目外，还有一个使用本地共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为本地程序。其目的是在发布共享篋之前，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<p>　　另外，一个使用仓库crates.io里共享篋的可执行应用程序Cargo项目（binary package），称为可执行的本地程序，或者简称为仓库程序。其目的是在发布共享软件篋之后，作为完全独立的Cargo项目，来测试和应用该共享软件篋。</p>
<h2><a class="header" href="#作业区命名法则" id="作业区命名法则">作业区命名法则</a></h2>
<p>　　作业区目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#篋命名法则" id="篋命名法则">篋命名法则</a></h2>
<p>　　按照Rust语言命名法则，共享软件篋名称使用小蛇式命名（lower snake case）。</p>
<p>　　可执行程序。其目录名称的命名法则，可以是使用短横线命名（kebab-case），也可以使用小蛇式命名（lower snake case）。</p>
<h2><a class="header" href="#实例项目类型清单" id="实例项目类型清单">实例：项目类型清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例篋类型清单" id="实例篋类型清单">实例：篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
</tbody></table>
<hr/>
<h2><a class="header" href="#实例作业区所有目录文件清单" id="实例作业区所有目录文件清单">实例：作业区所有目录文件清单</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── hello.rs
    └── lib-hello
        ├── Cargo.lock
        ├── Cargo.toml
        ├── Cargo.txt
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   └── lib.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.r
</code></pre>
<h2><a class="header" href="#本书使用符号说明" id="本书使用符号说明">本书使用符号说明</a></h2>
<table><thead><tr><th>符号</th><th>英文单词</th><th>说明</th><th>要求</th><th>实例</th></tr></thead><tbody>
<tr><td>Ⓓ</td><td>default</td><td>叙述Rust语言默认情况</td><td>必须记住</td><td>Ⓓ 所有模块和函数默认情况下都是私有的。</td></tr>
<tr><td>ⓡ</td><td>regulation</td><td>阐述Rust语言规则</td><td>必须记住</td><td>ⓡ 所有字符串文字类型都是引用，且具有静态生命周期。</td></tr>
<tr><td>Ⓒ</td><td>consensus</td><td>解释约定而非强制方法</td><td>最好记住</td><td>Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</td></tr>
<tr><td>Ⓘ</td><td>idea</td><td>必须记住</td><td>计算机技术和Rust语言基本概念</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于作业区和软件篋crate实例" id="关于作业区和软件篋crate实例">关于作业区和软件篋（Crate）实例</a></h1>
<p>　　软件篋（Crate）是其他语言的库（library）或包（package）的同义词。软件篋可以生成这里称之为应用程序的可执行文件或共享库，</p>
<h2><a class="header" href="#实例创建作业区空间" id="实例创建作业区空间">实例：创建作业区空间</a></h2>
<pre><code class="language-bash"># 创建一个工作空间
mkdir workpsaces &amp;&amp; cd workpsaces
</code></pre>
<h2><a class="header" href="#实例创建作业区" id="实例创建作业区">实例：创建作业区</a></h2>
<pre><code class="language-bash"># 创建一个作业区hello-world
mkdir hello-world &amp;&amp; cd hello-world
# 创建一个作业区配置文件
touch Cargo.toml
# 作业区存在四个软件篋
# 注意：下面两行代码是一行命令
echo '[workspace]
members = [&quot;lib-hello&quot;, &quot;bin-hello&quot;, &quot;bin-local-hello&quot;, &quot;lib-extern&quot;]' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#实例创建默认共享软件篋程序命令" id="实例创建默认共享软件篋程序命令">实例：创建默认共享软件篋程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;crate-project-name&gt;
# 命令实例，如创建名称为lib-hello的共享篋程序项目目录
mkdir lib-hello
# 进入软件篋程序根目录
cd lib-hello
# 命令说明：
# cargo init --name &lt;crate_name&gt; --lib
# 命令实例，如创建名称为hello_exercism的软件篋程序
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#实例创建默认可执行的应用程序命令" id="实例创建默认可执行的应用程序命令">实例：创建默认可执行的应用程序命令</a></h2>
<pre><code class="language-bash"># 进入作业区根目录
# 命令说明：
# mkdir &lt;app-project-name&gt;
# 命令实例，如创建名称为bin-hello的应用程序项目目录
mkdir bin-hello
# 进入应用程序根目录
cd bin-hello
# 命令说明
# cargo init --name &lt;app-name&gt; --bin
# 命令实例，如创建名称为bin-hello的应用程序
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#实例说明共享软件篋结构" id="实例说明共享软件篋结构">实例：说明共享软件篋结构</a></h2>
<p>　　使用软件工具Cargo，在默认Cargo项目基础上，这里除了增加了默认说明文件README.md外，还有增加了两个Cargo默认目录：tests和examples，同时在两个目录下增加了两个rust程序文件，其结果如下：</p>
<pre><code>── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   └── hello.rs
    ├── src
    │   └── lib.rs
    └── tests
        └── hello.rs
</code></pre>
<p>　　在上面的结构里，除了两个文件hello.rs之外，其他都是Cargo项目的默认目录和文件。这些目录和文件都是与Cargo工具默认命令相关的。Cargo项目还有其他默认目录和文件。目录src下的默认文件lib.rs是共享篋的入口文件。</p>
<h2><a class="header" href="#参考资料" id="参考资料">参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html">a4.cargo,crates_and_basic_project_structure</a></li>
</ul>
<h1><a class="header" href="#关于cargo工具基础命令" id="关于cargo工具基础命令">关于Cargo工具基础命令</a></h1>
<p>　　安装Rust语言软件篋存在两个行为，其目的和作用是不同的。使用软件工具rustup安装的软件篋是支持版本管理工具，而使用软件工具Cargo安装的软件篋是支持项目级开发环境。</p>
<h2><a class="header" href="#编写规范格式代码工具-rustfmt" id="编写规范格式代码工具-rustfmt">编写规范格式代码工具 Rustfmt</a></h2>
<h3><a class="header" href="#安装rustfmt命令" id="安装rustfmt命令">安装Rustfmt命令</a></h3>
<pre><code>rustup self update
rustup component add rustfmt
</code></pre>
<h3><a class="header" href="#使用rustfmt命令" id="使用rustfmt命令">使用Rustfmt命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo fmt
</code></pre>
<h2><a class="header" href="#编写有效代码工具-clippy" id="编写有效代码工具-clippy">编写有效代码工具 Clippy</a></h2>
<h3><a class="header" href="#安装clippy命令" id="安装clippy命令">安装Clippy命令</a></h3>
<pre><code>rustup self update
rustup component add clippy
</code></pre>
<h3><a class="header" href="#使用clippy命令" id="使用clippy命令">使用Clippy命令</a></h3>
<pre><code class="language-bash"># 进来Cargo项目根目录
cargo clippy
</code></pre>
<h2><a class="header" href="#说明cargo软件篋开发命令" id="说明cargo软件篋开发命令">说明Cargo软件篋开发命令</a></h2>
<p>　　除了上面两个开发工具命令之外，Cargo项目还有自身命令：</p>
<h3><a class="header" href="#测试代码运行命令" id="测试代码运行命令">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目和作业区 --
# 进来Cargo项目根目录
# 默认测试命令
# 说明：测试在目录tests下的所有测试文件
cargo test
</code></pre>
<h3><a class="header" href="#运行应用程序命令" id="运行应用程序命令">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于所有Cargo项目 --
# 进来Cargo项目根目录
# 命令说明：
# cargo run --example &lt;程序文件名称&gt;
# 命令实例，如运行在目录examples下文件名称为hello.rs的应用程序
cargo run --example hello
</code></pre>
<h3><a class="header" href="#运行应用程序命令-1" id="运行应用程序命令-1">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 仅适用于Cargo应用程序项目 --
# 进来Cargo项目根目录
# 默认运行命令
# 说明：运行目录src下默认入口文件main.rs
cargo run
</code></pre>
<h2><a class="header" href="#说明cargo作业区开发命令" id="说明cargo作业区开发命令">说明Cargo作业区开发命令</a></h2>
<h3><a class="header" href="#测试代码运行命令-1" id="测试代码运行命令-1">测试代码运行命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区和所有Cargo项目 --
# 进来作业区根目录
# 命令说明：
# cargo test --package &lt;篋名称&gt;
# 或者
# cargo test -p &lt;篋名称&gt;
# 命令实例，如运行在Cargo项目lib-hello下共享篋名称为hello_exercism
cargo test -p hello_exercism
</code></pre>
<h3><a class="header" href="#运行应用程序命令-2" id="运行应用程序命令-2">运行应用程序命令</a></h3>
<pre><code class="language-bash"># -- 适用于Cargo作业区内Cargo应用程序项目 --
# 进来作业区根目录
# 命令说明：
# cargo run --package &lt;篋名称&gt;
# 或者
# cargo run -p &lt;软件篋名称&gt;
# 命令实例，如运行在Cargo项目bin-hello下篋名称为bin-hello
cargo run -p bin-hello
</code></pre>
<p>　　后续还将介绍上面Cargo工具的其他实用命令。</p>
<h1><a class="header" href="#rust语言新思维和新概念" id="rust语言新思维和新概念">Rust语言新思维和新概念</a></h1>
<h2><a class="header" href="#变量生命期" id="变量生命期">变量生命期</a></h2>
<h2><a class="header" href="#不可变量immutable和可变量mutable" id="不可变量immutable和可变量mutable">不可变量(Immutable)和可变量(Mutable)</a></h2>
<h2><a class="header" href="#表达式expression和语句statements" id="表达式expression和语句statements">表达式(Expression)和语句(statements)</a></h2>
<h2><a class="header" href="#方法method和函数function" id="方法method和函数function">方法(method)和函数(function)</a></h2>
<h2><a class="header" href="#类和对象" id="类和对象">类和对象</a></h2>
<h2><a class="header" href="#全局软件篋和项目软件篋" id="全局软件篋和项目软件篋">全局软件篋和项目软件篋</a></h2>
<p><a href="https://crates.io/crates/hello_exercism"><img src="https://img.shields.io/crates/v/hello_exercism?label=hello_exercism" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world"><img src="https://img.shields.io/badge/hello--world-code-yellowgreen" alt="The Crate hello_exercism Code" /></a></p>
<h1><a class="header" href="#关于软件篋项目hello-world" id="关于软件篋项目hello-world">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#项目目标" id="项目目标">项目目标</a></h2>
<p>　　学习和理解如何开发Rust语言的软件篋基本思路和方法，同时了解该项目的其他Cargo项目开发过程和方法。</p>
<h2><a class="header" href="#主题内容" id="主题内容">主题内容</a></h2>
<ul>
<li>了解和学习Cargo工具作业区概念</li>
<li>学习和理解共享软件篋整个开发过程</li>
<li>了解和学习单元测试和集成测试基本概念</li>
</ul>
<h2><a class="header" href="#关键词内容" id="关键词内容">关键词内容</a></h2>
<table><thead><tr><th>说明</th><th>关键词</th><th>链接</th></tr></thead><tbody>
<tr><td>实例定义</td><td>let</td><td></td></tr>
<tr><td>公共修饰</td><td>pub</td><td></td></tr>
<tr><td>函数和方法</td><td>fn</td><td></td></tr>
<tr><td>模块定义</td><td>mod</td><td></td></tr>
<tr><td>生命周期修饰</td><td>'</td><td></td></tr>
<tr><td>静态修饰</td><td>static</td><td></td></tr>
<tr><td>模块关联</td><td>super</td><td></td></tr>
<tr><td>无名氏</td><td>_</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#类型内容" id="类型内容">类型内容</a></h2>
<table><thead><tr><th>归类</th><th>数据类型</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>基本数据类型</td><td>&amp;str</td><td>字符串文字</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#宏内容" id="宏内容">宏内容</a></h2>
<table><thead><tr><th>归类</th><th>宏名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库宏</td><td>println!</td><td>打印输出</td><td></td></tr>
<tr><td>标准库宏</td><td>assert_eq!</td><td>相同值测试</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#注释内容" id="注释内容">注释内容</a></h2>
<table><thead><tr><th>归类</th><th>注释名</th><th>说明</th><th>链接</th></tr></thead><tbody>
<tr><td>标准库注释</td><td>#[test]</td><td>注释测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[cfg(test)]</td><td>注释有条件运行测试函数</td><td></td></tr>
<tr><td>标准库注释</td><td>#[path=&quot;.&quot;]</td><td>注释模块路径</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#命名规范" id="命名规范">命名规范</a></h2>
<table><thead><tr><th>命名对象</th><th>命名规范</th><th>实例</th><th>链接</th></tr></thead><tbody>
<tr><td>共享软件箧</td><td>小蛇式命名</td><td>hello_exercism</td><td></td></tr>
<tr><td>程序软件箧</td><td>小蛇式命名或短横线命名</td><td>bin-hello</td><td></td></tr>
<tr><td>函数和方法</td><td>小蛇式命名</td><td>it_works_at_private()</td><td></td></tr>
<tr><td>模块</td><td>小蛇式命名</td><td>owned_hello</td><td></td></tr>
<tr><td>变量</td><td>小蛇式命名</td><td>_</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#关于软件篋项目hello-world-1" id="关于软件篋项目hello-world-1">关于软件篋项目hello-world</a></h1>
<h2><a class="header" href="#学习内容" id="学习内容">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
<li>了解项目目录和文件结构</li>
</ul>
<h2><a class="header" href="#篇目-1" id="篇目-1">篇目</a></h2>
<ol>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-world/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%B8%85%E5%8D%95">项目目录清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95">项目文件清单</a></li>
<li><a href="hello-world/about.html#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A0%91">项目结构树</a></li>
<li><a href="hello-world/about.html#%E9%A2%98%E5%A4%96%E8%AF%9D%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%91%BD%E4%BB%A4">题外话：目录与命令</a></li>
</ol>
<h2><a class="header" href="#项目名称清单" id="项目名称清单">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-world</strong></td><td>./hello-world</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-world/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
<tr><td>共享篋</td><td>lib-extern</td><td>./hello-world/lib-extern</td><td>作为第三方共享篋实例使用</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单" id="软件篋类型清单">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>hello_exercism</strong></td><td>./hello-world/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-world/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-world/bin-hello</td></tr>
<tr><td>共享软件篋</td><td>hello_extern</td><td>./hello-world/lib-extern</td></tr>
</tbody></table>
<h2><a class="header" href="#项目目录清单" id="项目目录清单">项目目录清单</a></h2>
<table><thead><tr><th>目录名称</th><th>根目录说明</th><th>生成方式</th></tr></thead><tbody>
<tr><td>src</td><td>篋源代码目录</td><td>Cargo命令</td></tr>
<tr><td>src/integration_tests</td><td>篋源代码集成测试目录</td><td>用户手动命令</td></tr>
<tr><td>src/private_tests</td><td>篋源代码私有代码测试目录</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>篋测试源代码目录</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>篋实例源代码目录</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>篋构建目录</td><td>Cargo命令</td></tr>
<tr><td>debug</td><td>篋调试构建目录</td><td>Cargo命令</td></tr>
<tr><td>release</td><td>篋版本构建目录</td><td>Cargo命令</td></tr>
</tbody></table>
<h2><a class="header" href="#项目文件清单" id="项目文件清单">项目文件清单</a></h2>
<table><thead><tr><th>名称</th><th>说明</th><th>内容属性</th><th>名称属性</th></tr></thead><tbody>
<tr><td>README.md</td><td>项目说明文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.lock</td><td>项目配置锁定文件</td><td>不可修改</td><td>不可修改</td></tr>
<tr><td>Cargo.toml</td><td>项目配置锁定文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>main.rs</td><td>可执行软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>lib.rs</td><td>共享软件篋的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>mod.rs</td><td>篋模块的入口文件</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>i_hello.rs</td><td>集成测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>u_hello.rs</td><td>单元测试或者实例文件</td><td>可修改</td><td>可修改</td></tr>
<tr><td>owned_hello.rs</td><td>私有代码测试文件</td><td>可修改</td><td>可修改</td></tr>
</tbody></table>
<h2><a class="header" href="#项目结构树" id="项目结构树">项目结构树</a></h2>
<pre><code>── hello-world
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── bin-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── bin-local-hello
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── src
    │   │   └── main.rs
    │   └── tests
    │       └── i_hello.rs
    ├── lib-extern
    │   ├── Cargo.toml
    │   ├── README.md
    │   ├── src
    │   │   └── lib.rs
    │   └── tests
    │       └── u_hello.rs
    └── lib-hello
        ├── Cargo.toml
        ├── README.md
        ├── examples
        │   ├── i_hello.rs
        │   ├── main.rs
        │   └── u_hello.rs
        ├── src
        │   ├── integration_tests
        │   │   ├── i_hello.rs
        │   │   └── mod.rs
        │   ├── lib.rs
        │   └── private_tests
        │       ├── mod.rs
        │       └── owned_hello.rs
        └── tests
            ├── i_hello.rs
            └── u_hello.rs
</code></pre>
<h2><a class="header" href="#题外话目录与命令" id="题外话目录与命令">题外话：目录与命令</a></h2>
<table><thead><tr><th>目录名称</th><th>生成命令</th><th>删除命令</th></tr></thead><tbody>
<tr><td>src</td><td>cargo new &lt;project_name&gt; <br/> cargo new &lt;project_name&gt; --lib <br/> cargo new &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; <br/> cargo init --name &lt;project_name&gt; --bin <br/> cargo init --name &lt;project_name&gt; --lib</td><td>用户手动命令</td></tr>
<tr><td>tests</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>examples</td><td>用户手动命令</td><td>用户手动命令</td></tr>
<tr><td>target</td><td>随下面命令自动生成</td><td>cargo clean</td></tr>
<tr><td>debug</td><td>cargo build 或者 cargo run</td><td>cargo clean --target-dir target/debug</td></tr>
<tr><td>release</td><td>cargo build --release <br/> cargo run --release</td><td>cargo clean --release <br/> cargo clean --target-dir target/release</td></tr>
</tbody></table>
<h1><a class="header" href="#共享篋开发命令" id="共享篋开发命令">共享篋：开发命令</a></h1>
<h2><a class="header" href="#学习内容-1" id="学习内容-1">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用共享篋项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-2" id="篇目-2">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-lib.html#%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%AF%8B%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建共享篋项目命令</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和单元测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">开发共享篋的单元实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">开发共享篋和集成测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">执行共享篋和测试代码</a></li>
<li><a href="hello-world/commands-lib.html#%E6%89%A7%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">执行共享篋的实例代码</a></li>
<li><a href="hello-world/commands-lib.html#%E5%BC%80%E5%8F%91%E5%85%B1%E4%BA%AB%E7%AF%8B%E6%96%87%E6%A1%A3">开发共享篋文档</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">发布共享篋准备工作</a></li>
<li><a href="hello-world/commands-lib.html#%E5%8F%91%E5%B8%83%E5%85%B1%E4%BA%AB%E7%AF%8B">发布共享篋</a></li>
</ol>
<h2><a class="header" href="#创建共享篋项目命令" id="创建共享篋项目命令">创建共享篋项目命令</a></h2>
<pre><code class="language-bash"># 创建共享篋项目命令
# 先进入作业区根目录，且创建项目目录，然后进入共享篋根目录
mkdir lib-hello &amp;&amp; cd lib-hello
# 创建名称为hello_exercism的共享篋
cargo init --name hello_exercism --lib
</code></pre>
<h2><a class="header" href="#开发共享篋和单元测试代码" id="开发共享篋和单元测试代码">开发共享篋和单元测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和单元测试代码
vi Cargo.toml
vi src/lib.rs
mkdir tests
touch tests/u_hello.rs
vi tests/u_hello.rs
touch tests/i_hello.rs
vi tests/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码" id="开发共享篋的单元实例代码">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋的单元实例代码-1" id="开发共享篋的单元实例代码-1">开发共享篋的单元实例代码</a></h2>
<pre><code class="language-bash"># 开发共享篋的单元实例代码
mkdir examples
touch examples/u_hello.rs
vi examples/u_hello.rs
</code></pre>
<h2><a class="header" href="#开发共享篋和集成测试代码" id="开发共享篋和集成测试代码">开发共享篋和集成测试代码</a></h2>
<pre><code class="language-bash"># 开发共享篋和集成测试代码
echo 'i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}' &gt;&gt; Cargo.toml
touch tests/i_hello.rs
vi tests/i_hello.rs
touch examples/i_hello.rs
vi examples/i_hello.rs
</code></pre>
<h2><a class="header" href="#执行共享篋和测试代码" id="执行共享篋和测试代码">执行共享篋和测试代码</a></h2>
<pre><code class="language-bash"># 执行共享篋和测试代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo test
</code></pre>
<h2><a class="header" href="#执行共享篋的实例代码" id="执行共享篋的实例代码">执行共享篋的实例代码</a></h2>
<pre><code class="language-bash"># 执行共享篋的实例代码
# 这些命令需要重复运行
cargo fmt
cargo clippy
cargo run --example u_hello
cargo run --example i_hello
</code></pre>
<h2><a class="header" href="#开发共享篋文档" id="开发共享篋文档">开发共享篋文档</a></h2>
<pre><code class="language-bash"># 开发共享篋文档
mkdir -p ../../docs/hello-world
cargo doc
cp -rf ../target/doc/. ../../docs/hello-world/.
</code></pre>
<h2><a class="header" href="#发布共享篋准备工作" id="发布共享篋准备工作">发布共享篋准备工作</a></h2>
<pre><code class="language-bash"># 发布共享篋准备工作
# 注册网站crates.io帐号
# 登录网站crates.io
# 从网站crates.io获取token，如下所示
# 在本地电脑运行下面命令
cargo login &lt;token&gt;
</code></pre>
<p><img src="hello-world/../../images/crates_io_api_access_new_token.png" alt="image" />
<img src="hello-world/../../images/crates_io_api_access_create.png" alt="image" /></p>
<h2><a class="header" href="#发布共享篋" id="发布共享篋">发布共享篋</a></h2>
<pre><code class="language-bash">## 提交代码
cargo package
cargo publish
</code></pre>
<h1><a class="header" href="#共享软件篋hello_exercism程序代码解释" id="共享软件篋hello_exercism程序代码解释">共享软件篋hello_exercism：程序代码解释</a></h1>
<p>　　共享软件篋本身只能提供给其他共享篋和应用程序使用。Cargo工具实现了项目内所有目录和文件有机联系在一起。当运行测试代码或者实例代码时，这些代码都知道应该怎么样连接到正在开发的共享篋。</p>
<h2><a class="header" href="#学习内容-2" id="学习内容-2">学习内容</a></h2>
<ul>
<li>阐述共享篋文件功能</li>
<li>理解项目共享篋程序代码</li>
</ul>
<h2><a class="header" href="#篇目-3" id="篇目-3">篇目</a></h2>
<ol>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/lib.html#%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6librs%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">程序文件lib.rs的核心代码</a></li>
<li><a href="hello-world/lib.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B">静态生命周期的字符串文字类型</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dmod%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8Dpub">关键词mod与关键词pub</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8D%95%E5%85%83%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的单元实例文件</a></li>
<li><a href="hello-world/lib.html#%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E9%9B%86%E6%88%90%E5%AE%9E%E4%BE%8B%E6%96%87%E4%BB%B6">实例目录的集成实例文件</a></li>
<li><a href="hello-world/lib.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-world/lib.html#rust%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E8%AF%8D">Rust语言类型与关键词</a></li>
<li><a href="hello-world/lib.html#%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9A%84%E6%A8%A1%E5%9D%97">浅谈软件篋的模块</a></li>
<li><a href="hello-world/lib.html#%E5%85%B3%E9%94%AE%E8%AF%8Dlet">关键词let</a></li>
<li><a href="hello-world/lib.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A8%A1%E5%9D%97">表达式、语句和模块</a></li>
<li><a href="hello-world/lib.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">项目配置文件</a></li>
<li><a href="hello-world/lib.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml" id="项目配置文件cargotoml">项目配置文件Cargo.toml</a></h2>
<p>　　文件Cargo.toml是由用户编写的描述项目共享篋依赖关系。而文件Cargo.lock包含有关共享软件篋的依赖项的确切信息。它是由Cargo工具自动生成和维护的，不应手动对其进行编辑。</p>
<pre><code class="language-toml"># Crate Configuration File: ./Cargo.toml
[package]
name = &quot;hello_exercism&quot;
version = &quot;0.5.5&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
repository = &quot;https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-world&quot;
homepage = &quot;https://crates.io/crates/hello_exercism&quot;
documentation = &quot;https://cnruby.github.io/learn-rust-by-crates/hello-world/hello_exercism/&quot;
categories = [&quot;development-tools::testing&quot;]
description = &quot;how to create an own crate&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#hello_extern = { version = &quot;0.1.1&quot;}
i_crate = { version = &quot;0.1.1&quot;, package = &quot;hello_extern&quot;}
</code></pre>
<p>　　在文件Cargo.toml里，最重要的一项是共享软件篋名称：name。这是使用该共享篋的入口名称。这里默认模块名称为hello_exercism。</p>
<p>　　最常用的一节是共享篋依赖关系：[dependencies]。这里有一行依赖关系代码，说明共享篋有赖于外部共享篋。这里使用了软件篋hello_exercism的已经发布的版本，只是为了解释问题和说明方便，实际上可以依赖所有需要的共享篋。</p>
<h2><a class="header" href="#程序文件librs的核心代码" id="程序文件librs的核心代码">程序文件lib.rs的核心代码</a></h2>
<p>　　程序文件lib.rs是由三部分代码。第一部分是共享篋核心代码：两个函数hello()和hallo()。第二部分是私有代码测试函数。第三部分是集成测试函数。这里仅仅说明该程序两个函数的功能，将在后面章节说明其它两个部分的测试代码。</p>
<p>　　程序文件lib.rs是共享篋的入口文件。它有两个函数hello()和hallo()，其功能都是返回一个字符串文字。hello()返回英文问候，而hallo()返回德文问候。它们返回的类型也都是&amp;'static str的字符串，这一类型是静态生命周期的字符串文字。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
<span class="boring">[cfg(test)]
[path = &quot;./private_tests/owned_hello.rs&quot;]
</span>mod owned_hello;

// code 2
<span class="boring">[cfg(test)]
[path = &quot;./private_tests/mod.rs&quot;]
</span>mod private_tests;

// code 3
<span class="boring">[cfg(test)]
</span>mod private_tests_with_use {
    use super::*;
    //use super::hallo;

<span class="boring">    [test]
</span>    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
<span class="boring">[cfg(test)]
</span>mod private_tests_without_use {
<span class="boring">    [test]
</span>    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
<span class="boring">[cfg(test)]
[path = &quot;./integration_tests/i_hello.rs&quot;]
</span>mod i_hello;

<span class="boring">[cfg(test)]
[path = &quot;./integration_tests/mod.rs&quot;]
</span>mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#静态生命周期的字符串文字类型" id="静态生命周期的字符串文字类型">静态生命周期的字符串文字类型</a></h2>
<p>　　程序文件lib.rs里，两个函数的返回类型都是：静态生命周期的字符串文字类型。</p>
<p>　　ⓡ 所有字符串文字类型都是引用，且具有静态生命周期的功能。</p>
<p>　　↳ 这里的函数返回值是包含一个引用字符串文字类型值，所以函数返回类型也要此类型<code>&amp;str</code>。因为在整个程序过程中需要该类型是有效的，所以此类型还要增加静态生命周期<code>'static</code>修饰关键词。</p>
<h2><a class="header" href="#关键词mod与关键词pub" id="关键词mod与关键词pub">关键词mod与关键词pub</a></h2>
<p>　　Ⓓ 在默认情况下，无论使用关键词mod定义的模块，还使用关键词fn定义的函数，它们都是私有的。要使得它们可公开访问的话，就需要使用修饰词关键词'pub'。</p>
<p>　　↳ 程序文件lib.rs里，hello()是公共可访问的函数，而hallo()只是模块hello_exercism内可访问的私有函数。该软件篋的公共接口只有：函数hello()。</p>
<p>　　Ⓓ 共享篋模块默认是公开的。</p>
<p>　　↳ 这里共享篋模块名称是hello_exercism，尽管既没有关键词mod也没有关键词pub出现，但是Rust语言已经给了该模块名称这两个关键词。</p>
<h2><a class="header" href="#实例目录的单元实例文件" id="实例目录的单元实例文件">实例目录的单元实例文件</a></h2>
<p>　　单元实例仅仅测试此软件篋自身的功能。</p>
<p>　　ⓡ 凡是存在main()函数的Rust程序都是可执行的。</p>
<p>　　这个程序的功能是调用了该项目的软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。</p>
<p>　　Ⓓ 在运行实例目录下可执行文件时，Cargo工具自动会调用程序lib.rs。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/u_hello.rs
fn main() {
    println!(&quot;{}&quot;, hello_exercism::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example u_hello -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#实例目录的集成实例文件" id="实例目录的集成实例文件">实例目录的集成实例文件</a></h2>
<p>　　集成实例测试此共享篋与外部其它共享篋的功能。</p>
<p>　　这个程序的功能是调用了外部软件篋hello_exercism程序的函数hello()，且打印调用函数的结果。这也是该共享篋的功能。此外，还比较了正在开发的软件篋与外部软件篋的函数返回值。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: examples/i_hello.rs
fn main() {
    println!(&quot;{}&quot;, i_crate::hello());
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}
</code></pre></pre>
<p>　　在共享篋里的实例目录下的可执行的Rust程序，使用下面命令执行，且得到执行结果如下：</p>
<pre><code class="language-bash"># 从该共享篋项目的根目录执行下面命令；
$ cargo run --example i_hello -q
Hello, World!
Hallo, Welt!
</code></pre>
<h2><a class="header" href="#题外话" id="题外话">题外话</a></h2>
<h3><a class="header" href="#rust语言类型与关键词" id="rust语言类型与关键词">Rust语言类型与关键词</a></h3>
<p>　　对于修饰词关键词'static'，Rust语言以与常量类似的方式提供了类似“全局变量”的功能。对每一个值只有一个实例，并且位于内存中的固定位置。</p>
<p>　　在Rust语言里，存在一类关键词是修饰词关键词，如关键词&quot;pub&quot;和“static”。</p>
<table><thead><tr><th>类型</th><th>关键词</th><th>类型说明</th></tr></thead><tbody>
<tr><td>&amp;str</td><td></td><td>字符串文字</td></tr>
<tr><td></td><td>static</td><td>静态修饰词关键词</td></tr>
<tr><td></td><td>'</td><td>生命周期关键词</td></tr>
<tr><td></td><td>'static</td><td>静态生命周期关键词</td></tr>
<tr><td>&amp;'static str</td><td></td><td>静态生命周期字符串文字</td></tr>
</tbody></table>
<h3><a class="header" href="#浅谈软件篋的模块" id="浅谈软件篋的模块">浅谈软件篋的模块</a></h3>
<p>　　每一个共享篋都有自己的入口模块名称，这里是hello_exercism，使用共享篋都要从这个名称开始，这里模块hello_exercism有自己的函数hello()。在程序文件lib.rs内还，可以使用关键词mod再定义模块名称，但是它们都是hello_exercism的子模块。</p>
<h3><a class="header" href="#关键词let" id="关键词let">关键词let</a></h3>
<p>　　从作用意义上，共享篋的函数hello()类似于使用关键词let语句，即可把它看作为一个类型为&amp;str的字符串文字与一个变量绑定，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">// Rust File: examples/main.rs
fn main() {
    let _: &amp;'static str = &quot;Hello, World!&quot;;
    let _: &amp;str = &quot;Hello, World!&quot;;
}

</code></pre></pre>
<h3><a class="header" href="#表达式语句和模块" id="表达式语句和模块">表达式、语句和模块</a></h3>
<p>　　在Rust语言里，表达式和语句都可以作为一行代码。要是一行代码，最后没有分号就是表达式，而有分号就是语句。表达式只有作为函数的返回值。</p>
<p>　　表达式和语句可以汇聚成一个由{}内的代码块和由关键词fn开始的函数与方法。函数和方法可以组成一个由关键词mod开始的模块。若干个模块可以形成由关键词mod开始的父模块。</p>
<h3><a class="header" href="#项目配置文件" id="项目配置文件">项目配置文件</a></h3>
<p>　　除了项目配置文件Cargo.toml之外，还可以有其它功能的配置文件，如工具rustfmt的配置文件。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://blog.csdn.net/s_lisheng/article/details/79287713">Rust中的const和static</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying-dependencies</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录tests的测试代码解释" id="共享篋hello_exercism目录tests的测试代码解释">共享篋hello_exercism：目录tests的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-3" id="学习内容-3">学习内容</a></h2>
<ul>
<li>理解开发共享篋的测试代码</li>
<li>了解公共接口的单元测试方法</li>
<li>了解目录tests的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-4" id="篇目-4">篇目</a></h2>
<ol>
<li><a href="hello-world/lib-tests.html#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6u_hellors">公共接口的单元测试文件u_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试与公共接口的单元测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">基于目录tests的集成测试文件i_hello.rs</a></li>
<li><a href="hello-world/lib-tests.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%9F%BA%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95tests%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试与基于测试目录tests的集成测试</a></li>
<li><a href="hello-world/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#公共接口的单元测试文件u_hellors" id="公共接口的单元测试文件u_hellors">公共接口的单元测试文件u_hello.rs</a></h2>
<p>　　在下面的单元测试程序里，只有一个测试函数，其功能是判断函数hello()返回值与字符串文字“Hello, World!”是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/u_hello.rs
<span class="boring">[cfg(test)]
</span>mod tests {
<span class="boring">    [test]
</span>    fn it_works_at_uint() {
        assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
    }
}
</code></pre></pre>
<h2><a class="header" href="#单元测试与公共接口的单元测试" id="单元测试与公共接口的单元测试">单元测试与公共接口的单元测试</a></h2>
<p>　　Ⓘ 单元测试（Unit tests）是单个模块或者说单个软件篋的单独测试。</p>
<p>　　一般情况下，单元测试很小且可以测试私有代码。它们的目的是软件篋每一个功能能否正常工作。Rust语言将单元测试分成两类：这里探讨公共接口的单元测试和下面将要说明的私有代码的单元测试。</p>
<p>　　ⓡ 从模块范围之外只能访问模块的公共接口，而不能访问模块的私有内容。</p>
<p>　　Ⓒ 大多数单元测试都带有注解'#[cfg(test)]'的测试模块。</p>
<p>　　ⓡ 每一个单元测试函数带有'#[test]'注解标记。测试文件名称命名是由用户自己确定的。</p>
<p>　　每个测试函数都是单独地调用正在开发的共享软件篋进行运行的。因此Cargo工具将共享软件篋纳入到每个测试函数的范围里。</p>
<p>　　Ⓓ 所有公共接口的单元测试文件存储于默认测试目录tests下。</p>
<h2><a class="header" href="#基于目录tests的集成测试文件i_hellors" id="基于目录tests的集成测试文件i_hellors">基于目录tests的集成测试文件i_hello.rs</a></h2>
<p>　　在下面的集成测试程序里，有两个测试函数，第一个函数功能是判断外部共享篋的函数hello()返回值与字符串文字“Hello, World!”是否完全一致。第二个函数功能是判断正在开发共享篋与外部共享篋的函数hello()返回值是否完全一致。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: tests/i_hello.rs
<span class="boring">[test]
</span>fn it_works_with_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

<span class="boring">[test]
</span>fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试与基于测试目录tests的集成测试" id="集成测试与基于测试目录tests的集成测试">集成测试与基于测试目录tests的集成测试</a></h2>
<p>　　Ⓘ 集成测试（Integration tests）是与外部的多个共享篋的测试。它们比较大，但仅测试正在开发共享篋的公共接口。它们的目的是与其它篋能否正常协同工作。</p>
<p>　　集成测试可以存储于这里探讨的基于测试目录tests，也可以存储于下面将要解释的基于共享篋目录src。但是它们处理代码的方式是完全不同的。</p>
<p>　　Ⓒ 集成测试不需要使用注释'#[cfg(test)]'来注释任何测试代码。</p>
<p>　　ⓡ 每一个单元测试函数注解带有'#[test]'标记。</p>
<p>　　ⓡ 在默认情况下，集成测试文件存储于测试目录tests下。</p>
<h2><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#共享篋hello_exercism目录src的测试代码解释" id="共享篋hello_exercism目录src的测试代码解释">共享篋hello_exercism：目录src的测试代码解释</a></h1>
<h2><a class="header" href="#学习内容-4" id="学习内容-4">学习内容</a></h2>
<ul>
<li>了解共享篋目录src下的测试代码结构</li>
<li>了解私有代码的单元测试方法</li>
<li>了解目录src下的集成测试方法</li>
</ul>
<h2><a class="header" href="#篇目-5" id="篇目-5">篇目</a></h2>
<ol>
<li><a href="hello-world/src-tests.html#%E7%9B%AE%E5%BD%95src%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">目录src测试代码结构</a></li>
<li><a href="hello-world/src-tests.html#%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6modrs">默认模块文件mod.rs</a></li>
<li><a href="hello-world/src-tests.html#%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">私有代码的单元测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95src%E5%86%85%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">基于目录src内的集成测试</a></li>
<li><a href="hello-world/src-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#目录src测试代码结构" id="目录src测试代码结构">目录src测试代码结构</a></h2>
<pre><code class="language-bash">$ tree ./src -L 3
./src
├── integration_tests
│   ├── i_hello.rs
│   └── mod.rs
├── lib.rs
└── private_tests
    ├── mod.rs
    └── owned_hello.rs
</code></pre>
<h2><a class="header" href="#默认模块文件modrs" id="默认模块文件modrs">默认模块文件mod.rs</a></h2>
<p>　　Ⓓ 从目录src开始，Cargo项目共享篋程序目录名称就是模块名称。目录src就是共享篋模块名称，其模块文件就是lib.rs。</p>
<p>　　如：这里共享篋名称hello_exercism就是模块名称</p>
<p>　　Ⓓ 所有目录src的子目录也是模块名称，其模块文件就是mod.rs。</p>
<p>　　如，目录private_tests就是模块hello_exercism的子模块。</p>
<p>　　Ⓓ 除了lib.rs和mod.rs文件以外，所有其它文件名称也就是模块名称，且其文件名称就是模块名称。</p>
<p>　　如，文件i_hello.rs就是一个模块，其模块名称为i_hello。</p>
<h2><a class="header" href="#私有代码的单元测试" id="私有代码的单元测试">私有代码的单元测试</a></h2>
<p>　　↳ 所有私有函数的单元测试代码必须在其相关的程序文件内。</p>
<p>　　Cargo项目私有代码的单元测试思路：单元测试与共享篋程序代码是融为一体的。所以测试代码都是在私有代码相关的可访问模块里，是不可分开的。</p>
<h2><a class="header" href="#程序文件srclibrs与私有代码的单元测试" id="程序文件srclibrs与私有代码的单元测试">程序文件src/lib.rs与私有代码的单元测试</a></h2>
<p>　　为了测试共享篋程序文件src/lib.rs的私有函数hallo()，需要将测试代码存放在该文件的可访问模块里，或者分离到另外若干个文件里。</p>
<p>　　这里说明程序文件src/lib.rs的第二部分私有代码的单元测试代码，有四段单元测试代码，它们是为三个不同模块：hello_exercism::private_tests::owned_hello、hello_exercism::private_tests_with_use和hello_exercism::private_tests_without_use，而每一个模块都有一个单元测试函数，其测试目的和代码含义都是完全一样的，只是代码形式不一样。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: src/lib.rs
pub fn hello() -&gt; &amp;'static str {
    println!(&quot;{}&quot;, hallo());
    &quot;Hello, World!&quot;
}

fn hallo() -&gt; &amp;'static str {
    &quot;Hallo, Welt!&quot;
}

// BEGIN: unit tests for private code
// code 1
<span class="boring">[cfg(test)]
[path = &quot;./private_tests/owned_hello.rs&quot;]
</span>mod owned_hello;

// code 2
<span class="boring">[cfg(test)]
[path = &quot;./private_tests/mod.rs&quot;]
</span>mod private_tests;

// code 3
<span class="boring">[cfg(test)]
</span>mod private_tests_with_use {
    use super::*;
    //use super::hallo;

<span class="boring">    [test]
</span>    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
    }
}

// code 4
<span class="boring">[cfg(test)]
</span>mod private_tests_without_use {
<span class="boring">    [test]
</span>    fn it_works_at_private() {
        assert_eq!(&quot;Hallo, Welt!&quot;, super::hallo());
    }
}
// END unit tests for private code 

// BEGIN: integration tests
<span class="boring">[cfg(test)]
[path = &quot;./integration_tests/i_hello.rs&quot;]
</span>mod i_hello;

<span class="boring">[cfg(test)]
[path = &quot;./integration_tests/mod.rs&quot;]
</span>mod integration_tests;
// END: integration tests
</code></pre></pre>
<h2><a class="header" href="#多文件结构的私有代码的单元测试" id="多文件结构的私有代码的单元测试">多文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的单元测试文件或者说模块。分离文件'src/private_tests/owned_hello.rs'如下所示里。它们的第二行说明其下一行模块的位置。</p>
<p>　　Ⓓ 因为第二段代码的访问模块方式是默认方式，所以第二行代码可以省略。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/owned_hello.rs
use super::*;
//use super::hallo;

<span class="boring">[test]
</span>fn it_works_at_private() {
    assert_eq!(&quot;Hallo, Welt!&quot;, hallo());
}
</code></pre></pre>
<p>　　在程序文件mod.rs和owned_hello.rs里，第一行代码都是需要访问其父模块的所有函数。因为从模块owned_hello出发，需要访问其上两层模块，所以两个模块里都需要使用super语句。</p>
<pre><pre class="playpen"><code class="language-rust editable">// src/private_tests/mod.rs
use super::*;
mod owned_hello;
</code></pre></pre>
<h2><a class="header" href="#单一文件结构的私有代码的单元测试" id="单一文件结构的私有代码的单元测试">单一文件结构的私有代码的单元测试</a></h2>
<p>　　在程序文件lib.rs的第二部分代码里，第三段代码和第四段代码方法是把测试代码存放在可访问私有代码的模块里。它们仅仅是否使用了关键词use不同而已。</p>
<p>　　第三段代码的第三行说明该模块hello_exercism::private_tests_with_use需要访问其父模块hello_exercism的所有函数。</p>
<p>　　第四段代码里super也是说明了需要使用期父模块的函数hallo()。</p>
<h2><a class="header" href="#基于目录src内的集成测试" id="基于目录src内的集成测试">基于目录src内的集成测试</a></h2>
<p>　　基于共享篋目录src内的集成测试，与私有代码的单元测试思路有类似性，其测试代码也都是在模块程序代码里，但是有本质上区别，它仅仅使用了共享篋模块结构属性，而非共享篋的原代码，因此它是只能访问共享篋的公共接口。</p>
<p>　　这里说明程序文件src/lib.rs的第三部分集成测试代码，存在两段测试代码。第一段代码和第二段代码方法都是把测试代码分离到另外文件里，这里它们指向相同的集成测试文件或者说模块。代码原理与前面私有代码的单元测试是完全一样的。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/mod.rs
mod i_hello;
</code></pre></pre>
<p>　　不同代码的是，程序文件mod.rs和集成测试文件i_hello.rs。程序文件mod.rs没有super相关语句，只是说明了使用i_hello模块。集成测试文件i_hello.rs也是不一样的，也没有super相关语句，而是引用了一行使用自己模块的语句，且把自己也称之为模块hello_exercism，这个模块名称可以随意自己命名。</p>
<pre><pre class="playpen"><code class="language-rust editable">// Rust File: ./integration_tests/i_hello.rs
use crate as hello_exercism;

<span class="boring">[test]
</span>fn it_works_with_only_extern() {
    assert_eq!(&quot;Hello, World!&quot;, i_crate::hello());
}

<span class="boring">[test]
</span>fn it_works_with_the_crate_and_extern() {
    assert_eq!(hello_exercism::hello(), i_crate::hello());
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit_testing</a></li>
<li><a href="https://www.guru99.com/unit-test-vs-integration-test.html">unit-test-vs-integration-test</a></li>
<li><a href="http://xion.io/post/code/rust-unit-test-placement.html">rust-unit-test-placement</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://www.nibor.org/blog/integration-testing-a-service-written-in-rust-and-iron/">integration-testing-a-service-written-in-rust-and-iron</a></li>
<li><a href="https://dev.to/werner/practical-rust-web-development-testing-4eo5">practical-rust-web-development-testing</a></li>
<li><a href="https://rust-random.github.io/book/contrib-test.html">book/contrib-test</a></li>
<li><a href="http://andrewradev.com/2019/03/01/testing-in-rust-temporary-files/">testing-in-rust-temporary-files</a></li>
<li><a href="https://jonathanmh.com/unit-tests-with-rust-tutorial-101/">unit-tests-with-rust-tutorial-101</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/use-declarations.html">use-declarations</a></li>
</ul>
<h1><a class="header" href="#本地程序开发命令" id="本地程序开发命令">本地程序：开发命令</a></h1>
<h2><a class="header" href="#学习内容-5" id="学习内容-5">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用本地程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-6" id="篇目-6">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-local.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
</ol>
<h2><a class="header" href="#创建项目命令" id="创建项目命令">创建项目命令</a></h2>
<pre><code class="language-bash"># 先进入作业区根目录，且创建项目目录，然后进入本地程序项目根目录
mkdir bin-local-hello &amp;&amp; cd bin-local-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-local-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件" id="修改项目配置文件">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
echo 'hello_exercism = { path = &quot;../lib-hello&quot;}' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码" id="开发主程序文件代码">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
vi src/main.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件" id="运行主程序文件">运行主程序文件</a></h2>
<pre><code class="language-bash"># 进入本地程序项目根目录
cargo run
</code></pre>
<h1><a class="header" href="#子项目本地程序项目bin-local-hello" id="子项目本地程序项目bin-local-hello">子项目：本地程序项目bin-local-hello</a></h1>
<p>　　在共享篋hello_exercism发布以前，Cargo项目本地程序可以以独立的Cargo项目使用该共享篋，且开发应用和检查代码。</p>
<h2><a class="header" href="#学习内容-6" id="学习内容-6">学习内容</a></h2>
<ul>
<li>阐述项目本地程序开发方法</li>
<li>理解项目本地程序代码</li>
</ul>
<h2><a class="header" href="#篇目-7" id="篇目-7">篇目</a></h2>
<ol>
<li><a href="hello-world/bin-local.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">修改项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin-local.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">开发主程序文件main.rs</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行主程序及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C">运行测试代码及其结果</a></li>
<li><a href="hello-world/bin-local.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#修改项目配置文件cargotoml" id="修改项目配置文件cargotoml">修改项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了共享篋源代码所处的位置。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-local-hello&quot;
version = &quot;0.1.0&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
hello_exercism = { path = &quot;../lib-hello&quot;}
</code></pre>
<h2><a class="header" href="#开发主程序文件mainrs" id="开发主程序文件mainrs">开发主程序文件main.rs</a></h2>
<p>　　主程序文件main.rs与前面代码非常类似，但是这个程序的执行命令与以前是不一样的，并且代码文件结构形式也是不一样的，程序代码和测试代码存在于一个文件里。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

<span class="boring">[test]
</span>fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
</code></pre></pre>
<h2><a class="header" href="#运行主程序及其结果" id="运行主程序及其结果">运行主程序及其结果</a></h2>
<pre><code class="language-bash"># 运行主程序及其结果
$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#运行测试代码及其结果" id="运行测试代码及其结果">运行测试代码及其结果</a></h2>
<pre><code class="language-bash"># 运行测试代码及其结果
$ cargo test -q

running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/33025887/how-to-use-a-local-unpublished-crate">how-to-use-a-local-unpublished-crate</a></li>
</ul>
<h1><a class="header" href="#仓库程序开发命令" id="仓库程序开发命令">仓库程序：开发命令</a></h1>
<p>　　只有发布了自己共享软件篋以后，才能开发这个项目。</p>
<h2><a class="header" href="#学习内容-7" id="学习内容-7">学习内容</a></h2>
<ul>
<li>熟悉和使用Cargo工具命令</li>
<li>熟悉和使用仓库程序项目开发命令</li>
</ul>
<h2><a class="header" href="#篇目-8" id="篇目-8">篇目</a></h2>
<ol>
<li><a href="hello-world/commands-bin.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4">创建项目命令</a></li>
<li><a href="hello-world/commands-bin.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改项目配置文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%BC%80%E5%8F%91%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81">开发主程序文件代码</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">运行主程序文件</a></li>
<li><a href="hello-world/commands-bin.html#%E5%AE%89%E8%A3%85%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F">安装仓库程序于本地系统</a></li>
<li><a href="hello-world/commands-bin.html#%E8%BF%90%E8%A1%8C%E5%AE%89%E8%A3%85%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">运行安装于本地系统的仓库程序</a></li>
<li><a href="hello-world/commands-bin.html#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%93%E5%BA%93%E7%A8%8B%E5%BA%8F">删除本地系统的仓库程序</a></li>
</ol>
<h2><a class="header" href="#创建项目命令-1" id="创建项目命令-1">创建项目命令</a></h2>
<pre><code class="language-bash"># 创建项目命令
# 先进入作业区根目录，且创建项目目录，然后进入仓库程序项目根目录
mkdir bin-hello &amp;&amp; cd bin-hello
# 创建名称为bin-hello的可执行软件篋
cargo init --name bin-hello --bin
</code></pre>
<h2><a class="header" href="#修改项目配置文件-1" id="修改项目配置文件-1">修改项目配置文件</a></h2>
<pre><code class="language-bash"># 修改项目配置文件
# 进入仓库程序项目根目录
echo 'hello_exercism = &quot;0.4.1&quot;' &gt;&gt; Cargo.toml
</code></pre>
<h2><a class="header" href="#开发主程序文件代码-1" id="开发主程序文件代码-1">开发主程序文件代码</a></h2>
<pre><code class="language-bash"># 开发主程序文件代码
# 进入仓库程序项目根目录
rm src/main.rs
mkdir -p src/bin
touch src/bin/hello.rs
vi src/bin/hello.rs
touch src/bin/hallo.rs
vi src/bin/hallo.rs
</code></pre>
<h2><a class="header" href="#运行主程序文件-1" id="运行主程序文件-1">运行主程序文件</a></h2>
<pre><code class="language-bash"># 运行主程序文件
# 进入仓库程序项目根目录
cargo run --bin hello
cargo run --bin hallo
</code></pre>
<h2><a class="header" href="#安装仓库程序于本地系统" id="安装仓库程序于本地系统">安装仓库程序于本地系统</a></h2>
<pre><code class="language-bash"># 安装仓库程序于本地系统
# 进入仓库程序项目根目录
# 所有Cargo软件篋都安装于目录~/.cargo/bin/
ls ~/.cargo/bin/
cargo install --path .
ls ~/.cargo/bin/
</code></pre>
<h2><a class="header" href="#运行安装于本地系统的仓库程序" id="运行安装于本地系统的仓库程序">运行安装于本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 运行安装于本地系统的仓库程序
# 可以在本地系统任何目录下运行下面命令
hello
hallo
</code></pre>
<h2><a class="header" href="#删除本地系统的仓库程序" id="删除本地系统的仓库程序">删除本地系统的仓库程序</a></h2>
<pre><code class="language-bash"># 删除本地系统的仓库程序
# 进入仓库程序项目根目录
ls ~/.cargo/bin/
# cargo uninstall &lt;来自于Cargo.toml里的仓库程序名称&gt;
cargo uninstall bin-hello
ls ~/.cargo/bin/
</code></pre>
<h1><a class="header" href="#子项目仓库程序项目bin-hello" id="子项目仓库程序项目bin-hello">子项目：仓库程序项目bin-hello</a></h1>
<p>　　在共享篋hello_exercism发布以后，Cargo项目仓库程序可以以独立的Cargo项目使用共享篋，且开发应用和检查代码。一般情况下。用户使用共享篋是以这种项目形式出现的。</p>
<p>　　这个仓库程序项目介绍了一种方法，在一个可执行的软件篋里，存在多个独立的可执行程序。</p>
<h2><a class="header" href="#学习内容-8" id="学习内容-8">学习内容</a></h2>
<ul>
<li>阐述项目仓库程序开发方法</li>
<li>理解项目仓库程序代码</li>
</ul>
<h2><a class="header" href="#篇目-9" id="篇目-9">篇目</a></h2>
<ol>
<li><a href="hello-world/bin.html#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Cargotoml">项目配置文件Cargo.toml</a></li>
<li><a href="hello-world/bin.html#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6mainrs">主程序文件main.rs</a></li>
<li><a href="hello-world/bin.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6i_hellors">集成测试文件i_hello.rs</a></li>
</ol>
<h2><a class="header" href="#项目配置文件cargotoml-1" id="项目配置文件cargotoml-1">项目配置文件Cargo.toml</a></h2>
<p>　　下面文件Cargo.toml里，与项目关系最大的一行代码是最后一行代码。这行代码说明了所使用的共享篋，包括共享篋名称和版本号。</p>
<pre><code class="language-toml">[package]
name = &quot;bin-hello&quot;
version = &quot;0.5.3&quot;
authors = [&quot;cnruby &lt;gudao.luo@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# https://crates.io/crates/hello_exercism
# change the follow version to current version
hello_exercism = &quot;0.5.3&quot;
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhellors" id="主程序文件srcbinhellors">主程序文件src/bin/hello.rs</a></h2>
<p>　　下面主程序文件main.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    println!(&quot;{}&quot;,hello_exercism::hello());
}

</code></pre></pre>
<p>　　执行上面程序的命令及其结果，如下所示：</p>
<pre><code class="language-bash">$ cargo run -q
Hallo, Welt!
Hello, World!
</code></pre>
<h2><a class="header" href="#主程序文件srcbinhallors" id="主程序文件srcbinhallors">主程序文件src/bin/hallo.rs</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main () {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}

</code></pre></pre>
<h2><a class="header" href="#集成测试文件i_hellors" id="集成测试文件i_hellors">集成测试文件i_hello.rs</a></h2>
<p>　　下面的集成测试文件i_hello.rs与前面项目bin-local-hello完全是一样的。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
[test]
</span>fn test_hello_world() {
    assert_eq!(&quot;Hello, World!&quot;, hello_exercism::hello());
}
<span class="boring">}
</code></pre></pre>
<h1><a class="header" href="#题外话-1" id="题外话-1">题外话</a></h1>
<h2><a class="header" href="#篇目-10" id="篇目-10">篇目</a></h2>
<ol>
<li><a href="hello-world/off-topic.html#cargo%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4">Cargo工具命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%9B%AE%E5%BD%95examples%E4%B8%8B%E6%96%87%E4%BB%B6">构建和运行软件篋目录examples下文件</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4">Cargo项目构建命令</a></li>
<li><a href="hello-world/off-topic.html#Cargo%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4">Cargo项目测试特定代码命令</a></li>
<li><a href="hello-world/off-topic.html#%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98">思考问题</a></li>
<li><a href="hello-world/off-topic.html#%E7%B1%BB%E5%9E%8Bstr%E5%92%8Cstatic-str%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8Duse%E5%92%8Cextern%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">使用关键词use和extern有什么区别？</a></li>
<li><a href="hello-world/off-topic.html#%E6%B3%A8%E8%A7%A3cfgtest%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89">注解#[cfg(test)]有什么意义?</a></li>
<li><a href="hello-world/off-topic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#cargo工具命令" id="cargo工具命令">Cargo工具命令</a></h2>
<h3><a class="header" href="#构建和运行软件篋目录examples下文件" id="构建和运行软件篋目录examples下文件">构建和运行软件篋目录examples下文件</a></h3>
<pre><code class="language-bash"># cargo build --example &lt;目录examples下无扩展名的文件名称&gt;
# cargo run --example &lt;目录examples下无扩展名的文件名称&gt;
cargo build --example i_hello
cargo run --example i_hello
</code></pre>
<h3><a class="header" href="#cargo项目构建命令" id="cargo项目构建命令">Cargo项目构建命令</a></h3>
<pre><code class="language-bash">cargo build
cargo build --release
</code></pre>
<h3><a class="header" href="#cargo项目测试特定代码命令" id="cargo项目测试特定代码命令">Cargo项目测试特定代码命令</a></h3>
<pre><code class="language-bash">cargo test tests::it_works_at_uint
cargo test test_hello_world
</code></pre>
<h2><a class="header" href="#思考问题" id="思考问题">思考问题</a></h2>
<h3><a class="header" href="#类型str和static-str有什么区别" id="类型str和static-str有什么区别">类型<code>＆str</code>和<code>＆'static str</code>有什么区别？</a></h3>
<ul>
<li>在语句里，它们是没有任何区别。</li>
<li>在函数返回类型里，它们是有区别的。</li>
</ul>
<h3><a class="header" href="#使用关键词use和extern有什么区别" id="使用关键词use和extern有什么区别">使用关键词use和extern有什么区别？</a></h3>
<ul>
<li>自Rust2018版本以来几乎不再需要extern语句。</li>
<li>关键词use方法与以前相同。</li>
<li>关键词use仅仅是引用标准符号的简写，或者使用trait时必须出现。</li>
</ul>
<h3><a class="header" href="#注解cfgtest有什么意义" id="注解cfgtest有什么意义">注解#[cfg(test)]有什么意义?</a></h3>
<ul>
<li>它告诉编译器在测试环境下进行编译，</li>
<li>仅当使用命令'cargo test'运行测试时，Cargo工具才会编译测试代码。</li>
</ul>
<h2><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/29403920/whats-the-difference-between-use-and-extern">whats-the-difference-between-use-and-extern</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-alpha.2/book/crates-and-modules.html">crates-and-modules</a></li>
<li><a href="https://freyskeyd.fr/cfg-test-and-cargo-test-a-missing-information/">cfg-test-and-cargo-test-a-missing-information</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">ch11-03-test-organization</a></li>
<li><a href="https://klausi.github.io/rustnish/2017/05/25/writing-integration-tests-in-rust.html">writing-integration-tests-in-rust</a></li>
<li><a href="https://stackoverflow.com/questions/49684657/what-is-the-difference-between-str-and-static-str-in-a-static-or-const">what-is-the-difference-between-str-and-static-str-in-a-static-or-const</a></li>
</ul>
<p><a href="https://crates.io/crates/trait_exerci"><img src="https://img.shields.io/crates/v/trait_exerci?label=trait_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-trait"><img src="https://img.shields.io/badge/hello--trait-code-yellowgreen" alt="The Crate trait_exerci Code" /></a></p>
<h1><a class="header" href="#软件篋trait_exerci" id="软件篋trait_exerci">软件篋trait_exerci</a></h1>
<h3><a class="header" href="#本章学习内容" id="本章学习内容">本章学习内容</a></h3>
<ul>
<li>什么是Rust语言衔接关键词trait</li>
<li>为什么需要衔接关键词trait</li>
<li>怎么样实现Rust语言衔接关键词trait</li>
<li>实现关键词impl与衔接关键词trait是什么关系</li>
</ul>
<h3><a class="header" href="#本节篇目" id="本节篇目">本节篇目</a></h3>
<ul>
<li><a href="hello-trait/index.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a>
<ul>
<li><a href="hello-trait/index.html#%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8rust%E8%AF%AD%E8%A8%80nightly%E7%89%88%E6%9C%AC">怎么样使用Rust语言nightly版本</a></li>
<li><a href="hello-trait/index.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
<li><a href="hello-trait/index.html#%E6%9C%AC%E7%AB%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">本章参考资料</a></li>
</ul>
<h2><a class="header" href="#题外话-2" id="题外话-2">题外话</a></h2>
<h3><a class="header" href="#怎么样使用rust语言nightly版本" id="怎么样使用rust语言nightly版本">怎么样使用Rust语言nightly版本</a></h3>
<pre><code class="language-bash">rustc --version
rustup default nightly
rustc --version
rustup default stable
rustup update
rustup show
</code></pre>
<h3><a class="header" href="#参考资料-6" id="参考资料-6">参考资料</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rustup.rs/issues/451">Setting &quot;rustup default nightly&quot; and back to stable ends up</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/55571">Toolchain 'nightly-x86_64-apple-darwin' missing</a></li>
</ul>
<h2><a class="header" href="#本章参考资料" id="本章参考资料">本章参考资料</a></h2>
<ul>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">Impls &amp; Traits</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">Traits from 'rust-by-example'</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/traits.html">Traits from 'The Rust Programming Language'</a></li>
<li><a href="https://doc.rust-lang.org/beta/book/ch10-02-traits.html">Traits: Defining Shared Behavior</a></li>
</ul>
<h1><a class="header" href="#类型关键词struct" id="类型关键词struct">类型关键词<code>struct</code></a></h1>
<p>　　通过了解和学习本节Rust语言的基本概念，可以实现本章需要开发的共享软件篋程序代码。</p>
<h2><a class="header" href="#学习内容-9" id="学习内容-9">学习内容</a></h2>
<ul>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>定义形式</li>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>实例化方式</li>
<li>理解和掌握Rust语言结构性的类型关键词<code>struct</code>调用手段</li>
</ul>
<h2><a class="header" href="#篇目-11" id="篇目-11">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-struct.html#%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E6%98%AF%E4%BB%80%E4%B9%88">类型关键词<code>struct</code>是什么</a></li>
<li><a href="hello-trait/examples-struct.html#C%E8%AF%AD%E8%A8%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct%E4%BB%A3%E7%A0%81">C语言形式的类型关键词<code>struct</code>代码</a></li>
<li><a href="hello-trait/examples-struct.html#%E5%85%83%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dstruct">元组形式的类型关键词<code>struct</code></a></li>
<li><a href="hello-trait/examples-struct.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#类型关键词struct是什么" id="类型关键词struct是什么">类型关键词<code>struct</code>是什么</a></h2>
<p>　　类型关键词struct提供定义一种结构性的类型方式。这种类型的定义分析如下：</p>
<table><thead><tr><th>名称</th><th>事物描述</th><th>Rust语言描述</th></tr></thead><tbody>
<tr><td>结构性事物</td><td>类别</td><td>struct</td></tr>
<tr><td>事物名称</td><td>人</td><td>Person</td></tr>
<tr><td>事物属性</td><td>姓名，年龄</td><td>name: string, age:u32</td></tr>
</tbody></table>
<p><img src="hello-trait/../../images/hello-trait-11-struct.png" alt="image" /></p>
<p>　　从上图所示，可以理解到，结构类型关键词struct将一组不同的数据类型作为整体在一起分析和处理。</p>
<p>　　同时还可以看到，在Rust语言里，结构类型关键词struct可以将这种结构性事物以两种不同的表达形式进行定义。它们分别称之为：C语言形式和元组形式。图上左边的C语言形式是以哈希结构表达的类型，而图上右边的元组形式是以数组结构表达的类型。</p>
<h2><a class="header" href="#类型关键词struct的私有性" id="类型关键词struct的私有性">类型关键词<code>struct</code>的私有性</a></h2>
<p>　　Rust语言规定，Ⓓ 默认情况下，关键词struct定义的类型及其属性都是私有的，默认实例代码如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>struct Person {
    name: String,
    age: u32,
}
<span class="boring">}
</code></pre></pre>
<h2><a class="header" href="#c语言形式的类型关键词struct代码" id="c语言形式的类型关键词struct代码">C语言形式的类型关键词<code>struct</code>代码</a></h2>
<p>　　这里通过下面的代码，说明如下内容：</p>
<ul>
<li>使用关键词mod，关键词<code>struct</code>定义结构类型的方式。</li>
<li>使用关键词pub，实现关键词<code>struct</code>定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。</li>
<li>结构类型的实例调用结构类型的属性手法。</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct ClikeStructType {
        // data: u32,
        pub data: u32,
    }
}

// cargo run --example pub_field
fn main() {
    let instance = trait_exerci::ClikeStructType { data: 0 };
    let data = instance.data;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#元组形式的类型关键词struct" id="元组形式的类型关键词struct">元组形式的类型关键词<code>struct</code></a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>mod</code>，关键词struct定义结构类型的方式。<br/>ⓡ 注意：元组形式的类型关键词<code>struct</code>定义的类型是以分号结束的，而C语言形式的类型关键词<code>struct</code>代码是没有分号的。</li>
<li>使用关键词<code>pub</code>，实现关键词<code>struct</code>定义的类型及其属性公开性。</li>
<li>使用结构类型属性的公开性，实现结构类型的实例化方式。两种形式的类型不同的。</li>
<li>结构类型的实例调用结构类型的属性手法。元组形式的类型是以其属性的顺序号实现调用的，而C语言形式的类型是以其公开性属性实现调用的。</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct TupleStructType (pub u32);
}

// cargo run --example tuple_struct
fn main() {
    let instance = trait_exerci::TupleStructType(0);
    let data = instance.0;
    assert_eq!(0, data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-7" id="参考资料-7">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/structs.html">structs from 'rust-by-example '</a></li>
</ul>
<h1><a class="header" href="#关键词impl与方法代码实现" id="关键词impl与方法代码实现">关键词<code>impl</code>与方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-10" id="学习内容-10">学习内容</a></h2>
<ul>
<li>阐述关键词<code>impl</code>基本概念</li>
<li>理解关键词<code>impl</code>实现代码的方式</li>
</ul>
<h2><a class="header" href="#篇目-12" id="篇目-12">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-impl.html#%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E6%A6%82%E5%BF%B5">关键词<code>impl</code>概念</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl">实现功能关键词<code>impl</code></a></li>
<li><a href="hello-trait/examples-impl.html#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">实现功能关键词<code>impl</code>与函数代码实现</a></li>
<li><a href="hello-trait/examples-impl.html#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%85%B3%E9%94%AE%E8%AF%8Dimpl">程序结构图与功能关键词impl</a></li>
<li><a href="hello-trait/examples-impl.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#关键词impl概念" id="关键词impl概念">关键词impl概念</a></h2>
<p>　　关键词<code>impl</code>是为类型实现结构类型或者其它一些类型的不同行为功能。这里仅仅说明了直接针对结构类型本身的不同行为实现方式。</p>
<p><img src="hello-trait/../../images/hello-trait-12-impl.png" alt="image" /></p>
<h2><a class="header" href="#实现功能关键词impl" id="实现功能关键词impl">实现功能关键词impl</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>Ⓓ 关键词<code>impl</code>始终是公开的，且不可增加修饰关键词<code>pub</code>；</li>
<li>Ⓓ 关键词<code>impl</code>实现的函数和方法默认都是私有的，且可增加修饰关键词<code>pub</code>。</li>
</ul>
<p>　　默认实例代码如下所示。尽管下面代码已实现了函数<code>new()</code>，但是该函数外部还是不可访问的。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
struct Person {
   name: String,
   age: u32,
}
</span>
impl Person {
    fn new(name: String, age: u32) -&gt; Person {
        Person {
            name: name,
            age: age,
        }
    }
}
<span class="boring">}
</code></pre></pre>
<h2><a class="header" href="#实现功能关键词impl与函数代码实现" id="实现功能关键词impl与函数代码实现">实现功能关键词impl与函数代码实现</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>impl</code>，实现结构类型<code>StructType</code>的实例化函数<code>new()</code>；</li>
<li>使用关键词<code>pub</code>，实现结构类型<code>StructType</code>的函数<code>new()</code>公开性；</li>
<li>实例是一种类型的具体对象；</li>
<li>借助于公开性函数<code>new()</code>，实现该结构类型的实例化方式；</li>
<li>借助于结构类型属性的公开性，实现了实例调用结构类型的属性手法；</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

// cargo run --example function_instance
fn main() {
    let instance = trait_exerci::StructType::new(0);
    println!(&quot;instance.data = {}&quot;, instance.data);

    let instance = trait_exerci::StructType{ data:0, };
    println!(&quot;instance.data = {}&quot;, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#程序结构图与功能关键词impl" id="程序结构图与功能关键词impl">程序结构图与功能关键词impl</a></h2>
<p><img src="hello-trait/../../images/hello-trait-02-only-impl.png" alt="image" /></p>
<h2><a class="header" href="#参考资料-8" id="参考资料-8">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.impl.html">std keyword impl</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html">reference implementations</a></li>
</ul>
<h1><a class="header" href="#函数与方法代码实现" id="函数与方法代码实现">函数与方法代码实现</a></h1>
<h2><a class="header" href="#学习内容-11" id="学习内容-11">学习内容</a></h2>
<ul>
<li>阐述Rust语言函数与方法概念区别</li>
<li>理解实现函数与方法手段</li>
</ul>
<h2><a class="header" href="#篇目-13" id="篇目-13">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-methods.html#%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%85%B3%E9%94%AE%E8%AF%8Dmut%E6%A6%82%E5%BF%B5">修饰实例关键词<code>mut</code>概念</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E6%A6%82%E5%BF%B5">函数与方法概念</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81">实现方法代码</a></li>
<li><a href="hello-trait/examples-methods.html#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A7%81%E6%9C%89%E6%80%A7">结构类型属性的私有性</a></li>
<li><a href="hello-trait/examples-methods.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%9C%A8%E7%BB%88%E7%AB%AF%E9%87%8C%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F">在终端里怎么样使用表格形式</a></li>
<li><a href="hello-trait/examples-methods.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#修饰实例关键词mut概念" id="修饰实例关键词mut概念">修饰实例关键词<code>mut</code>概念</a></h2>
<p>　　关键词<code>let</code>用来定义实例变量，其值是不可改变的，而在一组关键词<code>let mut</code>也用来定义实例变量，但其值是可改变的。</p>
<p>　　下面具体实际代码，这样执行的话，一切正常，但是去掉注释行，就会出现编译错误。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let instance = 1;
    // instance = 2;
    let mut instance = 1;
    instance = 2;
}
</code></pre></pre>
<h2><a class="header" href="#函数与方法概念" id="函数与方法概念">函数与方法概念</a></h2>
<p>　　在Rust语言里，给予了函数（function）或者更明确地说关联函数（associated function）与方法（method）两个名称不同的概念。</p>
<p>　　<a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">引用</a>：Methods are functions attached to objects，直接翻译：方法是附加到对象的函数（行为功能），可以这么理解，方法是附属于类实例的行为功能。</p>
<p>　　而关联函数是附属于类的功能。在前面一节里，可以看到，实现类的关联函数代码方法及其调用手法。下面通过代码详细说明它们的区别。</p>
<h2><a class="header" href="#实现方法代码" id="实现方法代码">实现方法代码</a></h2>
<p>　　通过下面代码，实现了如下内容：</p>
<ul>
<li>实现结构类型<code>StructType</code>的实例化函数<code>new()</code>；</li>
<li>实现结构类型<code>StructType</code>获取其属性的方法<code>get_data()</code>；</li>
<li>实现结构类型<code>StructType</code>变更其属性的方法<code>set_data()</code>；</li>
<li>实现结构类型<code>StructType</code>的属性<code>data</code>是私有的；</li>
<li>借助于公开性方法<code>get_data()</code>，实现结构类型的属性内容获取手法；</li>
<li>借助于公开性方法<code>set_data()</code>，实现结构类型的属性内容变更手法；</li>
</ul>
<p>　　在Rust语言里，ⓡ 方法的第一个参数使用其本身的引用如<code>&amp;self</code>或者<code>&amp;mut self</code>，且在调用该函数时不需要传递该参数。凡是第一个参数不是引用的就是函数。</p>
<p>　　调用函数如<code>new()</code>是使用类型名称如<code>StructType</code>实现的，其调用函数new()的手法是使用<code>::</code>的形式，而调用函数方法如<code>get_data()</code>是使用类型的实例变量如<code>instance</code>实现的，其调用方法的手法是使用<code>.</code>的形式。</p>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
    pub struct StructType {
        data: u32,
    }

    impl StructType {
        pub fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }

        pub fn get_data(&amp;self) -&gt; u32 {
            self.data
        }

        pub fn set_data(&amp;mut self, data: &amp;u32) {
            self.data = *data;
        }
    }
}

// cargo run --example function_methods
fn main() {
    let instance = trait_exerci::StructType::new(0);
    let data = instance.get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;instance data&quot;, data);

    let mut instance = trait_exerci::StructType::new(0);
    instance.set_data(&amp;10);
    let data = instance.get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;mut instance data&quot;, data);

    let data = trait_exerci::StructType::new(20).get_data();
    println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
}
</code></pre></pre>
<h2><a class="header" href="#结构类型属性的私有性" id="结构类型属性的私有性">结构类型属性的私有性</a></h2>
<p>　　结构类型<code>StructType</code>的属性是私有的，所以模块之外是不可访问的，如使用语句<code>instance.data;</code>是不可以的。但是使用方法<code>get_data()</code>可以实现了对该属性的访问。</p>
<p>　　结构类型属性私有性的好处是隐蔽了结构类型的属性。</p>
<h2><a class="header" href="#题外话-3" id="题外话-3">题外话</a></h2>
<h3><a class="header" href="#在终端里怎么样使用表格形式" id="在终端里怎么样使用表格形式">在终端里怎么样使用表格形式</a></h3>
<p>　　下面打印宏<code>println!</code>语句，实现了第一列和第二列占位20个字符的输出。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>let data = 10;
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
println!(&quot;{0: &lt;20} = {1: &lt;20}&quot;, &quot;data&quot;, data);
<span class="boring">}
</code></pre></pre>
<h2><a class="header" href="#参考资料-9" id="参考资料-9">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">rust-by-example methods</a></li>
<li><a href="https://stackoverflow.com/questions/30379341/how-to-print-well-formatted-tables-to-the-console">how-to-print-well-formatted-tables-to-the-console</a></li>
</ul>
<h1><a class="header" href="#衔接关键词trait" id="衔接关键词trait">衔接关键词<code>trait</code></a></h1>
<h2><a class="header" href="#学习内容-12" id="学习内容-12">学习内容</a></h2>
<ul>
<li>阐述衔接类型关键词<code>trait</code>基本概念</li>
</ul>
<h2><a class="header" href="#篇目-14" id="篇目-14">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-trait.html#%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5%E8%A1%A8%E8%BF%B0">关键词trait概念表述</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%85%B3%E9%94%AE%E8%AF%8Dimpl%E5%92%8Cfor%E6%A6%82%E5%BF%B5">关键词<code>impl</code>和<code>for</code>概念</a></li>
<li><a href="hello-trait/examples-trait.html#%E8%A1%94%E6%8E%A5%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E6%A6%82%E5%BF%B5">衔接类型关键词<code>trait</code>概念</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">实现类型关键词<code>trait</code></a></li>
<li><a href="hello-trait/examples-trait.html#%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E4%BB%A3%E7%A0%81">实现关键词<code>trait</code>代码</a></li>
<li><a href="hello-trait/examples-trait.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-trait.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-trait/../../images/hello-trait-21-oop.png" alt="image" /></p>
<h2><a class="header" href="#关键词trait概念表述" id="关键词trait概念表述">关键词trait概念表述</a></h2>
<p>　　关键词trait概念表述之一：</p>
<p>　　<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">关键词trait</a>是Rust语言的一项功能，可以告诉Rust编译器一种类型必须提供的功能。</p>
<p>　　关键词trait概念表述之二：</p>
<p>　　<a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">关键词trait</a>是为任何未知类型定义方法的集合。</p>
<p>　　关键词trait概念表述之三：</p>
<p>　　<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">关键词trait</a>告诉Rust编译器一种特定的类型具有且可与其他类型共享的功效性质。</p>
<p>　　关键词trait提供了一种类型或者几种类型之间的衔接方式。它应该包含下面内容：</p>
<ul>
<li>存在一种类型或者几种类型</li>
<li>使用关键词trait定义衔接特质名称</li>
<li>使用关键词trait代码块定义默认方法和函数</li>
<li>使用关键词&quot;impl&quot;和&quot;for&quot;组合，实现针对这一种类型或者这几种类型的方法和函数</li>
</ul>
<h2><a class="header" href="#衔接类型关键词trait概念" id="衔接类型关键词trait概念">衔接类型关键词trait概念</a></h2>
<p>　　<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">引用</a></p>
<blockquote>
<p>Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
</blockquote>
<p>　　直接翻译：特质(Trait)定义是一种途径，将方法一部分进行分组在一起，为实现某些目的所需以定义行为。</p>
<p>　　衔接类型关键词<code>trait</code>包含这些信息：</p>
<ul>
<li>衔接类型关键词<code>trait</code>提供了类型的一种通道。</li>
<li>衔接类型关键词<code>trait</code>定义了类型行为功能的一部分，且也可实现行为功能。</li>
<li>这一组或者部分类型的行为功能是为了完成一项特有明确的任务。</li>
<li>单个类型可以使用关键词trait定义多组类型行为功能，来实现不同任务。</li>
</ul>
<h2><a class="header" href="#实现类型关键词trait" id="实现类型关键词trait">实现类型关键词trait</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>关键词<code>trait</code>默认是私有的，但可增加修饰关键词<code>pub</code>；</li>
<li>使用关键词<code>trait</code>可以定义一个称之为特质的一组类型行为功能；</li>
<li>一旦定义了衔接类型特质，其函数和方法都是公共的，且且不可增加修饰关键词<code>pub</code>；</li>
</ul>
<p>　　默认实例代码如下所示。尽管下面代码已定义了函数<code>new()</code>或者实现了默认函数<code>init()</code>，但是该函数外部还是不可访问的，因为该特质是私有的。注意，定义了函数<code>new()</code>是语句，是带分号<code>;</code>，而实现了默认函数<code>init()</code>是表达式，是无分号<code>;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
struct Person {
   name: String,
   age: u32,
}
</span>#
trait TraitPerson {
    fn new(name: String, age: u32) -&gt; Person;
    fn init() -&gt; Person { Person { name: String::new(), age: 0, } }
}
<span class="boring">}
</code></pre></pre>
<h2><a class="header" href="#关键词impl和for概念" id="关键词impl和for概念">关键词<code>impl</code>和<code>for</code>概念</a></h2>
<p>　　Rust语言规定：</p>
<ul>
<li>关键词<code>impl</code>和<code>for</code>默认是公开的；</li>
<li>使用关键词<code>impl</code>和<code>for</code>实现的函数或者方法是不可增加修饰关键词<code>pub</code>；</li>
</ul>
<p>　　默认实例代码如下所示。尽管使用关键词<code>impl</code>和<code>for</code>实现了特质<code>TraitPerson</code>，且其默认是公开的，但是为了使用其功能，其相关的类型<code>Person</code>和特质<code>TraitPerson</code>必须要公开的。</p>
<pre><pre class="playpen"><code class="language-rust">#![allow(dead_code)]
<span class="boring">mod trait_exerci {
   pub struct Person {
       name: String,
       age: u32,
   }
</span>#
<span class="boring">   pub trait TraitPerson {
       fn new(name: String, age: u32) -&gt; Person;
       fn init() -&gt; Person {
           Person {
               name: String::new(),
               age: 0,
           }
       }
   }
</span>#
    impl TraitPerson for Person {
        fn new(name: String, age: u32) -&gt; Person {
            Person {
                name: name,
                age: age,
            }
        }
    }
<span class="boring">}
</span>#
<span class="boring">//use self::trait_exerci::TraitPerson;
use crate::trait_exerci::TraitPerson;
</span>#
<span class="boring">fn main() {
   trait_exerci::Person::init();
   trait_exerci::Person::new(String::from(&quot;Leo&quot;), 24);
}
</code></pre></pre>
<h2><a class="header" href="#实现关键词trait代码" id="实现关键词trait代码">实现关键词trait代码</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>trait</code>，定义了特质<code>TraitCanal</code>的函数<code>new()</code>；</li>
<li>使用关键词<code>impl</code>和<code>for</code>，基于结构类型<code>StructType</code>，为特质<code>TraitCanal</code>实现了实例化函数<code>new()</code>；</li>
<li>借助于特质<code>TraitCanal</code>，实现该结构类型的实例化方式；</li>
<li>借助于结构类型属性的公开性，实现了实例调用结构类型的属性手法；</li>
<li>使用宏方法<code>assert_eq!</code>，验证实例调用结果的正确性；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(dead_code)]
</span>
mod trait_exerci {
    pub struct StructType {
        pub data: u32,
    }

    pub trait TraitCanal {
        fn new(data: u32) -&gt; StructType;
    }

    impl TraitCanal for StructType {
        fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }
    }
}

use self::trait_exerci::TraitCanal;

// cargo run --example trait
fn main() {
    let instance = trait_exerci::StructType::new(0);
    assert_eq!(0, instance.data);
}
</code></pre></pre>
<h2><a class="header" href="#题外话-4" id="题外话-4">题外话</a></h2>
<h2><a class="header" href="#参考资料-10" id="参考资料-10">参考资料</a></h2>
<h1><a class="header" href="#特质实现及其对象" id="特质实现及其对象">特质实现及其对象</a></h1>
<h2><a class="header" href="#学习内容-13" id="学习内容-13">学习内容</a></h2>
<ul>
<li>理解衔接类型关键词<code>trait</code>的实现</li>
</ul>
<h2><a class="header" href="#篇目-15" id="篇目-15">篇目</a></h2>
<ul>
<li><a href="hello-trait/examples-trait-impl.html#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E4%B8%8E%E8%A1%94%E6%8E%A5%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E8%AF%8Dtrait">程序结构图与衔接类型关键词<code>trait</code></a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E4%BB%A3%E7%A0%81">实现基于默认方法的关键词<code>trait</code>代码</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E7%89%B9%E8%B4%A8%E5%AF%B9%E8%B1%A1%E8%A7%A3%E9%87%8A">特质对象解释</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A1%8D%E7%94%9F%E7%89%B9%E8%B4%A8">什么是可衍生特质</a></li>
<li><a href="hello-trait/examples-trait-impl.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#程序结构图与衔接类型关键词trait" id="程序结构图与衔接类型关键词trait">程序结构图与衔接类型关键词trait</a></h2>
<p><img src="hello-trait/../../images/hello-trait-03-trait-impl.png" alt="image" /></p>
<h2><a class="header" href="#实现基于默认方法的关键词trait代码" id="实现基于默认方法的关键词trait代码">实现基于默认方法的关键词trait代码</a></h2>
<p>　　通过下面的代码，可以学习到这些知识：</p>
<ul>
<li>使用关键词<code>trait</code>，定义了特质<code>TraitCanal</code>的默认实例化函数<code>init()</code>；</li>
<li>使用关键词<code>impl</code>和<code>for</code>，基于结构类型<code>StructType</code>，为特质<code>TraitCanal</code>实现了方法<code>new()</code>、get_data()<code>和</code>set_data()`；</li>
<li>借助于特质<code>TraitCanal</code>的默认实例化函数<code>init()</code>，实现该结构类型的实例化方式；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">mod trait_exerci {
<span class="boring">    [derive(Debug)]
</span>    pub struct StructType {
        pub data: u32,
    }

    pub trait TraitCanal {
        fn new(data: u32) -&gt; StructType;
        fn init() -&gt; StructType { StructType{data:0} }
        fn get_data(&amp;self) -&gt; u32;
        fn set_data(&amp;mut self, data: &amp;u32);
    }

    impl TraitCanal for StructType {
        fn new(data: u32) -&gt; StructType {
            StructType { data: data }
        }

        fn get_data(&amp;self) -&gt; u32 {
            self.data
        }

        fn set_data(&amp;mut self, data: &amp;u32) {
            self.data = *data;
        }
    }
}

use self::trait_exerci::TraitCanal;

// cargo run --example trait_with_default_method
fn main() {
    let mut instance = trait_exerci::StructType::new(10);
    instance.set_data(&amp;11);
    println!(&quot;new {:?}&quot;, instance);

    let mut instance = trait_exerci::StructType::init();
    instance.set_data(&amp;12);
    println!(&quot;init {:?}&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#特质对象解释" id="特质对象解释">特质对象解释</a></h2>
<p>　　特质本身不能定义特质对象，而是通过类型的对象，进行强制转换得到的特质对象。特质对象可以访问类型的公共数据和公共特质的行为。</p>
<p>　　Rust语言把面向对象编程的思想更加深化了。把类的数据与行为分散化定义，而把类的实例集成化使用。不仅如此，而且Rust语言在代码里完全把这种过程都隐藏起来了。</p>
<p><img src="hello-trait/../../images/hello-trait-31-trait-object.png" alt="image" /></p>
<h2><a class="header" href="#题外话-5" id="题外话-5">题外话</a></h2>
<h3><a class="header" href="#什么是可衍生特质" id="什么是可衍生特质">什么是可衍生特质</a></h3>
<p>　　Rust语言标准库或者第三方提供了一些非常有用的特质，称之为可衍生特质（Derivable Trait）。通过注释<code>#[derive(特质名称)]</code>，编译器能够为这些特质提供实现。比如，要求类型实现是可打印的，可以使用特质std::fmt::Debug。具体说，使用可衍生特质#[derive(Debug)]，所有类型都可以自动创建地实现std::fmt::Debug。</p>
<p>　　下面的代码里第一行就是注释可衍生特质<code>Debug</code>，为类型<code>Person</code>实现了特质<code>Debug</code>，这些后面的宏<code>println!()</code>就可以使用了这个特质。</p>
<p>　　注意，使用注释<code>#[derive(特质名称)]</code>，必须紧挨着类型定义之上。</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">[derive(Debug)]
</span>struct Person {
  name: String,
  age: u32,
}

impl Person {
    fn init() -&gt; Person {
        Person {
            name: String::new(),
            age: 0,
        }
    }
}

fn main() {
    let person = Person::init();
    println!(&quot;{:?}&quot;, person);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-11" id="参考资料-11">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">trait std::fmt::Debug</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">rust-by-example derive</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello/print/print_debug.html">rust-by-example print_debug</a></li>
<li><a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html#appendix-c-derivable-traits">appendix-03-derivable-traits</a></li>
</ul>
<h1><a class="header" href="#题外话标准库默认衔接特质default" id="题外话标准库默认衔接特质default">题外话：标准库默认衔接特质<code>Default</code></a></h1>
<h2><a class="header" href="#学习内容-14" id="学习内容-14">学习内容</a></h2>
<ul>
<li>理解标准库默认衔接特质<code>Default</code></li>
</ul>
<h2><a class="header" href="#篇目-16" id="篇目-16">篇目</a></h2>
<ol>
<li><a href="hello-trait/examples-trait-default.html#%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default%E5%8A%9F%E8%83%BD">默认衔接特质<code>Default</code>功能</a></li>
<li><a href="hello-trait/examples-trait-default.html#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default">使用默认衔接特质<code>Default</code></a></li>
<li><a href="hello-trait/examples-trait-default.html#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E9%BB%98%E8%AE%A4%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8Default">实现自己默认衔接特质<code>Default</code></a></li>
<li><a href="hello-trait/examples-trait-default.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#默认衔接特质default功能" id="默认衔接特质default功能">默认衔接特质<code>Default</code>功能</a></h2>
<p>　　标准库默认衔接特质<code>Default</code>也是一个有用的可衍生特质，为类型提供默认值的特质，也就是为类型提供默认的实例化手法。</p>
<h2><a class="header" href="#使用默认衔接特质default" id="使用默认衔接特质default">使用默认衔接特质<code>Default</code></a></h2>
<p>　　在使用默认衔接特质<code>Default</code>的函数default()定义变量时，必须说明变量类型。</p>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(dead_code)]
</span>
mod trait_exerci {
<span class="boring">    [derive(Default, Debug)]
</span>    pub struct StructType {
        pub data: u32,
    }
}

// cargo run --example trait_default
fn main() {
    let instance: trait_exerci::StructType = Default::default();
    println!(&quot;{0: &lt;20} = {1}&quot;, &quot;instance.data&quot;, instance.data);
    println!(&quot;{0: &lt;20} = {1:?}&quot;, &quot;instance&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#实现自己默认衔接特质default" id="实现自己默认衔接特质default">实现自己默认衔接特质<code>Default</code></a></h2>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">[derive(Debug)]``
</span>pub struct Person {
    name: String,
    age: u32,
}

impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;Leo&quot;),
            age: 24,
        }
    }
}

fn main() {
    let instance: Person = Default::default();
    println!(&quot;{:?}&quot;, instance);
    let mut instance = Person { age: 23, ..Default::default() };
    instance.age = 24;
    println!(&quot;{:?}&quot;, instance);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-12" id="参考资料-12">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html">std::default::Default</a></li>
</ul>
<h1><a class="header" href="#共享篋程序代码结构" id="共享篋程序代码结构">共享篋：程序代码结构</a></h1>
<p>　　这一节总结前面程序代码结构。</p>
<h2><a class="header" href="#篇目-17" id="篇目-17">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-structure.html#%E7%89%B9%E8%B4%A8%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">特质与类型实现方式结构示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E4%BB%85%E4%BB%85%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">仅仅类型实现方式示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E4%BB%85%E4%BB%85%E7%89%B9%E8%B4%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE">仅仅特质实现方式示意图</a></li>
<li><a href="hello-trait/lib-structure.html#%E7%89%B9%E8%B4%A8%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E7%A4%BA%E6%84%8F%E5%9B%BE">特质与类型实现比较示意图</a></li>
</ol>
<h1><a class="header" href="#特质与类型实现方式结构示意图" id="特质与类型实现方式结构示意图">特质与类型实现方式结构示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-01.png" alt="image" /></p>
<h1><a class="header" href="#仅仅类型实现方式示意图" id="仅仅类型实现方式示意图">仅仅类型实现方式示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-02-only-impl.png" alt="image" /></p>
<h1><a class="header" href="#仅仅特质实现方式示意图" id="仅仅特质实现方式示意图">仅仅特质实现方式示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-03-trait-impl.png" alt="image" /></p>
<h1><a class="header" href="#特质与类型实现比较示意图" id="特质与类型实现比较示意图">特质与类型实现比较示意图</a></h1>
<p><img src="hello-trait/../../images/hello-trait-04-all.png" alt="image" /></p>
<h1><a class="header" href="#关于软件篋trait_exerci" id="关于软件篋trait_exerci">关于软件篋<code>trait_exerci</code></a></h1>
<h2><a class="header" href="#学习内容-15" id="学习内容-15">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
</ul>
<h2><a class="header" href="#篇目-18" id="篇目-18">篇目</a></h2>
<ol>
<li><a href="hello-trait/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-trait/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
</ol>
<h2><a class="header" href="#项目名称清单-1" id="项目名称清单-1">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-trait</strong></td><td>./hello-trait</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-trait/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-trait/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-trait/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单-1" id="软件篋类型清单-1">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>trait_exerci</strong></td><td>./hello-trait/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-trait/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-trait/bin-hello</td></tr>
</tbody></table>
<h2><a class="header" href="#共享篋开发命令-1" id="共享篋开发命令-1">共享篋：开发命令</a></h2>
<h2><a class="header" href="#篇目-19" id="篇目-19">篇目</a></h2>
<ul>
<li><a href="hello-trait/commands-lib.html#%e5%88%9b%e5%bb%ba%e5%85%b1%e4%ba%ab%e7%af%8b">创建共享篋</a></li>
<li><a href="hello-trait/commands-lib.html#%e5%88%9b%e5%bb%ba%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">创建应用程序</a></li>
</ul>
<h1><a class="header" href="#创建共享篋" id="创建共享篋">创建共享篋</a></h1>
<pre><code class="language-bash">mkdir lib-hello &amp;&amp; cd lib-hello
cargo init --name trait_exerci --lib
</code></pre>
<h1><a class="header" href="#创建应用程序" id="创建应用程序">创建应用程序</a></h1>
<pre><code class="language-bash">mkdir bin-hello &amp;&amp; cd bin-hello
cargo init --name hello-trait --bin
</code></pre>
<h1><a class="header" href="#共享篋程序代码解释" id="共享篋程序代码解释">共享篋：程序代码解释</a></h1>
<h2><a class="header" href="#学习内容-16" id="学习内容-16">学习内容</a></h2>
<ul>
<li>学习和理解关键词<code>trait</code>开发过程</li>
</ul>
<h2><a class="header" href="#篇目-20" id="篇目-20">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-codes.html#%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E7%AF%8B%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">项目共享篋程序结构示意图</a></li>
<li><a href="hello-trait/lib-codes.html#%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A">程序代码解释</a></li>
<li><a href="hello-trait/lib-codes.html#%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E8%AF%8Dtrait%E5%92%8Cimpl%E5%85%B3%E7%B3%BB">理解关键词<code>trait</code>和<code>impl</code>关系</a></li>
<li><a href="hello-trait/lib-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/lib-codes.html#%E6%A0%87%E5%87%86%E5%BA%93%E5%B9%B3%E7%AD%89%E6%AF%94%E8%BE%83%E7%89%B9%E8%B4%A8PartialEq">标准库平等比较特质<code>PartialEq</code></a></li>
<li><a href="hello-trait/lib-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#项目共享篋程序结构示意图" id="项目共享篋程序结构示意图">项目共享篋程序结构示意图</a></h2>
<p>　　下面示意图是共享篋<code>trait_exerci</code>程序的结构。该共享篋提供了对外三个衔接通道：两个特质<code>TraitCanal</code>和<code>TraitKanal</code>以及一个类型的自我实现<code>StructType</code>。</p>
<p><img src="hello-trait/../../images/hello-trait-05-complex.png" alt="image" /></p>
<h2><a class="header" href="#程序代码解释" id="程序代码解释">程序代码解释</a></h2>
<p>　　通过下面代码，实现了如下内容：</p>
<ul>
<li>结构类型<code>StructType</code>进行了自我实现；</li>
<li>针对结构类型<code>StructType</code>，定义了两个特质<code>TraitCanal</code>和<code>TraitKanal</code>；</li>
<li>对于结构类型<code>StructType</code>，实现了两个特质<code>TraitCanal</code>和<code>TraitKanal</code>；</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">[derive(Debug, PartialEq, Default)]
</span>pub struct StructType {
    data: u32,
}

pub trait TraitCanal {
    fn get_data(&amp;self) -&gt; u32;
}

pub trait TraitKanal {
    fn set_data(&amp;mut self, data: &amp;u32);
}

impl TraitCanal for StructType {
    fn get_data(&amp;self) -&gt; u32 {
        self.data
    }
}

impl TraitKanal for StructType {
    fn set_data(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

// impl AllTrait for StructType {
impl StructType {
    pub fn new(data: u32) -&gt; StructType {
        dbg!(&quot;impl StructType: new&quot;);
        StructType { data: data }
    }

    pub fn get_data_for_all(&amp;self) -&gt; u32 {
        self.data
    }

    pub fn set_data_for_all(&amp;mut self, data: &amp;u32) {
        self.data = *data;
    }
}

</code></pre></pre>
<p>　　结构类型<code>StructType</code>自我实现，包含了一个函数<code>new()</code>和两个方法<code>get_data_for_all()</code>和<code>set_data_for_all()</code>。</p>
<p>　　针对一个结构类型<code>StructType</code>，定义且实现了两个不同的特质<code>TraitCanal</code>和<code>TraitKanal</code>。特质<code>TraitCanal</code>包含一个方法<code>get_data()</code>，而特质<code>TraitKanal</code>包含一个方法<code>set_data()</code>。</p>
<h2><a class="header" href="#理解关键词trait和impl关系" id="理解关键词trait和impl关系">理解关键词<code>trait</code>和<code>impl</code>关系</a></h2>
<p>　　针对一个结构类型<code>StructType</code>实例，可以存在不同的特质，只要把这些特质在一起使用，这些不同特质实现的函数和方法是可以相通的。</p>
<p>　　任何结构类型<code>StructType</code>的特质实现，都可以使用结构类型<code>StructType</code>自我实现的函数和方法。</p>
<h2><a class="header" href="#题外话-6" id="题外话-6">题外话</a></h2>
<h3><a class="header" href="#标准库平等比较特质partialeq" id="标准库平等比较特质partialeq">标准库平等比较特质<code>PartialEq</code></a></h3>
<p>　　标准库平等比较特质<code>PartialEq</code>，可以比较类型的实例以检查它们是否相等。</p>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">[derive(Default, Debug, PartialEq)]
</span>pub struct Person {
    name: String,
    age: u32,
}

fn main() {
    assert_eq!(
        Person::default(),
        Person {
            name: String::new(),
            age: 0
        }
    );
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-13" id="参考资料-13">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">std::cmp::PartialEq</a></li>
<li><a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html?highlight=PartialEq#partialeq-and-eq-for-equality-comparisons">PartialEq#partialeq-and-eq-for-equality-comparisons</a></li>
</ul>
<h1><a class="header" href="#共享篋目录测试代码解释" id="共享篋目录测试代码解释">共享篋：目录测试代码解释</a></h1>
<h2><a class="header" href="#篇目-21" id="篇目-21">篇目</a></h2>
<ol>
<li><a href="hello-trait/lib-tests.html#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8BStructType%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">结构类型<code>StructType</code>自我实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E7%89%B9%E8%B4%A8TraitCanal%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">特质<code>TraitCanal</code>实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E7%89%B9%E8%B4%A8TraitKanal%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">特质<code>TraitKanal</code>实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">所有实现的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">基于模块的单元测试代码</a></li>
<li><a href="hello-trait/lib-tests.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-trait/lib-tests.html#%E6%B5%85%E8%AF%B4%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8BBox">浅说指针类型<code>Box</code></a></li>
<li><a href="hello-trait/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ol>
<h2><a class="header" href="#结构类型structtype自我实现的单元测试代码" id="结构类型structtype自我实现的单元测试代码">结构类型<code>StructType</code>自我实现的单元测试代码</a></h2>
<p>　　下面单元测试仅仅使用了结构类型<code>StructType</code>的自我实现。四个方法分别测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数new();</li>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数default();</li>
<li>使用结构类型<code>StructType</code>自我实现的方法get_data_for_all();</li>
<li>使用结构类型<code>StructType</code>自我实现的方法set_data_for_all();</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;

<span class="boring">[test]
</span>fn it_works_with_new() {
    let instance = StructType::new(10);
    assert_eq!(StructType::new(10), instance);
}

<span class="boring">[test]
</span>fn it_works_with_default() {
    let instance :StructType = Default::default();
    assert_eq!(StructType::new(0), instance);
}

<span class="boring">[test]
</span>fn it_works_with_get() {
    let instance = StructType::new(11);
    assert_eq!(11, instance.get_data_for_all());
    assert_eq!(StructType::new(11), instance);
}

<span class="boring">[test]
</span>fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data_for_all(&amp;12);
    assert_eq!(StructType::new(12), instance);
}

</code></pre></pre>
<h2><a class="header" href="#特质traitcanal实现的单元测试代码" id="特质traitcanal实现的单元测试代码">特质<code>TraitCanal</code>实现的单元测试代码</a></h2>
<p>　　下面单元测试使用了结构类型<code>StructType</code>的自我实现和特质<code>TraitCanal</code>实现。特别需要注意的是，从代码表面上看，第二行语句与后面代码没有任何关系。之所以代码里可以使用方法<code>get_data()</code>，就是因为第二行语句的作用。当我们写下第二行语句时，就应该知道接下来我们将要使用什么函数或／和方法。</p>
<p>　　方法<code>it_works_with_get()</code>测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数<code>new()</code>;</li>
<li>使用特质<code>TraitCanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<p>　　方法<code>it_works_with_default()</code>测试了：</p>
<ul>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数<code>default()</code>;</li>
<li>使用特质<code>TraitCanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitCanal;

<span class="boring">[test]
</span>fn it_works_with_get() {
    let instance = StructType::new(20);
    assert_eq!(20, instance.get_data());
    assert_eq!(StructType::new(20), instance);
}

<span class="boring">[test]
</span>fn it_works_with_default() {
    let instance :StructType = Default::default();
    assert_eq!(0, instance.get_data());
    assert_eq!(StructType::new(0), instance);
}

</code></pre></pre>
<h2><a class="header" href="#特质traitkanal实现的单元测试代码" id="特质traitkanal实现的单元测试代码">特质<code>TraitKanal</code>实现的单元测试代码</a></h2>
<p>　　下面单元测试使用了结构类型<code>StructType</code>的自我实现和特质<code>TraitKanal</code>实现。所以这里没有使用到特质<code>TraitCanal</code>实现。尽管下面代码没有使用特质<code>TraitCanal</code>实现，但是我们使用了标准库平等比较特质<code>PartialEq</code>，实现了代码测试。</p>
<p>　　方法<code>it_works_with_get()</code>测试了：</p>
<ul>
<li>使用结构类型<code>StructType</code>自我实现的实例化函数<code>new()</code>;</li>
<li>使用特质<code>TraitKanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<p>　　方法<code>it_works_with_default()</code>测试了：</p>
<ul>
<li>使用标准库默认特质<code>Default</code>实现的实例化函数<code>default()</code>;</li>
<li>使用特质<code>TraitKanal</code>实现的方法<code>get_data()</code>;</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitKanal;

<span class="boring">[test]
</span>fn it_works_with_set() {
    let mut instance = StructType::new(0);
    instance.set_data(&amp;30);
    assert_eq!(StructType::new(30), instance);
}

<span class="boring">[test]
</span>fn it_works_with_default() {
    let mut instance :StructType = Default::default();
    instance.set_data(&amp;30);
    assert_eq!(StructType::new(30), instance);
}

</code></pre></pre>
<h2><a class="header" href="#所有实现的单元测试代码" id="所有实现的单元测试代码">所有实现的单元测试代码</a></h2>
<p>　　下面单元测试程序的所有三个实现。所以最前面三行语句表示使用这三个实现。</p>
<pre><pre class="playpen"><code class="language-rust editable">use trait_exerci::StructType;
use trait_exerci::TraitCanal;
use trait_exerci::TraitKanal;

<span class="boring">[test]
</span>fn it_works_with_both_traits_and_new() {
    let mut instance = StructType::new(40);
    instance.set_data(&amp;41);
    assert_eq!(41, instance.get_data());
    assert_eq!(StructType::new(41), instance);
}

<span class="boring">[test]
</span>fn it_works_with_both_traits_and_default() {
    let mut instance :StructType = Default::default();
    instance.set_data(&amp;41);
    assert_eq!(41, instance.get_data());
    assert_eq!(StructType::new(41), instance);
}

</code></pre></pre>
<h2><a class="header" href="#基于模块的单元测试代码" id="基于模块的单元测试代码">基于模块的单元测试代码</a></h2>
<p>　　下面单元测试主要说明在模块下如何进行单元测试。除了定义模块之外，最重要的是，使用三个实现语句必须在模块内。</p>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">[cfg(test)]
</span>mod tests {
    use trait_exerci::StructType;
    use trait_exerci::TraitCanal;

<span class="boring">    [test]
</span>    fn it_works_with_new() {
        let instance = StructType::new(50);
        assert_eq!(StructType::new(50), instance);
    }

<span class="boring">    [test]
</span>    fn it_works_with_get() {
        let instance = StructType::new(51);
        assert_eq!(51, instance.get_data());
    }

<span class="boring">    [test]
</span>    fn it_works_with_new_and_box() {
        let instance = Box::new(StructType::new(52));
        assert_eq!(Box::new(StructType::new(52)), instance);
    }

<span class="boring">    [test]
</span>    fn it_works_with_get_and_box() {
        let instance = Box::new(StructType::new(53));
        assert_eq!(53, instance.get_data());
    }

    use trait_exerci::TraitKanal;
<span class="boring">    [test]
</span>    fn it_works_with_set() {
        let mut instance = StructType::new(54);
        instance.set_data(&amp;55);
        assert_eq!(StructType::new(55), instance);
    }

<span class="boring">    [test]
</span>    fn it_works_with_set_and_box() {
        let mut instance = Box::new(StructType::new(56));
        instance.set_data(&amp;57);
        assert_eq!(Box::new(StructType::new(57)), instance);
    }
}

</code></pre></pre>
<h2><a class="header" href="#题外话-7" id="题外话-7">题外话</a></h2>
<h3><a class="header" href="#浅说指针类型box" id="浅说指针类型box">浅说指针类型<code>Box</code></a></h3>
<p>　　Rust标准库提供了类型<code>Box&lt;T&gt;</code>。可以使用该类型<code>Box&lt;T&gt;</code>在堆上分配内容。此类型用于安全地抽象指向堆内存的指针。同时它具有更大的灵活性，允许将实现特质如<code>TraitCanal</code>的任何事物进行<code>Box</code>类型化。</p>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">[derive(Debug, Default)]
</span>pub struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person :Box&lt;Person&gt; = Box::new(Default::default());
    println!(&quot;{:?}&quot;, person);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-14" id="参考资料-14">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/30352802/what-does-the-box-keyword-do">what-does-the-box-keyword-do</a></li>
<li><a href="https://medium.com/@KevinHoffman/to-box-or-not-to-box-my-first-real-rust-refactor-db467119c4c7">To Box or not to Box — My First Real Rust Refactor</a></li>
</ul>
<h1><a class="header" href="#题外话-8" id="题外话-8">题外话</a></h1>
<h2><a class="header" href="#cargo工具第三方插件" id="cargo工具第三方插件">Cargo工具第三方插件</a></h2>
<pre><code class="language-bash"># --------------------------
# install
cargo install cargo-update
# --------------------------
# install
cargo install cargo-audit
# or upgrade with the crate `cargo`
cargo install --force cargo-audit
# or upgrade with the crate `cargo-update`
cargo install-update cargo-audit
# using
cargo audit
# --------------------------
# install
cargo install cargo-bloat
# using
# only 'bin' and 'cdylib' crate types are supported.
cargo bloat --release -n 10
cargo bloat --release --crates
# --------------------------
# install
cargo install cargo-edit
# using
cargo add &lt;CRATE&gt;
cargo rm &lt;CRATE&gt;
cargo upgrade
# --------------------------
# install
cargo install cargo-asm
cargo asm &lt;CRATE_NAME&gt;::&lt;MOD_NAME&gt;::&lt;FUNCTION_NAME&gt;
cargo llvm-ir &lt;CRATE_NAME&gt;::&lt;MOD_NAME&gt;::&lt;FUNCTION_NAME&gt;
</code></pre>
<h2><a class="header" href="#参考资料-15" id="参考资料-15">参考资料</a></h2>
<ul>
<li><a href="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html">Keeping-secure-with-cargo-audit-0.9</a></li>
<li><a href="https://crates.io/crates/cargo-audit">cargo-audit</a></li>
<li><a href="https://crates.io/crates/cargo-update">cargo-update</a></li>
<li><a href="https://crates.io/crates/cargo-edit">cargo-watch</a></li>
<li><a href="https://crates.io/crates/cargo-asm">cargo-asm</a></li>
<li><a href="https://stackoverflow.com/questions/39219961/how-to-get-assembly-output-from-building-with-cargo">how-to-get-assembly-output-from-building-with-cargo</a></li>
</ul>
<p><a href="https://crates.io/crates/mod_trait_exerci"><img src="https://img.shields.io/crates/v/mod_trait_exerci?label=mod_trait_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-mod-trait"><img src="https://img.shields.io/badge/hello--mod--trait-code-yellowgreen" alt="The Crate mod_trait_exerci Code" /></a></p>
<h1><a class="header" href="#软件篋mod_trait_exerci" id="软件篋mod_trait_exerci">软件篋mod_trait_exerci</a></h1>
<h2><a class="header" href="#学习内容-17" id="学习内容-17">学习内容</a></h2>
<ul>
<li>学习软件篋文件、模块与程序结构</li>
<li>了解和学习动态调度关键词<code>dyn</code></li>
<li>学习和理解动态与静态调度（Static vs Dynamic Dispatch）</li>
<li>衔接类型关键词<code>trait</code>作用</li>
</ul>
<h2><a class="header" href="#参考资料-16" id="参考资料-16">参考资料</a></h2>
<ul>
<li><a href="https://archive.fosdem.org/2018/schedule/event/rust_testing_mocking/attachments/slides/2113/export/events/attachments/rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf">rust_testing_mocking/slides/2113/testing_in_rust_by_donald_whyte.pdf</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.dyn.html">std keyword dyn</a></li>
<li><a href="https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/dyn-trait-for-trait-objects.html">dyn-trait-for-trait-objects</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html">a_quick_look_at_trait_objects_in_rust</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5d573e667aac08f960557b79d6385f6e">Code</a></li>
<li><a href="https://stackoverflow.com/questions/27567849/what-makes-something-a-trait-object">what-makes-something-a-trait-object</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic_dispatch</a></li>
<li><a href="https://doc.rust-lang.org/reference/identifiers.html">reference identifiers</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://blog.theenginerd.com/blog/2015/06/27/traits-on-generics/">traits-on-generics</a></li>
<li><a href="https://tutorialedge.net/rust/learning-generics-in-rust/">learning-generics-in-rust</a></li>
<li><a href="https://blog.jcoglan.com/2019/04/22/generic-returns-in-rust/">generic-returns-in-rust</a></li>
<li><a href="https://cprimozic.net/blog/writing-a-hashmap-to-struct-procedural-macro-in-rust/">writing-a-hashmap-to-struct-procedural-macro-in-rust</a></li>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">impls_and_traits</a></li>
</ul>
<h1><a class="header" href="#关于软件篋mod_trait_exerci" id="关于软件篋mod_trait_exerci">关于软件篋mod_trait_exerci</a></h1>
<h2><a class="header" href="#学习内容-18" id="学习内容-18">学习内容</a></h2>
<ul>
<li>了解项目名称和目录</li>
</ul>
<h2><a class="header" href="#篇目-22" id="篇目-22">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/about.html#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E6%B8%85%E5%8D%95">项目名称清单</a></li>
<li><a href="hello-mod-trait/about.html#%E8%BD%AF%E4%BB%B6%E7%AF%8B%E7%B1%BB%E5%9E%8B%E6%B8%85%E5%8D%95">软件篋类型清单</a></li>
<li><a href="hello-mod-trait/about.html#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">项目目录文件结构</a></li>
</ul>
<h2><a class="header" href="#项目名称清单-2" id="项目名称清单-2">项目名称清单</a></h2>
<table><thead><tr><th>项目类型</th><th>项目名称</th><th>相对路径</th><th>项目说明</th></tr></thead><tbody>
<tr><td>作业区</td><td><strong>hello-mod-trait</strong></td><td>./hello-mod-trait</td><td>开发共享软件篋工作区</td></tr>
<tr><td>共享篋</td><td>lib-hello</td><td>./hello-mod-trait/lib-hello</td><td>开发共享软件篋实例</td></tr>
<tr><td>本地程序</td><td>bin-local-hello</td><td>./hello-mod-trait/bin-local-hello</td><td>使用在本地的共享篋</td></tr>
<tr><td>仓库程序</td><td>bin-hello</td><td>./hello-mod-trait/bin-hello</td><td>使用在crates.io上共享篋</td></tr>
</tbody></table>
<h2><a class="header" href="#软件篋类型清单-2" id="软件篋类型清单-2">软件篋类型清单</a></h2>
<table><thead><tr><th>篋类型</th><th>篋名称</th><th>相对路径</th></tr></thead><tbody>
<tr><td>共享软件篋</td><td><strong>mod_trait_exerci</strong></td><td>./hello-mod-trait/lib-hello</td></tr>
<tr><td>可执行程序</td><td>bin-local-hello</td><td>./hello-mod-trait/bin-local-hello</td></tr>
<tr><td>可执行程序</td><td>bin-hello</td><td>./hello-mod-trait/bin-hello</td></tr>
</tbody></table>
<h2><a class="header" href="#项目目录文件结构" id="项目目录文件结构">项目目录文件结构</a></h2>
<pre><code class="language-bash">$ tree -L 3
.
├── Cargo.lock
├── Cargo.toml
├── README.md
├── bin-hello
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   ├── bin
│   │   └── main.rs
│   └── target
│       └── debug
├── bin-local-hello
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── main.rs
│   ├── target
│   │   └── debug
│   └── tests
│       └── type_both_hello.rs
└── lib-hello
    ├── Cargo.lock
    ├── Cargo.toml
    ├── README.md
    ├── examples
    │   ├── bare_hello.rs
    │   ├── box_dynamic_hello.rs
    │   ├── box_static_hello.rs
    │   ├── generics_fn_hello.rs
    │   ├── generics_impl_hello.rs
    │   ├── generics_trait_hello.rs
    │   ├── generics_type_hello.rs
    │   ├── simple_dynamic_dispatch.rs
    │   ├── simple_static_dispatch.rs
    │   ├── trait_dispatch_abstract.rs
    │   ├── trait_dispatch_concrete.rs
    │   ├── trait_fn_hello.rs
    │   ├── trait_instance_hello.rs
    │   └── trait_where_hello.rs
    ├── src
    │   ├── lib.rs
    │   ├── mod_bare
    │   ├── mod_dynamic_fn.rs
    │   ├── mod_static_fn.rs
    │   └── mod_where_fn.rs
    └── tests
        ├── box_dynamic_hello.rs
        ├── box_static_hello.rs
        ├── mod_bare.rs
        └── mod_trait.rs
</code></pre>
<h1><a class="header" href="#文件与模块" id="文件与模块">文件与模块</a></h1>
<p>　　在这一节里，学习Cargo项目文件、目录与模块相互关系。Rust语言表达模块的三种方式。</p>
<h2><a class="header" href="#学习内容-19" id="学习内容-19">学习内容</a></h2>
<ul>
<li>了解和学习本软件篋模块文件结构</li>
<li>理解和掌握Cargo项目目录与文件关系</li>
<li>理解和掌握Cargo项目模块与文件关系</li>
<li>理解和掌握Cargo项目文件与文件关系</li>
</ul>
<h2><a class="header" href="#篇目-23" id="篇目-23">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/crate-structure.html#%E6%96%87%E4%BB%B6%E6%9C%AC%E8%BA%AB%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">文件本身表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">文件名称表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">目录名称表达模块方式</a></li>
<li><a href="hello-mod-trait/crate-structure.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_00_structure.png" alt="image" /></p>
<h2><a class="header" href="#文件本身表达模块方式" id="文件本身表达模块方式">文件本身表达模块方式</a></h2>
<p>　　Ⓓ 使用模块关键词<code>mod</code>和代码块<code>{}</code>的表达式，在Rust语言程序文件里，可以定义任何一个或者多个不同名称的模块。</p>
<p>　　在文件lib.rs里，创建了称之为<code>mod_trait</code>模块，该模块实现代码也在该文件里。</p>
<h2><a class="header" href="#文件名称表达模块方式" id="文件名称表达模块方式">文件名称表达模块方式</a></h2>
<p>　　Ⓓ 使用模块关键词<code>mod</code>语句，在Rust语言程序文件里，可以定义任何一个或者多个不同的模块。</p>
<p>　　使用关键词<code>mod</code>语句，实现模块代码存在两种形式：以文件名称作为模块名称方式和以目录名称为模块名称方式。这里先解释前面一种情况，如程序文件<code>mod_generics.rs</code>。</p>
<p>　　实现以文件名称作为模块名称具体方法是，在文件<code>lib.rs</code>里，使用语句<code>pub mod mod_generics;</code>，且在与文件<code>lib.rs</code>相同的目录下，创建名称为<code>mod_generics.rs</code>模块程序文件，为了其自身模块，该文件不需要使用模块关键词了。</p>
<h2><a class="header" href="#目录名称表达模块方式" id="目录名称表达模块方式">目录名称表达模块方式</a></h2>
<p>　　程序文件<code>mod.rs</code>是第三种表达模块方式，即以目录名称为模块名称方式。</p>
<p>　　在程序文件<code>lib.rs</code>里，使用语句<code>pub mod mod_bare;</code>，说明了该模块是外部文件实现模块代码，但是从中微分确认其实现方式。我们看到在与文件<code>lib.rs</code>相同目录下存在目录<code>mod_bare</code>，说明了该实现在该目录下的文件，默认情况下就是程序文件<code>mod.rs</code>，所有模块目录的入口文件默认情况下都是该文件名称。</p>
<h2><a class="header" href="#参考资料-17" id="参考资料-17">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/48071513/how-to-use-one-module-from-another-module-in-a-rust-cargo-project">how-to-use-one-module-from-another-module-in-a-rust-cargo-project</a></li>
<li><a href="https://dev.to/saiumesh/modules-in-rust-programming-language-495m">modules-in-rust-programming-language</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/4-modules.html">rust-gentle-intro/modules</a></li>
<li><a href="https://doc.rust-lang.org/1.29.2/book/2018-edition/ch07-01-mod-and-the-filesystem.html">ch07-01-mod-and-the-filesystem</a></li>
<li><a href="https://stackoverflow.com/questions/48071513/how-to-use-one-module-from-another-module-in-a-rust-cargo-project">how-to-use-one-module-from-another-module-in-a-rust-cargo-project</a></li>
</ul>
<h1><a class="header" href="#共享篋程序结构和代码解释" id="共享篋程序结构和代码解释">共享篋：程序结构和代码解释</a></h1>
<p>　　在本节里，了解两个模块<code>mod_bare</code>和<code>mod_trait</code>结构和代码实现。</p>
<h2><a class="header" href="#学习内容-20" id="学习内容-20">学习内容</a></h2>
<ul>
<li>了解和学习不同结构类型关键词<code>struct</code>实现方法</li>
</ul>
<h2><a class="header" href="#篇目-24" id="篇目-24">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-codes.html#%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">基于结构类型的实现</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">基于衔接特质的实现</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF">学习理解编译错误</a></li>
<li><a href="hello-mod-trait/lib-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#基于结构类型的实现" id="基于结构类型的实现">基于结构类型的实现</a></h2>
<h3><a class="header" href="#模块mod_bare结构" id="模块mod_bare结构">模块<code>mod_bare</code>结构</a></h3>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_02_mod_bar.png" alt="image" /></p>
<h3><a class="header" href="#模块mod_bare代码" id="模块mod_bare代码">模块<code>mod_bare</code>代码</a></h3>
<p>https://doc.rust-lang.org/stable/error-index.html#E0038</p>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">[derive(Debug, Default, PartialEq)]
</span>pub struct StructType {
    pub data: (u32),
}

impl StructType {
    pub fn get_tuple(&amp;self) -&gt; (u32) {
        (self.data)
    }
}

<span class="boring">[derive(Debug, Default, PartialEq)]
</span>pub struct TupleType (pub u32);

impl TupleType {
    pub fn get_tuple(&amp;self) -&gt; (u32) {
        (self.0)
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现" id="基于衔接特质的实现">基于衔接特质的实现</a></h2>
<h3><a class="header" href="#模块mod_trait结构" id="模块mod_trait结构">模块<code>mod_trait</code>结构</a></h3>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_01_mod_trait.png" alt="image" /></p>
<h3><a class="header" href="#模块mod_trait代码" id="模块mod_trait代码">模块<code>mod_trait</code>代码</a></h3>
<p>　　两个类型的函数new()是通过属性值，实现创建其类型的实例，而特质方法get_object()是通过其类型本身实例，实现创建一个新的类型实例。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub mod mod_bare;
pub mod mod_where_fn;
pub mod mod_static_fn;
pub mod mod_box_static_fn;
pub mod mod_dynamic_fn;
pub mod mod_box_dynamic_fn;

pub mod mod_trait {
<span class="boring">    [derive(Debug, Default, PartialEq, Copy, Clone)]
</span>    pub struct StructType {
        data: (u32),
    }

<span class="boring">    [derive(Debug, Default, PartialEq, Copy, Clone)]
</span>    pub struct TupleType(pub u32);

    pub trait TraitCanal {
        fn get_object(&amp;self) -&gt; Self where Self: Sized;  // For keyword `dyn`
        //fn get_object(&amp;self) -&gt; Self;                  // E0038 For keyword `dyn`; OK for static functions
        fn get_tuple(&amp;self) -&gt; (u32);
    }

    impl TraitCanal for StructType {
        fn get_object(&amp;self) -&gt; Self {
            StructType{data: self.data}
        }

        fn get_tuple(&amp;self) -&gt; (u32) {
            println!(&quot;impl TraitCanal for StructType&quot;);
            (self.data)
        }
    }

    impl TraitCanal for TupleType {
        fn get_object(&amp;self) -&gt; Self {
            TupleType(self.0)
        }

        fn get_tuple(&amp;self) -&gt; (u32) {
            println!(&quot;impl TraitCanal for TupleType&quot;);
            (self.0)
        }
    }

    impl StructType {
        pub fn new(_data: u32) -&gt; Self {
            StructType{data: _data}
        }
    }

    impl TupleType {
        pub fn new(_data: u32) -&gt; Self {
            TupleType(_data)
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#题外话-9" id="题外话-9">题外话</a></h2>
<h3><a class="header" href="#学习理解编译错误" id="学习理解编译错误">学习理解编译错误</a></h3>
<p>　　在程序文件<code>src/lib.rs</code>里，使用关键词<code>trait</code>定义衔接特质<code>TraitCanal</code>代码块的第一行代码注释掉，而第二行代码去掉注释，一旦执行编译，就会出现下面错误信息：<code>error[E0038]</code>。</p>
<pre><code>error[E0038]: the trait `mod_trait::TraitCanal` cannot be made into
an object
--&gt; lib-hello/src/mod_dynamic_fn.rs:4:1
|
4 | pub fn get_dynamic_trait_ref(canal: &amp;dyn TraitCanal) -&gt; (u32) {
| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ t
he trait `mod_trait::TraitCanal` cannot be made into an object
|
= note: method `init` references the `Self` type in its arguments
or return type
</code></pre>
<p>　　下面链接里的<code>E0038</code>就是该错误编号，点击下面链接就可以了解到错误的原因信息。</p>
<p><a href="https://doc.rust-lang.org/stable/error-index.html#E0038">https://doc.rust-lang.org/stable/error-index.html#E0038</a></p>
<h2><a class="header" href="#参考资料-18" id="参考资料-18">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/error-index.html">Rust Compiler Error Index</a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">std Sized</a></li>
<li><a href="https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait">why-is-the-sized-bound-necessary-in-this-trait</a></li>
</ul>
<h1><a class="header" href="#三种调用方式解释" id="三种调用方式解释">三种调用方式解释</a></h1>
<p>　　在本节里，通过两个模块<code>mod_bare</code>和<code>mod_trait</code>实现及其三种调用方式比较，详细说明衔接关键词<code>trait</code>作用。</p>
<h2><a class="header" href="#学习内容-21" id="学习内容-21">学习内容</a></h2>
<ul>
<li>理解衔接关键词<code>trait</code>的重要性</li>
<li>掌握衔接关键词<code>trait</code>实现的应用方法</li>
</ul>
<h2><a class="header" href="#篇目-25" id="篇目-25">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8">基于结构类型的实现：使用实例调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8">基于衔接特质的实现：使用实例调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E6%A8%A1%E5%9D%97">基于衔接特质的模块</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%9F%BA%E4%BA%8E%E8%A1%94%E6%8E%A5%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8">基于衔接特质的实现：作为参数调用</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%B5%85%E8%AF%B4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B">浅说面向对象编程、命令式编程和声明式编程</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84">数据类型数组</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95">泛型函数与方法</a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E7%B1%BB%E5%9E%8B%E8%8C%83%E5%9B%B4%E5%85%B3%E9%94%AE%E8%AF%8Dwhere">类型范围关键词<code>where</code></a></li>
<li><a href="hello-mod-trait/exampels-codes.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p><img src="hello-mod-trait/../../images/hello_mod_trait_04_apply_ways.png" alt="image" /></p>
<h2><a class="header" href="#基于结构类型的实现使用实例调用" id="基于结构类型的实现使用实例调用">基于结构类型的实现：使用实例调用</a></h2>
<p>　　从上面图示，可以了解到下面程序文件直接访问模块<code>mod_bare</code>，该模块是基于结构类型的实现，不存在衔接特质。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/bare_hello.rs
use mod_trait_exerci::mod_bare::StructType;
use mod_trait_exerci::mod_bare::TupleType;

fn get_data_from_struct(instances: [StructType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

fn get_data_from_tuple(instances: [TupleType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

// clear &amp;&amp; cargo run --example bare_hello
fn main() {
    let instances: [StructType; 2] = [Default::default(), StructType{data:0}];
    get_data_from_struct(instances);

    let instances: [TupleType; 2] = [Default::default(), TupleType(0)];
    get_data_from_tuple(instances);    
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现使用实例调用" id="基于衔接特质的实现使用实例调用">基于衔接特质的实现：使用实例调用</a></h2>
<p>　　从上面图示，下面程序文件也是直接访问模块<code>mod_trait</code>本身，与上面应用实例不同，这里通过衔接特质方式实现代码，从代码的关键词<code>use</code>语句也可以了解到这一点。</p>
<p>　　比较上面程序文件<code>bare_hello.rs</code>和下面文件<code>trait_instance_hello.rs</code>的关键词<code>use</code>语句，可以看到，上面程序文件里的关键词<code>use</code>语句访问模块，采用了绝对路径方式，而下面文件既有绝对路径方式，也有相对路径方式。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_instance_hello.rs
use mod_trait_exerci::mod_trait;
use mod_trait::TraitCanal;
use mod_trait::StructType;
use mod_trait::TupleType;

fn get_data_from_struct(instances: [StructType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

fn get_data_from_tuple(instances: [TupleType; 2]) {
    let data = instances[0].get_tuple();
    assert_eq!(0, data);
    assert_eq!((0), data);
    assert_eq!(instances[0], instances[1]);
    println!(&quot;{:?}&quot;, instances[0]);
    println!(&quot;{:?}&quot;, instances[1]);
}

// clear &amp;&amp; cargo run --example trait_instance_hello
fn main() {
    let instances: [StructType; 2] = [Default::default(), StructType::new(0)];
    get_data_from_struct(instances);

    let instances: [TupleType; 2] = [Default::default(), TupleType::new(0)];
    get_data_from_tuple(instances);    
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的模块" id="基于衔接特质的模块">基于衔接特质的模块</a></h2>
<p>　　从上面图示，可以了解到，下面程序文件也是一个模块<code>mod_where_fn</code>，该模块应用了模块<code>mod_trait</code>的功能，注意该文件关键词<code>use</code>语句只使用了衔接特质<code>TraitCanal</code>，这也是一种访问其父模块的相对路径方式。它的存在意义是什么？这是为用户提供更加灵活的实现而设计的。这里提供了怎么样使用模块，而不必用户完成实现。</p>
<p>　　下面代码的方法是一种泛型方法的表达方式，其概念参考下面说明。</p>
<p>　　下面将会说明关键词<code>where</code>。在文件<code>mod_where_fn.rs</code>里的两个函数是两个完全相同的实现，只是语法表达方式不同而已。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_where_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32) {
    typ.get_tuple()
}

pub fn get_static_type_ref_with_where&lt;Type&gt;(typ: &amp;Type) -&gt; (u32)
    where Type: TraitCanal {
    typ.get_tuple()
}

</code></pre></pre>
<h2><a class="header" href="#基于衔接特质的实现作为参数调用" id="基于衔接特质的实现作为参数调用">基于衔接特质的实现：作为参数调用</a></h2>
<p>　　从上面图示，可以了解到下面程序文件并不是直接访问模块<code>mod_trait</code>本身，而是访问中间模块<code>mod_where_fn</code>完成的，这是一种更加方便和灵活的三层程序设计结构。与模块<code>mod_trait</code>不同，它实现的功能更多的是数据操作功能，这里称之为“<code>数据模块</code>”，而这种中间模块<code>mod_where_fn</code>，它提供更多样化的有实际意义知识性功能，这里称之为“<code>知识模块</code>”。</p>
<p>　　无论是什么类型结构，为了获取不同的结构类型属性，都不需要访问其属性名称。</p>
<p>　　在使用模块<code>mod_where_fn</code>的函数时，结构类型的实例是作为参数传递给该模块的函数。我们仅仅告诉它我们是‘谁’，我们需要做什么。</p>
<p>　　模块<code>mod_trait</code>告诉我们是什么功能，这好比是产品生产原料。模块<code>mod_where_fn</code>解决了怎么做问题，这好比是为用户预先打造的特定产品，当然用户也可以自己制造自己需要的产品。这里程序文件说明了要做什么事情，这好比作为用户使用现成的产品。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_where_hello.rs
use mod_trait_exerci::mod_where_fn;
use mod_trait_exerci::mod_trait;
use mod_trait::StructType;
use mod_trait::TupleType;

fn static_struct_ref_with_where(instance: &amp;StructType) {
    let data = mod_where_fn::get_static_type_ref_with_where(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

fn static_tuple_ref_with_where(instance: &amp;TupleType) {
    let data = mod_where_fn::get_static_type_ref_with_where(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

// clear &amp;&amp; cargo run --example trait_where_hello
fn main() {
    let instance: StructType = Default::default();
    static_struct_ref_with_where(&amp;instance);

    let instance: TupleType = Default::default();
    static_tuple_ref_with_where(&amp;instance);
}
</code></pre></pre>
<h2><a class="header" href="#题外话-10" id="题外话-10">题外话</a></h2>
<h3><a class="header" href="#浅说面向对象编程命令式编程和声明式编程" id="浅说面向对象编程命令式编程和声明式编程">浅说面向对象编程、命令式编程和声明式编程</a></h3>
<p>　　面向对象编程回答了是什么，命令式编程回答了怎么做，而声明式编程回答了做什么。</p>
<h3><a class="header" href="#数据类型数组" id="数据类型数组">数据类型数组</a></h3>
<p>　　在Rust语言里，数组是一种基本数据类型。</p>
<h2><a class="header" href="#泛型函数与方法" id="泛型函数与方法">泛型函数与方法</a></h2>
<p>　　在类型理论中，泛型称之为参数多态（parametric polymorphism），对于给定参数（parametric）能够有多种形式（poly是多，morph是形态）的函数或类型。</p>
<p>　　在Rust语言里，泛型是一种非常广泛采用的技术，不仅应用函数与方法关键词<code>fn</code>，也应用衔接特质关键词<code>trait</code>等等。其目的是，减少代码重复。</p>
<h3><a class="header" href="#类型范围关键词where" id="类型范围关键词where">类型范围关键词<code>where</code></a></h3>
<p>　　关键词<code>where</code>用于向泛型类型添加约束，并为编译器提供解决问题所需的信息！</p>
<h2><a class="header" href="#参考资料-19" id="参考资料-19">参考资料</a></h2>
<ul>
<li><a href="https://mgattozzi.github.io/2016/09/13/understanding-where-clauses.html">understanding-where-clauses</a></li>
</ul>
<h1><a class="header" href="#理解动态与静态调度实现" id="理解动态与静态调度实现">理解动态与静态调度实现</a></h1>
<p>　　在这一节里，介绍Rust语言调度动态与静态函数的方式。动态与静态调度函数是计算机语言广泛应用的概念和技术。</p>
<h2><a class="header" href="#学习内容-22" id="学习内容-22">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言静态和动态函数概念</li>
<li>理解和掌握静态和动态函数基本实现</li>
</ul>
<h2><a class="header" href="#篇目-26" id="篇目-26">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/examples-dispatch.html#%E6%9C%80%E5%B8%B8%E8%A7%81%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B">最常见静态函数实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BE%8B">静态函数的动态调度实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B">调用动态函数的实例</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86%E7%AC%A6%E5%89%8D%E7%BC%80r">原始标识符前缀<code>r#</code></a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BVec">数据类型<code>Vec</code></a></li>
<li><a href="hello-mod-trait/examples-dispatch.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#最常见静态函数实例" id="最常见静态函数实例">最常见静态函数实例</a></h2>
<p>　　Ⓓ 在默认情况下，Rust语言方法都是静态函数。如下面代码的函数<code>static_dispatch()</code>。</p>
<p>　　静态调度或者分派（static dispatch）在编译时就知道被调用方是谁，而动态调度只有在运行时，才知道被调用方是谁。显然，在常见的情况下，相比动态调度，在运行程序时，静态调度会更快速，而相比静态调度，在编译程序时，动态调度会更快速。</p>
<p>　　在使用静态分派会更有效，因为总是可以使用静态分派包装器函数来执行动态调度，但反之则不然。由于这个原因，比如标准库尝试在尽可能的情况下进行静态调度。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/simple_static_dispatch.rs
<span class="boring">[derive(Default)]
</span>struct NormalStruct {
    data: (u8)
}

impl NormalStruct {
    fn static_dispatch(&amp;self) -&gt; (u8) { (self.data) }
}

// clear &amp;&amp; cargo run --example simple_static_dispatch
fn main() {
    let instance_struct :NormalStruct = Default::default();
    assert_eq!((0u8), instance_struct.static_dispatch());
}
</code></pre></pre>
<h2><a class="header" href="#静态函数的动态调度实例" id="静态函数的动态调度实例">静态函数的动态调度实例</a></h2>
<p>　　上面程序与下面程序的前面一部分是完全一致的。而下面程序的后面一部分代码动态方式调度静态函数。</p>
<p>　　下面程序的关键词<code>dyn</code>就是告诉编译器需要进行动态方式调度。但是，要是关键词<code>dyn</code>不在，也能够通过编译，只是有警告提示“不带显式<code>dyn</code>的衔接特质对象已弃用”，这告诉我们代码需要增加动态调度关键词<code>dyn</code>。</p>
<p>　　这个警告提示提供了一条信息：我们正在涉及到的是衔接特质的一个或者一组对象，之所以需要动态方式，是因为，在Rust语言里衔接特质关键词<code>trait</code>可以针对任何类型实现功能，这是一种未知类型行为的随时调度方式。衔接特质的对象如同一个衔接插口，可以随时插到任何一个类型上。</p>
<p>　　在动态调度时，Rust语言需要衔接特质对象的指针。从下面后面的三段代码里，可以理解到这个概念。比如。指针类型<code>Box</code>把实例<code>instance_struct</code>包装为指针类型；类型Vec的内部项都是实例<code>instance_struct</code>的指针类型。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/simple_dynamic_dispatch.rs
trait Trait {
    fn static_dispatch(&amp;self) -&gt; (u8);
}

<span class="boring">[derive(Default)]
</span>struct Struct {data: (u8)}

impl Trait for Struct {
    fn static_dispatch(&amp;self) -&gt; (u8) {
        (self.data)
    }
}

// clear &amp;&amp; cargo run --example simple_dynamic_dispatch
fn main () {
    let instance_struct: Struct = Default::default();
    assert_eq!((0u8), instance_struct.static_dispatch());

    let instance_struct: Struct = Default::default();
    let box_struct: Box&lt;dyn Trait&gt; = Box::new(instance_struct);
    assert_eq!((0), box_struct.static_dispatch());

    let instance_struct: Struct = Default::default();
    let mut v: Vec&lt;&amp;dyn Trait&gt; = Vec::new();
    v.push(&amp;instance_struct);
    for instance_struct in v.iter() {
        assert_eq!((0), instance_struct.static_dispatch());
    }

    let instance_struct: Struct = Default::default();
    let mut v: Vec&lt;Box&lt;dyn Trait&gt;&gt; = Vec::new();
    v.push(Box::new(instance_struct));
    for instance_struct in v.iter() {
        assert_eq!((0), instance_struct.static_dispatch());
    }    
}
</code></pre></pre>
<h2><a class="header" href="#调用动态函数的实例" id="调用动态函数的实例">调用动态函数的实例</a></h2>
<p>　　这里将说明基于衔接特质关键性<code>trait</code>的静态和动态函数实现，但是这静态函数与之前的也是完全不一样的概念。另外将会看到调用这种动态函数，它们看起来是一些更复杂的静态和动态函数。</p>
<p>　　下面程序第二段代码的两个函数<code>static_dispatch()</code>和<code>dynamic_dispatch()</code>，它们的目的是解决代码重复的相同问题。但是其手段是不同的。</p>
<p>　　Rust语言没有继承概念，继承编程不再是软件开发的思想。通过关键词<code>trait</code>定义函数，借助于关键词impl实现函数及其泛型编程方法，以实现多态式编程方法。静态函数<code>static_dispatch()</code>使用了泛型编程方法，关于泛型编程将有另外专题说明。</p>
<p>　　Rust语言也通过衔接特质对象及动态调度编程方法，来实现多态式编程方法。动态函数<code>dynamic_dispatch()</code>使用了动态编程方法。特性对象是不限类型的，动态绑定类型是通过实时运行时具体地匹配类型。</p>
<p>　　从代码上看，静态函数<code>static_dispatch()</code>和动态函数<code>dynamic_dispatch()</code>都是实现相同的功能。</p>
<p>　　下面程序第三段代码里，无论是类型<code>NormalStruct</code>，还是类型<code>TupleStruct</code>，它们都是以同一方式分别调用函数<code>static_dispatch()</code>和函数<code>dynamic_dispatch()</code>。</p>
<p>　　不管是静态函数，还是动态函数，它们都是基于衔接特质对象的指针实现，这一点是非常重要的。</p>
<p>　　下面程序是Rust语言非常经典的代码结构。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_dispatch_concrete.rs
// 1. Define and Implement struct, trait and impl..for
struct NormalStruct {
    data: (u8)
}

trait Trait {
    fn _fn(&amp;self) -&gt; (u8);
}

impl Trait for NormalStruct {
    fn _fn(&amp;self) -&gt; (u8) { (self.data) }
}

struct TupleStruct(u8);

impl Trait for TupleStruct {
    fn _fn(&amp;self) -&gt; (u8) { (self.0) }
}

// 2. Implement static and dynamic dispatch
fn static_dispatch&lt;TraitObject: Trait&gt;(r#type: &amp;TraitObject) {
    r#type._fn(); 
}

fn dynamic_dispatch(r#trait: &amp;dyn Trait) {
    r#trait._fn();
}

// 3. Use these dispatch functions
// clear &amp;&amp; cargo run --example trait_dispatch_concrete
fn main() {
    let instance_struct = NormalStruct{data: 0};
    assert_eq!((), static_dispatch(&amp;instance_struct));
    assert_eq!((), dynamic_dispatch(&amp;instance_struct));

    let instance_tuple = TupleStruct(0);
    assert_eq!((), static_dispatch(&amp;instance_tuple));
    assert_eq!((), dynamic_dispatch(&amp;instance_tuple));
}
</code></pre></pre>
<h2><a class="header" href="#题外话-11" id="题外话-11">题外话</a></h2>
<h3><a class="header" href="#原始标识符前缀r" id="原始标识符前缀r">原始标识符前缀<code>r#</code></a></h3>
<p>　　原始标识符也是一种标识符，其前缀是<code>r#</code>，之后也可以加上任何严格或保留的关键字，但除关键字<code>crate, extern, self, super, Self</code>外。</p>
<h3><a class="header" href="#向量数据类型vec" id="向量数据类型vec">向量数据类型<code>Vec</code></a></h3>
<p>　　向量数据类型<code>Vec</code>也是一种数组，其内部是以0开始进行排序的，但是这种数组大小是可调整的，或者说是一种连续的且可增长的数组类型。</p>
<h2><a class="header" href="#参考资料-20" id="参考资料-20">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/identifiers.html">reference identifiers</a></li>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/doc-02-21-2015/book/static-and-dynamic-dispatch.html">static-and-dynamic-dispatch</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html">book static-and-dynamic-dispatch</a></li>
<li><a href="https://jmarcher.io/when-does-dynamic-vs-static-dispatch-matter/">when-does-dynamic-vs-static-dispatch-matter</a></li>
<li><a href="https://riptutorial.com/rust/example/4656/static-and-dynamic-dispatch">riptutorial.com static-and-dynamic-dispatch</a></li>
<li><a href="https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/">exploring-dynamic-dispatch-in-rust</a></li>
<li><a href="https://joshleeb.com/posts/rust-traits-and-trait-objects/">rust-traits-and-trait-objects</a></li>
<li><a href="https://gist.github.com/greister/37289c6eb3629d4fefa7dd0acf6de378">Static vs Dynamic dispatch</a></li>
<li><a href="https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html">a_quick_look_at_trait_objects_in_rust</a></li>
<li><a href="https://learning-rust.github.io/docs/b5.impls_and_traits.html">b5.impls_and_traits</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.dyn.html">std keyword dyn</a></li>
<li><a href="https://stackoverflow.com/questions/25818082/vector-of-objects-belonging-to-a-trait/25819164">Vector of objects belonging to a trait</a></li>
</ul>
<h1><a class="header" href="#深度解析动态与静态调度实现" id="深度解析动态与静态调度实现">深度解析动态与静态调度实现</a></h1>
<p>　　在本节里。主要解释静态函数与动态函数的内部结构。</p>
<h2><a class="header" href="#学习内容-23" id="学习内容-23">学习内容</a></h2>
<ul>
<li>进一步学习静态函数与动态函数</li>
<li>通过Miri了解分析Rust语言代码</li>
</ul>
<h2><a class="header" href="#篇目-27" id="篇目-27">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/examples-miri.html#%E4%BB%80%E4%B9%88%E6%98%AFMiri">什么是Miri</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E4%B8%8EMiri%E7%9B%B8%E5%85%B3%E7%9A%84Cargo%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4">与Miri相关的Cargo工具命令</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E6%89%93%E5%BC%80Miri%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4">打开Miri代码文件命令</a></li>
<li><a href="hello-mod-trait/examples-miri.html#Miri%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E">Miri代码实例说明</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E4%B8%8E%E7%89%B9%E8%B4%A8%E5%AF%B9%E8%B1%A1">类型泛型参数与特质对象</a></li>
<li><a href="hello-mod-trait/examples-miri.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#什么是miri" id="什么是miri">什么是Miri</a></h2>
<p>　　<a href="https://github.com/rust-lang/miri">Miri</a>网站说明如下：</p>
<pre><code>An experimental interpreter for Rust's mid-level intermediate representation (MIR).
</code></pre>
<p>直接翻译为：Rust语言的中间中级水平表达层（mid-level intermediate representation，MIR）的实验解释器。这里有两个中间是什么意思？“intermediate”是说明Miri是介于Rust语言与汇编语言编译过程的中间位置；“mid-level”可以理解为表达层代码水平。</p>
<p>　　Miri作用是什么？在编译器中引入这一表达层（MIR），消除了Rust语言代码大部分表面的表示层（mid-level），留下了一种更简单的形式，目的是适合于类型检查和翻译成汇编语言（intermediate）。</p>
<h2><a class="header" href="#与miri相关的cargo工具命令" id="与miri相关的cargo工具命令">与Miri相关的Cargo工具命令</a></h2>
<p>　　在项目根目录下，执行代码命令，可以得到Miri代码文件。一般情况下，该文件是不会出现在项目目录里的。</p>
<p>　　这个命令是两部分，在`cargo之前部分，是告诉编译器想到得到额外的编译结果。后面部分是想编译什么内容。</p>
<p>　　与Miri编译相关内容是在<code>release</code>编译版本下才能得到。</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;--emit mir&quot; cargo build --release --example trait_dispatch_concrete
</code></pre>
<h2><a class="header" href="#打开miri代码文件命令" id="打开miri代码文件命令">打开Miri代码文件命令</a></h2>
<p>　　可以通过资源管理器来寻找如下命令里的目录文件，也可以使用下面命令打开，其中<code>-t</code>是告诉命令<code>open</code>使用默认编辑器打开该文件。该文件名称非常长，所以命令里使用了星号。</p>
<p>　　从网络上看，还没有能够显示Miri代码的工具。</p>
<pre><code class="language-bash">open -t ./target/release/examples/trait_dispatch_concrete-*.mir
</code></pre>
<h2><a class="header" href="#miri代码实例说明" id="miri代码实例说明">Miri代码实例说明</a></h2>
<p>　　为了说明问题，下面Miri代码仅仅是其一部分代码，包括静态函数和动态函数，并且还是省略过的。凡是&quot;...&quot;都是两个函数相同的代码。</p>
<p>　　从下面的Miri代码里，可以看到，函数<code>static_dispatch()</code>的参数只有一个，它是衔接特质的对象指针，函数<code>dynamic_dispatch</code>的参数也只有一个，它是衔接特质的指针。除了这一点区别之外，其余都是一样的。</p>
<p>　　从上面分析可以了解到，衔接特质的对象是确定的，使用它，可以理解为已知类型的特质准备的，而动态的衔接特质是不确定的，可以理解为未知类型的特质准备的。</p>
<pre><code>fn  static_dispatch(_1: &amp;TraitObject) -&gt; () {
    ...
    let mut _3: &amp;TraitObject;            // in scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:23:5: 23:11

    bb0: {
        ...
        _2 = const &lt;TraitObject as Trait&gt;::fn(move _3) -&gt; bb1; // bb0[3]: scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:23:5: 23:18 //...

    }

    bb1: {
        ...
    }
}
</code></pre>
<pre><code>fn  dynamic_dispatch(_1: &amp;dyn Trait) -&gt; () {
    ...
    let mut _3: &amp;dyn Trait;              // in scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:27:5: 27:12

    bb0: {
        ...
        _2 = const &lt;dyn Trait as Trait&gt;::fn(move _3) -&gt; bb1; // bb0[3]: scope 0 at lib-hello/examples/trait_dispatch_concrete.rs:27:5: 27:19 //...
    }

    bb1: {
        ...
    }
}
</code></pre>
<h2><a class="header" href="#类型泛型参数与特质对象" id="类型泛型参数与特质对象">类型泛型参数与特质对象</a></h2>
<p>　　类型泛型参数（generics type parameters）与特质对象（trait objects）</p>
<h2><a class="header" href="#参考资料-21" id="参考资料-21">参考资料</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/miri">An interpreter for Rust's mid-level intermediate representation</a></li>
</ul>
<h1><a class="header" href="#共享篋简单三层结构实现" id="共享篋简单三层结构实现">共享篋：简单三层结构实现</a></h1>
<p>　　在前面学习概念基础之上，在这一节里，将会实现共享篋的简单三层结构。</p>
<h2><a class="header" href="#学习内容-24" id="学习内容-24">学习内容</a></h2>
<ul>
<li>理解和掌握知识模块的实现</li>
</ul>
<h2><a class="header" href="#篇目-28" id="篇目-28">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-fn.html#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">静态函数的知识模块实现</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">动态函数的知识模块实现</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">应用实例</a></li>
<li><a href="hello-mod-trait/lib-fn.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#静态函数的知识模块实现" id="静态函数的知识模块实现">静态函数的知识模块实现</a></h2>
<p>　　下面模块<code>mod_static_fn</code>代码，利用衔接特质<code>TraitCanal</code>，实现了两个不同功能的静态函数：<code>get_static_type_ref()</code>和<code>print_static_all_daten()</code>。</p>
<p>　　关于函数<code>get_static_type_ref()</code>，输入实例是类型<code>StructType</code>或者<code>TupleType</code>的指针，输出是类型<code>tuple</code>，其元素值是它们属性<code>data</code>值。</p>
<p>　　关于函数<code>print_static_all_daten()</code>，输入实例是<code>StructType</code>或者<code>TupleType</code>数组的指针，程序接受输入实例以后，打印输入实例及其属性内容。</p>
<p>　　为了使用函数<code>print_static_all_daten()</code>里的打印宏，程序里需要做到两点：</p>
<ul>
<li>使用语句：<code>use std::fmt::Debug;</code>;</li>
<li>函数参数里增加该特质<code>Debug</code>;</li>
</ul>
<p>但是第一条语句应该不需要，因为类型<code>StructType</code>和<code>TupleType</code>已经声明过了特质<code>Debug</code>。如特质<code>PartialEq</code>就没有使用<code>use</code>语句，这是因为类型<code>StructType</code>和<code>TupleType</code>也已经声明过了<code>PartialEq</code>。但是有一点是肯定的：先要声明特质，然后还要在静态函数里使用它们，才能真正实现使用这些特质。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_static_fn.rs
use super::mod_trait::TraitCanal;
use std::fmt::Debug;
use std::cmp::PartialEq;

//get_static_type_ref&lt;T&gt;
//get_static_trait_ref::&lt;StructType&gt;
//get_static_trait_ref::&lt;TupleType&gt;

// get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32)
//get_static_trait_ref(typ: &amp;StructType) -&gt; (u32)
//get_static_trait_ref(typ: &amp;TupleType) -&gt; (u32)

// static: Generics type parameters
// dynamic: trait objects

pub fn get_static_type_ref&lt;Type: TraitCanal&gt;(typ: &amp;Type) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn print_static_all_daten&lt;Type: TraitCanal+Debug+PartialEq&gt;(typs: &amp;[Type]) {
    for typ in typs {
        let data = typ.get_tuple();
        println!(&quot;{:?}&quot;, typ);          // FOR Debug
        println!(&quot;{:?}&quot;, data);         // FOR Debug
        assert_eq!(*typ, typ.get_object());   // FOR PartialEq
    }
}
</code></pre></pre>
<h2><a class="header" href="#动态函数的知识模块实现" id="动态函数的知识模块实现">动态函数的知识模块实现</a></h2>
<p>　　下面模块<code>mod_dynamic_fn</code>代码的函数，与前面的说明完全类似。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_dynamic_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_dynamic_trait_ref(canal: &amp;dyn TraitCanal) -&gt; (u32) {
    (canal.get_tuple())
}

</code></pre></pre>
<h2><a class="header" href="#应用实例" id="应用实例">应用实例</a></h2>
<p>　　</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/trait_fn_hello.rs
// clear &amp;&amp; cargo run --example trait_fn_hello
use mod_trait_exerci::mod_static_fn;
use mod_trait_exerci::mod_dynamic_fn;
use mod_trait_exerci::mod_trait;
use mod_trait::StructType;
use mod_trait::TupleType;

fn get_data_from_struct(instance: &amp;StructType) {
    let data = mod_static_fn::get_static_type_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
    let data = mod_dynamic_fn::get_dynamic_trait_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

fn get_data_from_tuple(instance: &amp;TupleType) {
    let data = mod_static_fn::get_static_type_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
    let data = mod_dynamic_fn::get_dynamic_trait_ref(instance);
    assert_eq!(0, data);
    assert_eq!((0), data);
}

// clear &amp;&amp; cargo run --example trait_fn_hello
fn main() {
    let instance: StructType = Default::default();
    get_data_from_struct(&amp;instance);

    let instance: TupleType = Default::default();
    get_data_from_tuple(&amp;instance);

    let instance: TupleType = Default::default();
    let instances = vec![instance, TupleType::new(100)];
    mod_static_fn::print_static_all_daten(&amp;instances);    
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-22" id="参考资料-22">参考资料</a></h2>
<h1><a class="header" href="#共享篋基于封装的静态调度实现" id="共享篋基于封装的静态调度实现">共享篋：基于封装的静态调度实现</a></h1>
<p>　　在这一节里，列出基于指针类型<code>Box</code>封装的静态调度实现。</p>
<h2><a class="header" href="#学习内容-25" id="学习内容-25">学习内容</a></h2>
<ul>
<li>了解和学习基于指针类型<code>Box</code>封装的静态函数实现方法</li>
</ul>
<h2><a class="header" href="#篇目-29" id="篇目-29">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-static.html#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">静态模块实现</a></li>
<li><a href="hello-mod-trait/lib-static.html#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E5%BA%94%E7%94%A8">静态模块应用</a></li>
<li><a href="hello-mod-trait/lib-static.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#静态模块实现" id="静态模块实现">静态模块实现</a></h2>
<p>　　</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_static_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_static_box_ref&lt;Type: TraitCanal&gt;(typ: &amp;Box&lt;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box&lt;Type: TraitCanal&gt;(typ: Box&lt;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box_type_ref&lt;Type: TraitCanal + ?Sized&gt;(typ: Box&lt;&amp;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}

pub fn get_static_box_and_type_ref&lt;Type: TraitCanal + ?Sized&gt;(typ: &amp;Box&lt;&amp;Type&gt;) -&gt; (u32) {
    (typ.get_tuple())
}


</code></pre></pre>
<h2><a class="header" href="#静态模块应用" id="静态模块应用">静态模块应用</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">use mod_trait_exerci::mod_box_static_fn;
use mod_trait_exerci::mod_trait::StructType;
use mod_trait_exerci::mod_trait::TraitCanal;
use mod_trait_exerci::mod_trait::TupleType;

// clear &amp;&amp; cargo run --example box_static_hello
fn main() {
    let instance: StructType = Default::default();
    let instance_box_type: Box&lt;StructType&gt; = Box::new(instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box(instance_box_type));

    let instance: StructType = Default::default();
    let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box_type_ref(instance_box_type));

    let instance: TupleType = Default::default();
    let instance_box_type: Box&lt;TupleType&gt; = Box::new(instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box(instance_box_type));

    let instance: TupleType = Default::default();
    let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
    assert_eq!((0), mod_box_static_fn::get_static_box_type_ref(instance_box_type));
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-23" id="参考资料-23">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std Box</a></li>
</ul>
<h1><a class="header" href="#共享篋基于封装的动态调度实现" id="共享篋基于封装的动态调度实现">共享篋：基于封装的动态调度实现</a></h1>
<p>　　在这一节里，列出基于指针类型<code>Box</code>封装的动态调度实现。</p>
<h2><a class="header" href="#学习内容-26" id="学习内容-26">学习内容</a></h2>
<ul>
<li>了解和学习基于指针类型<code>Box</code>封装的动态函数实现方法</li>
</ul>
<h2><a class="header" href="#篇目-30" id="篇目-30">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0">动态模块实现</a></li>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E5%BA%94%E7%94%A8">动态模块应用</a></li>
<li><a href="hello-mod-trait/lib-dynamic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#动态模块实现" id="动态模块实现">动态模块实现</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: src/mod_dynamic_fn.rs
use super::mod_trait::TraitCanal;

pub fn get_dynamic_box(canal: Box&lt;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_trait_ref(canal: Box&lt;&amp;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_ref(canal: &amp;Box&lt;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}

pub fn get_dynamic_box_and_trait_ref(canal: &amp;Box&lt;&amp;dyn TraitCanal&gt;) -&gt; (u32) {
    canal.get_tuple()
}
</code></pre></pre>
<h2><a class="header" href="#动态模块应用" id="动态模块应用">动态模块应用</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: examples/box_dynamic_hello.rs
use mod_trait_exerci::mod_box_dynamic_fn;
use mod_trait_exerci::mod_trait::StructType;
use mod_trait_exerci::mod_trait::TraitCanal;
use mod_trait_exerci::mod_trait::TupleType;

// clear &amp;&amp; cargo run --example box_dynamic_hello
fn main() {
    let instance: StructType = Default::default();
    let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));

    let instance: StructType = Default::default();
    let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));

    let instance: TupleType = Default::default();
    let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));

    let instance: TupleType = Default::default();
    let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
    assert_eq!((0), mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
}

</code></pre></pre>
<h2><a class="header" href="#参考资料-24" id="参考资料-24">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#共享篋单元测试代码解释" id="共享篋单元测试代码解释">共享篋：单元测试代码解释</a></h1>
<p>　　在这一节里，实现共享篋每一个模块的单元测试代码。</p>
<h2><a class="header" href="#学习内容-27" id="学习内容-27">学习内容</a></h2>
<ul>
<li>了解和学习实现基于不同类型的单元测试方法</li>
</ul>
<h2><a class="header" href="#篇目-31" id="篇目-31">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/lib-tests.html#%E6%A8%A1%E5%9D%97mod_bare%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">模块<code>mod_bare</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%A8%A1%E5%9D%97mod_trait%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于实例的模块<code>mod_trait</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块的实例单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8BBox%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块静态函数的类型<code>Box</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8BBox%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">基于中间模块动态函数的类型<code>Box</code>单元测试</a></li>
<li><a href="hello-mod-trait/lib-tests.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#模块mod_bare单元测试" id="模块mod_bare单元测试">模块<code>mod_bare</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_bare.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_bare
<span class="boring">[cfg(test)]
</span>mod tests {
    use mod_trait_exerci::mod_bare;
    use mod_bare::StructType;
    use mod_bare::TupleType;

<span class="boring">    [test]
</span>    fn it_works_with_struct_default() {
        let instance: StructType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_struct_struct() {
        let instance = StructType{data:(0)};
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_struct() {
        let instance_default: StructType = Default::default();
        let instance_struct = StructType{data:(0)};
        assert_eq!(instance_default, instance_struct);
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple_default() {
        let instance: TupleType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple_struct() {
        let instance = TupleType(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple() {
        let instance_default: TupleType = Default::default();
        let instance_tuple = TupleType(0);
        assert_eq!(instance_default, instance_tuple);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于实例的模块mod_trait单元测试" id="基于实例的模块mod_trait单元测试">基于实例的模块<code>mod_trait</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_trait_instance.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_trait_instance
<span class="boring">[cfg(test)]
</span>mod tests {
    use mod_trait_exerci::mod_trait;
    use mod_trait::TraitCanal;
    use mod_trait::StructType;
    use mod_trait::TupleType;

<span class="boring">    [test]
</span>    fn it_works_with_struct_default() {
        let instance: StructType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_struct_new() {
        let instance = StructType::new(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_struct() {
        let instance_default: StructType = Default::default();
        let instance_struct = StructType::new(0);
        assert_eq!(instance_default, instance_struct);
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple_default() {
        let instance: TupleType = Default::default();
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple_struct() {
        let instance = TupleType::new(0);
        assert_eq!(0, instance.get_tuple());
        assert_eq!((0), instance.get_tuple());
    }

<span class="boring">    [test]
</span>    fn it_works_with_tuple() {
        let instance_default: TupleType = Default::default();
        let instance_tuple = TupleType::new(0);
        assert_eq!(instance_default, instance_tuple);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于中间模块的实例单元测试" id="基于中间模块的实例单元测试">基于中间模块的实例单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_mod_trait_fn.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// $ clear &amp;&amp; cargo test --test u_for_mod_trait_fn
<span class="boring">[cfg(test)]
</span>mod tests {
    use mod_trait_exerci::mod_static_fn;
    use mod_trait_exerci::mod_dynamic_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TupleType;

<span class="boring">    [test]
</span>    fn it_works_with_fn_struct_default() {
        let instance: StructType = Default::default();
        let data = mod_static_fn::get_static_type_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
        let data = mod_dynamic_fn::get_dynamic_trait_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
    }

<span class="boring">    [test]
</span>    fn it_works_with_fn_tuple_default() {
        let instance: TupleType = Default::default();
        let data = mod_static_fn::get_static_type_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
        let data = mod_dynamic_fn::get_dynamic_trait_ref(&amp;instance);
        assert_eq!(0, data);
        assert_eq!((0), data);
    }
}
</code></pre></pre>
<h2><a class="header" href="#基于中间模块静态函数的类型box单元测试" id="基于中间模块静态函数的类型box单元测试">基于中间模块静态函数的类型<code>Box</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_box_static_hello.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// clear &amp;&amp; cargo test --test u_for_box_static_hello
<span class="boring">[cfg(test)]
</span>mod tests {
    use mod_trait_exerci::mod_box_static_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TraitCanal;
    use mod_trait::TupleType;

<span class="boring">    [test]
</span>    fn struct_static_box() {
        let instance: StructType = Default::default();
        let instance_box_type: Box&lt;StructType&gt; = Box::new(instance);
        //assert_eq!(0, mod_box_static_fn::get_static_type_ref(&amp;instance_box_type));
        //assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance));
        assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box(instance_box_type));
    }

<span class="boring">    [test]
</span>    fn struct_static_box_ref_and_type_ref() {
        let instance: StructType = Default::default();
        let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box_type_ref(instance_box_type));
    }

<span class="boring">    [test]
</span>    fn tuple_static_box() {
        let instance: TupleType = Default::default();
        let instance_box_type: Box&lt;TupleType&gt; = Box::new(instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box(instance_box_type));
    }

<span class="boring">    [test]
</span>    fn tuple_static_box_type() {
        let instance: TupleType = Default::default();
        let instance_box_type: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_static_fn::get_static_box_and_type_ref(&amp;instance_box_type));
        assert_eq!(0, mod_box_static_fn::get_static_box_type_ref(instance_box_type));
    }
}

</code></pre></pre>
<h2><a class="header" href="#基于中间模块动态函数的类型box单元测试" id="基于中间模块动态函数的类型box单元测试">基于中间模块动态函数的类型<code>Box</code>单元测试</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">// File: tests/u_for_box_dynamic_hello.rs
// clear &amp;&amp; cargo test
// clear &amp;&amp; cargo test --package mod_trait_exerci
// clear &amp;&amp; cargo test --test u_for_box_dynamic_hello
<span class="boring">[cfg(test)]
</span>mod tests {
    use mod_trait_exerci::mod_box_dynamic_fn;
    use mod_trait_exerci::mod_trait;
    use mod_trait::StructType;
    use mod_trait::TraitCanal;
    use mod_trait::TupleType;

<span class="boring">    [test]
</span>    fn struct_dynamic_box() {
        let instance: StructType = Default::default();
        let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));
    }

<span class="boring">    [test]
</span>    fn struct_dynamic_box_and_trait() {
        let instance: StructType = Default::default();
        let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
    }

<span class="boring">    [test]
</span>    fn tulpe_dynamic_box() {
        let instance: TupleType = Default::default();
        let instance_box_trait: Box&lt;dyn TraitCanal&gt; = Box::new(instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box(instance_box_trait));
    }

<span class="boring">    [test]
</span>    fn tulpe_dynamic_box_trait() {
        let instance: TupleType = Default::default();
        let instance_box_trait: Box&lt;&amp;dyn TraitCanal&gt; = Box::new(&amp;instance);
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_and_trait_ref(&amp;instance_box_trait));
        assert_eq!(0, mod_box_dynamic_fn::get_dynamic_box_trait_ref(instance_box_trait));
    }
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-25" id="参考资料-25">参考资料</a></h2>
<ul>
<li></li>
</ul>
<h1><a class="header" href="#题外话-12" id="题外话-12">题外话</a></h1>
<h2><a class="header" href="#篇目-32" id="篇目-32">篇目</a></h2>
<ul>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B">泛型类型实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B">泛型方法实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B">泛型实现实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E8%B4%A8%E5%AE%9E%E4%BE%8B">泛型特质实例</a></li>
<li><a href="hello-mod-trait/off-topic.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#泛型类型实例" id="泛型类型实例">泛型类型实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(unused_variables)]
</span>struct Struct&lt;T&gt; (T);

// clear &amp;&amp; cargo run --example generics_type_hello
fn main() {
    let instance = Struct(0u8);
    let instance = Struct(0u32);
    let instance = Struct('0');
    let instance = Struct(0.0);
    let instance = Struct(&quot;0.0&quot;);
    let instance = Struct(());
    let instance = Struct([0]);
    let instance = Struct(Struct(0.0f64));
}
</code></pre></pre>
<h2><a class="header" href="#泛型方法实例" id="泛型方法实例">泛型方法实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(unused_variables)]
</span>use std::fmt::Debug;

fn print&lt;T: Debug&gt;(x: T) {
    println!(&quot;{:?}&quot;, x);
}

// clear &amp;&amp; cargo run --example generics_fn_hello
fn main() {
    print(0u8);
    print(0u32);
    print('0');
    print(0.0);
    print(&quot;0.0&quot;);
    print(());
    print([0]);
}
</code></pre></pre>
<h2><a class="header" href="#泛型实现实例" id="泛型实现实例">泛型实现实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(unused_variables)]
</span>struct Struct&lt;T&gt; (T);

impl&lt;S&gt; Struct&lt;S&gt; {
    fn get(&amp;self) -&gt; &amp;S {
        &amp;self.0
    }
}
// clear &amp;&amp; cargo run --example generics_impl_hello
fn main() {
    let instance = Struct(0u8);
    instance.get();
    let instance = Struct(0u32);
    instance.get();

    let instance = Struct('0');
    instance.get();
    let instance = Struct(&quot;0&quot;);
    instance.get();
}
</code></pre></pre>
<h2><a class="header" href="#泛型特质实例" id="泛型特质实例">泛型特质实例</a></h2>
<pre><pre class="playpen"><code class="language-rust editable"><span class="boring">![allow(unused_variables)]
</span>struct Struct&lt;T&gt; (T);

trait Trait&lt;U&gt; {
    fn get(&amp;self) -&gt; &amp;U;
}

impl&lt;S&gt; Trait&lt;S&gt; for Struct&lt;S&gt; {
    fn get(&amp;self) -&gt; &amp;S {
        &amp;self.0
    }
}

// clear &amp;&amp; cargo run --example generics_trait_hello
fn main() {
    let instance = Struct(0u8);
    instance.get();
    let instance = Struct(0u32);
    instance.get();

    let instance = Struct('0');
    instance.get();
    let instance = Struct(&quot;0&quot;);
    instance.get();
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">// Dynamically Sized Types (DSTs)
// https://doc.rust-lang.org/nomicon/exotic-sizes.html
struct MySuperSliceable&lt;T: ?Sized&gt; {
    info: u32,
    data: T
}

fn main() {
    let sized: MySuperSliceable&lt;[u8; 8]&gt; = MySuperSliceable {
        info: 17,
        data: [0; 8],
    };

    let dynamic: &amp;MySuperSliceable&lt;[u8]&gt; = &amp;sized;

    // prints: &quot;17 [0, 0, 0, 0, 0, 0, 0, 0]&quot;
    println!(&quot;{} {:?}&quot;, dynamic.info, &amp;dynamic.data);
}
</code></pre></pre>
<h2><a class="header" href="#参考资料-26" id="参考资料-26">参考资料</a></h2>
<ul>
<li><a href="https://tutorialedge.net/rust/learning-generics-in-rust/">learning-generics-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">book ch10-01-syntax</a></li>
<li></li>
</ul>
<p><a href="https://crates.io/crates/borrowing_exerci"><img src="https://img.shields.io/crates/v/borrowing_exerci?label=borrowing_exerci" alt="Crates.io" /></a>
<a href="https://github.com/cnruby/learn-rust-by-crates/tree/master/hello-borrowing"><img src="https://img.shields.io/badge/hello--borrowing-code-yellowgreen" alt="The Crate borrowing_exerci Code" /></a></p>
<blockquote>
<p>$$\text{只有心灵的淡定宁静，继而产生的身心愉悦，才是幸福的真正源泉}$$</p>
</blockquote>
<h1><a class="header" href="#软件篋borrowing_exerci" id="软件篋borrowing_exerci">软件篋borrowing_exerci</a></h1>
<h2><a class="header" href="#re-sizable-type--dynamical-type--resizable-containers--a-heap-allocated-value-of-type" id="re-sizable-type--dynamical-type--resizable-containers--a-heap-allocated-value-of-type">re-sizable type / dynamical type / resizable containers / a heap allocated value of type:</a></h2>
<ul>
<li>their size is not known at compile time, but they can grow or shrink at any time</li>
<li>capacity / length</li>
<li>Vectors are re-sizable arrays, A contiguous growable array type</li>
<li>slices</li>
<li>String</li>
<li>(vec, list, map, set, hashmap, string, etc... )</li>
</ul>
<h2><a class="header" href="#fixed-size-type--static-type--a-regular-fixed-size-type--a-stack-allocated-value-of-type" id="fixed-size-type--static-type--a-regular-fixed-size-type--a-stack-allocated-value-of-type">fixed-size type / static type / a regular fixed size type / a stack allocated value of type:</a></h2>
<ul>
<li>the array is a fixed-size list of elements, A fixed-size array</li>
<li>length</li>
</ul>
<p>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to dynamically sized types they also have their addition data compared.</p>
<h2><a class="header" href="#参考资料-27" id="参考资料-27">参考资料</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/22596920/split-a-module-across-several-files">split-a-module-across-several-files</a></li>
<li><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">ch07-05-separating-modules-into-different-files</a></li>
<li><a href="https://chronicbuildfailure.co/splitting-up-modules-in-rust-5ad7713201d5">splitting-up-modules-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html">references-and-borrowing</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/borrow.html">rust-by-example/scope/borrow</a></li>
<li><a href="http://squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html">rust-borrowing-and-ownership</a></li>
<li><a href="https://medium.com/@bugaevc/understanding-rust-ownership-borrowing-lifetimes-ff9ee9f79a9c">understanding-rust-ownership-borrowing-lifetimes</a></li>
<li><a href="https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust">you-can-t-turn-off-the-borrow-checker-in-rust</a></li>
<li><a href="https://users.rust-lang.org/t/cant-derive-copy-because-of-string/18665/6">cant-derive-copy-because-of-string</a></li>
<li><a href="https://users.rust-lang.org/t/whats-the-difference-between-trait-copy-and-clone/2609">whats-the-difference-between-trait-copy-and-clone</a></li>
<li><a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone">what-is-the-difference-between-copy-and-clone</a></li>
<li><a href="https://www.codevamping.com/2018/12/rust-move-copy/">rust-move-copy</a></li>
<li><a href="https://www.snoyman.com/blog/2018/10/rust-crash-course-02-basics-of-ownership">rust-crash-course-02-basics-of-ownership</a></li>
<li><a href="https://jeenalee.com/2016/08/29/move-clone-copy.html">move-clone-copy</a></li>
<li><a href="https://facility9.com/2016/04/the-basics-of-rust-structs/">the-basics-of-rust-structs</a></li>
<li><a href="http://blog.joncairns.com/2015/10/a-single-command-to-compile-and-run-rust-programs/">a-single-command-to-compile-and-run-rust-programs</a></li>
<li><a href="https://stackoverflow.com/questions/41322300/how-to-execute-rust-code-directly-on-unix-systems-using-the-shebang">how-to-execute-rust-code-directly-on-unix-systems-using-the-shebang</a></li>
<li></li>
</ul>
<h2><a class="header" href="#关于软件篋borrowing_exerci" id="关于软件篋borrowing_exerci">关于软件篋borrowing_exerci</a></h2>
<p>使用方法</p>
<ul>
<li><a href="https://users.rust-lang.org/t/cargo-test-internal-packages/5187/2">cargo-test-internal-packages</a></li>
</ul>
<h1><a class="header" href="#克隆clone和复制copy" id="克隆clone和复制copy">克隆（Clone）和复制（Copy）</a></h1>
<p>use_clone_array.rs</p>
<h2><a class="header" href="#复制copy和克隆clone有什么区别" id="复制copy和克隆clone有什么区别">复制（Copy）和克隆（Clone）有什么区别？</a></h2>
<h3><a class="header" href="#表达方式不同" id="表达方式不同">表达方式不同</a></h3>
<p>Copies happen implicitly, for example as part of an assignment y = x. The behavior of Copy is not overloadable; it is always a simple bit-wise copy.</p>
<p>Rust is explicit first!!!
Cloning is an explicit action, x.clone(). The implementation of Clone can provide any type-specific behavior necessary to duplicate values safely. For example, the implementation of Clone for String needs to copy the pointed-to string buffer in the heap. A simple bitwise copy of String values would merely copy the pointer, leading to a double free down the line. For this reason, String is Clone but not Copy.</p>
<p>Clone is a supertrait of Copy, so everything which is Copy must also implement Clone. If a type is Copy then its Clone implementation only needs to return *self (see the example above).</p>
<p>By the way, every Copy type is also required to be Clone. However, they are not required to do the same thing! For your own types, .clone() can be an arbitrary method of your choice, whereas implicit copying will always trigger a memcpy, not the clone(&amp;self) implementation.</p>
<p>复制：
y = x</p>
<p>克隆
y = x.clone()</p>
<p>Arrays with Copy elements are intrinsically Copy themselves, so the Clone implementation can trivially dereference and return self by-value.</p>
<p>具有Copy元素的数组本质上就是复制自身，因此Clone实现可以琐碎地取消引用并返回自身按值。</p>
<h3><a class="header" href="#内部实现不同" id="内部实现不同">内部实现不同</a></h3>
<p>Clone is designed for arbitrary duplications: a Clone implementation for a type T can do arbitrarily complicated operations required to create a new T. It is a normal trait (other than being in the prelude), and so requires being used like a normal trait, with method calls, etc.</p>
<p>The Copy trait represents values that can be safely duplicated via memcpy: things like reassignments and passing an argument by-value to a function are always memcpys, and so for Copy types, the compiler understands that it doesn't need to consider those a move.</p>
<h3><a class="header" href="#类型区别不同" id="类型区别不同">类型区别不同</a></h3>
<p>Copy is meant to be implemented for &quot;cheap&quot; types, such as u8 in the example. If you write a quite heavyweight type, for which you think a move is more efficient than a copy, make it not impl Copy. Note that in the u8 case, you cannot possibly be more efficient with a move, since under the hood it would probably at least entail a pointer copy -- which is already as expensive as a u8 copy, so why bother.</p>
<h2><a class="header" href="#问题when-should-my-type-be-copy" id="问题when-should-my-type-be-copy">问题：When should my type be Copy?</a></h2>
<p>Always. If it warns add Copy unless you have a really good reason not to do that.
总是。 如果警告显示，请添加“复制”，除非您有充分的理由不这样做。</p>
<p>According to the docs, Copy should be implemented for all types that is possible. </p>
<p>Even if your huge struct is Copy there is nothing that prevents you from passing it by reference. Copy just makes copying more convenient. Besides, if you do something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>struct Huge {}
let a = Huge::new(); // and Huge implements Copy
let b = a;
// continue to work with 'b' here, never touch 'a' again.
<span class="boring">}
</code></pre></pre>
<p>then LLVM will happily optimize the copy away. Personally I would recommend deriving Copy for all types that can, with the exception of types that control access to some kind of resource (but in that case perhaps you don't want them to implement Clone either).</p>
<p>Right, but what if I accidentally continued to use a after is was copied? I would prefer to have the compiler tell me that I (possibly) unnecessarily copied a large struct and that if I really intended on doing that, I should do it explicitly with .clone().</p>
<h2><a class="header" href="#为什么存在克隆" id="为什么存在克隆">为什么存在克隆？</a></h2>
<p>That’s reserved for Clone. There are two reasons:</p>
<p>a Copy copy can be caused by something innocuous like a = b or a function call; it should not be allowed to execute arbitrary code</p>
<p>a move (which is possible for all types) is (under the hood) always the same as a copy, just that the compiler doesn’t let you access the source anymore</p>
<p>Copy requires that the value can be copied using a simple memcpy of the bytes on the stack. But copying a String not only needs to copy the value on the stack (which is just capacity, length and a pointer to the contents) but also to create a new allocation that duplicates the contents.</p>
<p>This is also why Rc, while cheap, cannot be Copy: it needs to increment the reference counter.</p>
<p>o ensure your remark:</p>
<ul>
<li>String is copyable, use .clone()</li>
<li>String is not implicitly copyable, because that would cause non-obvious memory allocations to occur</li>
</ul>
<h2><a class="header" href="#两种不同特质实现" id="两种不同特质实现">两种不同特质实现</a></h2>
<p>This explicitness shows in the two traits you have here:</p>
<p>Clone is about indicating how to create a new instance, and must be called explicitly. Most types (but not all) can be copied using it.</p>
<p>Copy is a specific compiler trait which indicates that the developer wishes to activate implicit copying for the type; it is only available if a shallow copy is equivalent to a deep copy, which ensures that no memory allocation will occur as part of those implicit copies</p>
<h2><a class="header" href="#代码说明" id="代码说明">代码说明</a></h2>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">[derive(Debug, Clone, Copy)]
</span>struct Point { x: i32, y: i32 }

fn main() {
    let a = Point{x:3,y:4};
    let b = a; // line#1:  call copy method
    
    let c = b.clone(); // is some difference here with last statement line#1 ?

   println!(&quot;origin={:?} copied={:?} cloned={:?}&quot;,a,b,c);
}
</code></pre></pre>
<p>The short explanation is “Clone is a way of copying a type that can run arbitrary code. Copy is a way of copying a type that just takes a memcpy.” Since Clone is more general than Copy, you can automatically make anything Copy Clone as well.</p>
<p>In your case, they’re the same. you’re just using a different method.</p>
<h3><a class="header" href="#问题" id="问题">问题</a></h3>
<p>Can I understand as Clone is a deep-copy, and Copy is shadow-copy? </p>
<p>Clone opens the possibility that the type might do either a deep or shallow copy: &quot;arbitrarily complicated&quot;. </p>
<h2><a class="header" href="#参考资料-28" id="参考资料-28">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">std/marker/trait.Copy</a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone">whats-the-difference-between-copy-and-clone</a></li>
<li><a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone">what-is-the-difference-between-copy-and-clone</a></li>
<li><a href="https://users.rust-lang.org/t/whats-the-difference-between-trait-copy-and-clone/2609">whats-the-difference-between-trait-copy-and-clone</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/2xxjda/when_should_my_type_be_copy/">when_should_my_type_be_copy</a></li>
<li><a href="https://users.rust-lang.org/t/cant-derive-copy-because-of-string/18665/11">cant-derive-copy-because-of-string</a></li>
<li><a href="https://stackoverflow.com/questions/38215753/how-do-i-implement-copy-and-clone-for-a-type-that-contains-a-string">how-do-i-implement-copy-and-clone-for-a-type-that-contains-a-string</a></li>
<li><a href="https://stackoverflow.com/questions/38304666/how-to-define-a-copyable-struct-containing-a-string">how-to-define-a-copyable-struct-containing-a-string</a></li>
</ul>
<h1><a class="header" href="#引用reference与指针pointer基本概念" id="引用reference与指针pointer基本概念">引用<code>Reference</code>与指针<code>Pointer</code>基本概念</a></h1>
<h2><a class="header" href="#学习内容-28" id="学习内容-28">学习内容</a></h2>
<ul>
<li>了解和学习引用<code>Reference</code>与指针<code>Pointer</code>概念</li>
</ul>
<h2><a class="header" href="#篇目-33" id="篇目-33">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88Pointer">什么是指针<code>Pointer</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8Reference">什么是引用<code>Reference</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%95%E7%94%A8Reference%E4%B8%8E%E6%8C%87%E9%92%88Pointer">Rust语言的引用<code>Reference</code>与指针<code>Pointer</code></a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A">引用实例解释</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E4%BB%8B%E7%BB%8DRust%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">介绍Rust的指针类型</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%AF%8Bprettytable-rs%E5%92%8Cripgrep">开发工具：软件篋prettytable-rs和ripgrep</a></li>
<li><a href="hello-borrowing/reference-pointer.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#什么是指针pointer" id="什么是指针pointer">什么是指针<code>Pointer</code></a></h2>
<p>　　Rust语言技术术语，既有其本身专门的技术术语，如软件篋<code>crate</code>、借用<code>Borrowing</code>和生命周期<code>Lifttime</code>等，也有一般计算机科学技术术语，如变量、类型和指针<code>Pointer</code>等。但是，对于一般技术术语，在Rust语言里也是有不同的内涵意义和实现形式。</p>
<p>　　<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">引用英文</a></p>
<blockquote>
<p>In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. </p>
</blockquote>
<p>直接翻译：在计算机科学中，指针是编程语言的对象，用于存储位于计算机内存中的另一个值的内存地址。</p>
<p>解读：</p>
<ul>
<li>指针是一个对象<code>object</code>或者说实例<code>instance</code>，它是指针类型的对象；</li>
<li>指针也是变量，与其它变量完全一样；</li>
<li>指针变量也绑定一个值，与其它变量绑定不一样的值，它绑定一种特殊值，就是内存地址；</li>
<li>在绑定的内存地址值下，也是一个变量；</li>
</ul>
<h2><a class="header" href="#什么是引用reference" id="什么是引用reference">什么是引用<code>Reference</code></a></h2>
<p>　　<a href="https://de.wikipedia.org/wiki/Referenz_(Programmierung)">引用德文</a></p>
<blockquote>
<p>Eine Referenz ist ein Verweis auf ein Objekt. Eine Referenz ist damit ein Aliasname für ein bereits bestehendes Objekt.</p>
</blockquote>
<p>直接翻译：引用是关于对象的参照物。因此引用是现有对象的别名。</p>
<p>解读：</p>
<ul>
<li>引用是总是与一个对象关联起来的；</li>
<li>从本质上，引用就是相关联的对象，只是表现形式不同而已；</li>
</ul>
<h2><a class="header" href="#rust语言的引用reference与指针pointer" id="rust语言的引用reference与指针pointer">Rust语言的引用<code>Reference</code>与指针<code>Pointer</code></a></h2>
<p>　　在Rust语言里，所有指针都是其自己的类型。且存在很多的指针<code>pointer</code>类型。比如，从Rust语言结构上分析，引用<code>reference</code>类型是一种指针类型，且最简单的指针类型，从内容上分析，每一个指针类型都包含引用的内存地址。引用<code>reference</code>类型的对象是最常见的。下面通过最简单的示意图了解什么是指针概念：</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-05_reference_integer.png" alt="image" /></p>
<p>　　从说明示意图结构上看到，引用<code>reference</code>类型的对象<code>ref_u8</code>与整数u8类型的对象<code>instance</code>是完全一样的，只是其值不同而已。</p>
<p>　　但是Rust语言在处理其值的方法有所不同。这是因为，Rust通常专注于非指针对象的值或者指针对象的引用对象值（即内容中有趣的部分），而不是指针对象的标识（内存地址）。比如下面代码，使用宏println!简单格式打印它们的值都是一样的，只有使用特殊格式，才能打印出引用对象的值，即内存地址。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>let instance = 42_u8;
let ref_u8 = &amp;instance;
println!(&quot;{}&quot;, instance);
println!(&quot;{}&quot;, ref_u8);
println!(&quot;{:p}&quot;, ref_u8);
<span class="boring">}
</code></pre></pre>
<p>　　Rust语言指针类型可以分为三大类：引用（包括<a href="https://doc.rust-lang.org/reference/types/pointer.html">共享引用和可变引用</a>）、<a href="https://doc.rust-lang.org/guide-pointers.html">原始引用</a>和智能引用<code>smart pointer</code>。其中前面两类类是Rust语言本身的，而第三类是属于标准库的。这里重点说明共享引用和原始引用。</p>
<p>　　Ⓘ　共享引用指向其他值所拥有的内存。当创建共享引用值时，引用将防止该值的直接改变。除了下面说明的原始指针之外，Rust语言其他指针都是安全的，并且都具有其生命周期。</p>
<p>　　Ⓘ　原始指针是没有安全性保证的指针。</p>
<p>　　在Rust代码中通常不提倡和不鼓励使用原始指针。Rust语言的原始指针与C语言的指针是等效的。原始指针可以为null，也可以指向垃圾，它们也没有生命周期。</p>
<p>　　为了以后说明问题简单化，我们把上面示意图统一成如下形式：</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-04_reference_integer.png" alt="image" /></p>
<h2><a class="header" href="#引用实例解释" id="引用实例解释">引用实例解释</a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-08_reference_str.png" alt="image" /></p>
<p>　　借助于上面两个引用和一个原始引用的示意图，理解下面相关代码的意义。</p>
<p>　　在函数<code>main()</code>里，一共有四段代码，前面两段代码形成了上面示意图内容，后面两段代码是获取它们的地址，以便说明问题。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File ./exmaples/use_references_simple.rs
// clear &amp;&amp; cargo run --example use_references_simple | bat -l cmd
<span class="boring">![allow(unused_variables)]
</span>
fn main() {
    let instance :&amp;str = &quot;Hello&quot;;
    let instance = &quot;Hello&quot;;

    let copy_instance :&amp;str = instance;
    let copy_instance = instance;

    println!(&quot;instance reference address = {:p}&quot;, instance);
    println!(&quot;copy_instance reference address = {:p}&quot;, copy_instance);

    println!(&quot;instance address = {:p}&quot;, &amp;instance);
    println!(&quot;copy_instance address = {:p}&quot;, &amp;copy_instance);
}

</code></pre></pre>
<p>　　第一段的两行代码是等效的，实际只需要一行代码就可以了。这代码把字符串文字绑定了变量<code>instance</code>同时，也形成了原始指针，变量<code>instance</code>的地址值指向了原始指针的地址。</p>
<p>　　第二段的两行代码也是等效的，实际只需要一行代码就可以了。这代码把变量<code>instance</code>绑定到新变量<code>copy_instance</code>，这种绑定方式Rust语言称之为复制（Copy），这里它不会产生新原始指针，而是指向与变量<code>instance</code>相同的原始指针地址。</p>
<p>　　从下面程序输出结果，也可以得到验证上面的阐述。第一行和第二行的地址就是原始指针的内存地址，而第三行和第四行的地址是两个引用变量自身的内存地址，注意，它们不是变量的内容值（内存地址）。</p>
<pre><code>───────┬──────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼──────────────────────────────────────────────────────────────────────────
   1   │ instance reference address = 0x101c39b20
   2   │ copy_instance reference address = 0x101c39b20
   3   │ instance address = 0x7fff5dfe81a0
   4   │ copy_instance address = 0x7fff5dfe81c0
───────┴──────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#题外话-13" id="题外话-13">题外话</a></h2>
<h3><a class="header" href="#介绍rust的指针类型列表" id="介绍rust的指针类型列表">介绍Rust的指针类型列表</a></h3>
<table><thead><tr><th>种类</th><th>类型</th><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td>共享引用</td><td>&amp;T</td><td>引用<code>Reference</code></td><td>允许一个或者多个引用来类型T</td></tr>
<tr><td>可变引用</td><td>&amp;mut T</td><td>可变引用<code>Mutable Reference</code></td><td>仅允许单个引用来读和写类型T</td></tr>
<tr><td>智能引用</td><td>Box<T></td><td>Box指针</td><td>处于堆上类型T的指针类型，该类型只能有单个所有者，它可以读取和写入类型T。</td></tr>
<tr><td>智能引用</td><td>Rc<T></td><td>参考计数指针</td><td>处于堆上类型T的指针类型，该类型可以有多个所有者，它们可以读取类型T。</td></tr>
<tr><td>智能引用</td><td>Arc<T></td><td>核参考计数指针</td><td>与类型Rc<T>一样，但适用于在线程之间安全共享</td></tr>
<tr><td>原始引用</td><td>*const T</td><td>原始指针<code>Raw pointer</code></td><td>不安全地读取访问类型T</td></tr>
<tr><td>原始引用</td><td>*mut T</td><td>可变原始指针<code>Mutable raw pointer</code></td><td>不安全地读取和写入访问类型T</td></tr>
</tbody></table>
<p><img src="hello-borrowing/../../hello-borrowing/images/rust_container_pointer.png" alt="image" /></p>
<h3><a class="header" href="#开发工具软件篋prettytable-rs" id="开发工具软件篋prettytable-rs">开发工具：软件篋prettytable-rs</a></h3>
<p>　　使用工具软件篋prettytable-rs可以使得程序输出更加美观。</p>
<p>　　为了使用该工具，需要将下面代码放入文件Cargo.toml的<code>[dependencies]</code>段里：</p>
<pre><code>prettytable-rs = &quot;0.8.0&quot;
</code></pre>
<p>　　具体使用实例代码如下：</p>
<pre><pre class="playpen"><code class="language-rust editable">// File ./exmaples/use_references.rs
// clear &amp;&amp; cargo run --example use_references | bat -l cmd

<span class="boring">[macro_use] extern crate prettytable;
</span>
fn main() {
    let instance = &quot;Hello&quot;;

    let copy_instance = instance;

    let table = table!([&quot;Name&quot;, &quot;Value&quot;, &quot;Remark&quot;],
                       [&quot;instance reference address&quot;, format!(&quot;{:p}&quot;, instance), &quot;is equal to the following line&quot;],
                       [&quot;copy_instance reference address&quot;, format!(&quot;{:p}&quot;, copy_instance), &quot;&quot;],
                       [&quot;instance address&quot;, format!(&quot;{:p}&quot;, &amp;instance), &quot;is not equal to the following line&quot;],
                       [&quot;copy_instance address&quot;, format!(&quot;{:p}&quot;, &amp;copy_instance), &quot;&quot;]);

    table.printstd();
}

</code></pre></pre>
<p>　　程序输出结果：</p>
<pre><code>───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────
       │ STDIN
───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ +---------------------------------+----------------+------------------------------------+
   2   │ | Name                            | Value          | Remark                             |
   3   │ +---------------------------------+----------------+------------------------------------+
   4   │ | instance reference address      | 0x104f58ba0    | is equal to the following line     |
   5   │ +---------------------------------+----------------+------------------------------------+
   6   │ | copy_instance reference address | 0x104f58ba0    |                                    |
   7   │ +---------------------------------+----------------+------------------------------------+
   8   │ | instance address                | 0x7fff5ad3fa50 | is not equal to the following line |
   9   │ +---------------------------------+----------------+------------------------------------+
  10   │ | copy_instance address           | 0x7fff5ad3fa60 |                                    |
  11   │ +---------------------------------+----------------+------------------------------------+
───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre>
<h2><a class="header" href="#参考资料-29" id="参考资料-29">参考资料</a></h2>
<ul>
<li><a href="https://crates.io/crates/chars">crate chars</a></li>
<li><a href="https://stackoverflow.com/questions/27150652/how-can-i-get-an-array-or-a-slice-from-a-raw-pointer">how-can-i-get-an-array-or-a-slice-from-a-raw-pointer</a></li>
<li><a href="https://users.rust-lang.org/t/mutation-slice-from-raw-pointer/19912">mutation-slice-from-raw-pointer</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html">std slice fn.from_raw_parts</a></li>
<li><a href="https://stackoverflow.com/questions/27852613/why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po">why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po</a></li>
<li><a href="https://shahuwang.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust%20Pointers.html">Rust的指针类型</a> </li>
<li><a href="https://www.cs.brandeis.edu/%7Ecs146a/rust/doc-02-21-2015/book/pointers.html#cheat-sheet">pointers cheat-sheet</a></li>
<li><a href="http://chenju2k6.github.io/blog/2019/05/rustlearn">Rust learning notes</a></li>
<li><a href="https://medium.com/@orbitalK/why-the-machine-b9803a77fa29">why-the-machine</a></li>
</ul>
<h1><a class="header" href="#引用类型与原始指针解释" id="引用类型与原始指针解释">引用、类型与原始指针解释</a></h1>
<h2><a class="header" href="#学习内容-29" id="学习内容-29">学习内容</a></h2>
<ul>
<li>了解和学习Rust语言引用<code>Reference</code>、类型与原始指针<code>Pointer</code>关系</li>
</ul>
<h2><a class="header" href="#篇目-34" id="篇目-34">篇目</a></h2>
<ul>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Bstr%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E5%9B%BE">引用类型<code>&amp;str</code>与原始指针关系图</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8BString%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E5%9B%BE">引用类型<code>&amp;String</code>与原始指针关系图</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%95%E7%94%A8%E3%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A">引用、类型与原始指针解释</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Chars">开发工具Cha(rs)</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%AF%8Bripgrep">开发工具：软件篋ripgrep</a></li>
<li><a href="hello-borrowing/reference-type-pointer.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2><a class="header" href="#引用类型str与原始指针关系图" id="引用类型str与原始指针关系图">引用类型<code>&amp;str</code>与原始指针关系图</a></h2>
<p>　　字符串<code>String</code>类型由三个部分组成：指向原始指针的指针地址、其长度和容量。该指针地址指向内部缓冲字符串（buffer string），用于存储其数据。</p>
<p>方法<code>as_ptr()</code>功能是将字符串切片转换为原始指针。
方法<code>as_str()</code>功能是提取包含整个<code>String</code>的字符串切片。</p>
<pre><pre class="playpen"><code class="language-rust editable">// File: ./examples/use_raw_pointer_str.rs
// clear &amp;&amp; cargo run --example use_raw_pointer_str | bat -l cmd

<span class="boring">![allow(unused_variables)]
</span>
use std::slice;

fn main() {
    println!(&quot;&quot;);
    let instance :String = String::from(&quot;Hello&quot;);
    let ref_raw :*const u8 = instance.as_ptr();
    println!(&quot;instance value = {}&quot;, instance);
    println!(&quot;instance reference raw address = {:?}&quot;, ref_raw);

    println!(&quot;&quot;);
    let ref_str :&amp;str = &amp;instance;
    let ref_str = instance.as_str();
    let ref_str :&amp;str = instance.as_str();
    let ref_str :&amp;str = &amp;instance[0..=4];
    println!(&quot;ref_str value = {}&quot;, ref_str);
    println!(&quot;ref_str owned address = {:p}&quot;, ref_str);    
    let ref_str :*const u8 = ref_str.as_ptr();

    assert_eq!(ref_raw, ref_str);

    println!(&quot;&quot;);
    let slice = unsafe { slice::from_raw_parts(&amp;ref_raw, 5) };
    dbg!(slice);

    assert_eq!(&amp;ref_raw, &amp;slice[0]);

    println!(&quot;&quot;);
    let slice = unsafe { slice::from_raw_parts(ref_raw, 5) };
    dbg!(slice);
}
</code></pre></pre>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-07-pointers.png" alt="image" /></p>
<h2><a class="header" href="#引用类型string与原始指针关系图" id="引用类型string与原始指针关系图">引用类型<code>&amp;String</code>与原始指针关系图</a></h2>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-01-pointers.png" alt="image" /></p>
<pre><pre class="playpen"><code class="language-rust editable">// File: ./examples/use_raw_pointer_string.rs
// clear &amp;&amp; cargo run --example use_raw_pointer_string | bat -l cmd

<span class="boring">![allow(unused_variables)]
</span>
use std::slice;

fn main() {
    println!(&quot;&quot;);
    let instance :String = String::from(&quot;Hello&quot;);
    let ref_raw = instance.as_ptr();
    println!(&quot;instance value = {}&quot;, instance);
    println!(&quot;instance reference raw address = {:?}&quot;, ref_raw);

    println!(&quot;&quot;);
    let ref_string :&amp;String = &amp;instance;
    //let ref_string = &amp;instance;
    println!(&quot;ref_string value = {}&quot;, ref_string);
    println!(&quot;ref_string owned address = {:p}&quot;, ref_string);
    let ref_string :*const u8 = ref_string.as_ptr();

    assert_eq!(ref_raw, ref_string);

    println!(&quot;&quot;);
    let slice = unsafe { slice::from_raw_parts(&amp;ref_raw, 5) };
    dbg!(slice);
    
    assert_eq!(&amp;ref_raw, &amp;slice[0]);

    println!(&quot;&quot;);
    let slice = unsafe { slice::from_raw_parts(ref_raw, 5) };
    dbg!(slice);
}

</code></pre></pre>
<h2><a class="header" href="#引用类型与原始指针解释-1" id="引用类型与原始指针解释-1">引用、类型与原始指针解释</a></h2>
<p>　　引用类型<code>&amp;String</code>与引用类型<code>&amp;str</code>的区别</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-06-pointers.png" alt="image" /></p>
<p>　　Rust语言的数据类型可以理解为是一种复杂的“引用”类型。</p>
<p><img src="hello-borrowing/../../hello-borrowing/images/hello_borrowing-02_references.png" alt="image" /></p>
<h3><a class="header" href="#软件篋chars" id="软件篋chars">软件篋Cha(rs)</a></h3>
<p>cargo install chars
chars 'H'</p>
<h3><a class="header" href="#软件篋ripgrep" id="软件篋ripgrep">软件篋ripgrep</a></h3>
<p>cargo install ripgrep
ifconfig | rg netmask</p>
<h2><a class="header" href="#参考资料-30" id="参考资料-30">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html">std string struct.String</a></li>
</ul>
<h1><a class="header" href="#借用关键词move" id="借用关键词move">借用关键词move</a></h1>
<h1><a class="header" href="#应用篋类型实例借用方法" id="应用篋类型实例借用方法">应用篋：类型实例借用方法</a></h1>
<p>string_type.rs</p>
<h1><a class="header" href="#应用篋引用借用实例" id="应用篋引用借用实例">应用篋：引用借用实例</a></h1>
<h1><a class="header" href="#应用篋指针类型借用方法" id="应用篋指针类型借用方法">应用篋：指针类型借用方法</a></h1>
<h2><a class="header" href="#参考资料-31" id="参考资料-31">参考资料</a></h2>
<ul>
<li>http://smallcultfollowing.com/babysteps/blog/2012/07/17/borrowed-pointer-tutorial/</li>
<li>https://aminb.gitbooks.io/rust-for-c/content/borrowed/index.html</li>
<li>https://stackoverflow.com/questions/18943513/rust-borrowed-pointers-syntax</li>
</ul>
<h1><a class="header" href="#应用篋固定大小类型实例" id="应用篋固定大小类型实例">应用篋：固定大小类型实例</a></h1>
<h1><a class="header" href="#应用篋可变大小类型实例" id="应用篋可变大小类型实例">应用篋：可变大小类型实例</a></h1>
<h1><a class="header" href="#应用篋栈和堆借用方法" id="应用篋栈和堆借用方法">应用篋：栈和堆借用方法</a></h1>
<p>栈(stack)和堆(heap)</p>
<h1><a class="header" href="#应用篋函数借用方法" id="应用篋函数借用方法">应用篋：函数借用方法</a></h1>
<h1><a class="header" href="#题外话应用篋的软件包结构" id="题外话应用篋的软件包结构">题外话：应用篋的软件包结构</a></h1>
<h1><a class="header" href="#题外话cargo工具features功能" id="题外话cargo工具features功能">题外话：Cargo工具features功能</a></h1>
<h1><a class="header" href="#题外话介绍几个软件篋" id="题外话介绍几个软件篋">题外话：介绍几个软件篋</a></h1>
<h2><a class="header" href="#use" id="use">use</a></h2>
<ul>
<li>https://github.com/dtolnay/cargo-expand</li>
</ul>
<h1><a class="header" href="#第四章" id="第四章">第四章</a></h1>
<h1><a class="header" href="#关于软件篋deref_exerci" id="关于软件篋deref_exerci">关于软件篋deref_exerci</a></h1>
<h1><a class="header" href="#开发软件篋deref_exerci" id="开发软件篋deref_exerci">开发软件篋deref_exerci</a></h1>
<h1><a class="header" href="#使用软件篋deref_exerci" id="使用软件篋deref_exerci">使用软件篋deref_exerci</a></h1>
<h1><a class="header" href="#软件篋macro_exerci" id="软件篋macro_exerci">软件篋macro_exerci</a></h1>
<h1><a class="header" href="#关于软件篋macro_exerci" id="关于软件篋macro_exerci">关于软件篋macro_exerci</a></h1>
<h1><a class="header" href="#开发软件篋macro_exerci" id="开发软件篋macro_exerci">开发软件篋macro_exerci</a></h1>
<h1><a class="header" href="#使用软件篋macro_exerci" id="使用软件篋macro_exerci">使用软件篋macro_exerci</a></h1>
<h1><a class="header" href="#软件篋generics_exerci" id="软件篋generics_exerci">软件篋generics_exerci</a></h1>
<h1><a class="header" href="#关于软件篋generics_exerci" id="关于软件篋generics_exerci">关于软件篋generics_exerci</a></h1>
<h1><a class="header" href="#开发软件篋generics_exerci" id="开发软件篋generics_exerci">开发软件篋generics_exerci</a></h1>
<h1><a class="header" href="#使用软件篋generics_exerci" id="使用软件篋generics_exerci">使用软件篋generics_exerci</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playpen_line_numbers = true;
        </script>
        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
